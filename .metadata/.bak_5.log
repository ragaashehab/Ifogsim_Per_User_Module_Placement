!SESSION 2020-10-15 12:17:24.501 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=14.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

This is a continuation of log file C:\Users\lenovo\Documents\Edge Computing 2020\iFogSim-master Simulator Project\iFogSim-master Static Priority -Time\.metadata\.bak_4.log
Created Time: 2020-10-15 12:35:14.643

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-10-15 12:35:14.643
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10051, count -3525, length 26081
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-10-15 12:35:16.143
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
package org.fog.test.perfeval;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.stream.Collectors;
import org.apache.commons.math3.util.Pair;
import org.cloudbus.cloudsim.Host;
import org.cloudbus.cloudsim.Log;
import org.cloudbus.cloudsim.Pe;
import org.cloudbus.cloudsim.Storage;
import org.cloudbus.cloudsim.core.CloudSim;
import org.cloudbus.cloudsim.power.PowerHost;
import org.cloudbus.cloudsim.provisioners.PeProvisionerSimple;
import org.cloudbus.cloudsim.provisioners.RamProvisionerSimple;
import org.cloudbus.cloudsim.sdn.overbooking.BwProvisionerOverbooking;
import org.cloudbus.cloudsim.sdn.overbooking.PeProvisionerOverbooking;
import org.fog.application.AppEdge;
import org.fog.application.AppLoop;
import org.fog.application.Application;
import org.fog.application.selectivity.FractionalSelectivity;
import org.fog.entities.Actuator;
import org.fog.entities.FogBroker;
import org.fog.entities.FogDevice;
import org.fog.entities.FogDeviceCharacteristics;
import org.fog.entities.Sensor;
import org.fog.entities.Tuple;
import org.fog.placement.Controller;
import org.fog.placement.ControllerEdgeward;
import org.fog.placement.LModulePlacementEdgewards;
import org.fog.placement.LatencyModulePlacementNear;
import org.fog.placement.ModuleMapping;
import org.fog.placement.ModulePlacementDifferentiated;
import org.fog.placement.ModulePlacementEdgewards;
import org.fog.placement.ModulePlacementMapping;
import org.fog.placement.ModulePlacementModified;
import org.fog.placement.ModulePlacementOnlyCloud;
import org.fog.policy.AppModuleAllocationPolicy;
import org.fog.scheduler.StreamOperatorScheduler;
import org.fog.utils.Config;
import org.fog.utils.FogLinearPowerModel;
import org.fog.utils.FogUtils;
import org.fog.utils.TimeKeeper;
import org.fog.utils.distribution.DeterministicDistribution;

/**
 * Simulation setup for  ECG
 * @author Ragaa Shehab
 *
 */ //updateTimingsOnReceipt - checkCloudletCompletion --tupleEndedExecutionUser
public class ECG {
	static List<FogDevice> fogDevices = new ArrayList<FogDevice>();
	static List<Sensor> sensors = new ArrayList<Sensor>();
	static List<Actuator> actuators = new ArrayList<Actuator>();
	static Map<Integer,FogDevice> deviceById = new HashMap<Integer,FogDevice>();	
	static List<Integer> idOfEndDevices = new ArrayList<Integer>();
	static Map<Integer, Double> deadlineInfo = new	HashMap<Integer, Double>();  // mobile id has priority
	static Map<Integer, Double> additionalMipsInfo = new HashMap<Integer, Double>(); // mobile id need tuple mips
	static Map<Integer, Map<String, Double>> deadlineInfomodule = new HashMap<Integer, Map<String,Double>>();  // mobile id has modulename with module priority
	static Map<Integer,List<Map<String, Double>>> deadlineInfomodule1 = new HashMap<Integer, List<Map<String,Double>>>();  // mobile id has modulename with module priority

	static boolean CLOUD = false;
	static int numOfDepts = 1;
	static int numOfMobilesPerDept =5;
	static double ECG_TRANSMISSION_TIME = 50.0 ; // 50.0;   //100, 50, 25 ms   100 //10s= 10000
	static public int mymips= 2000;     
	//static String placement = "Latency Module Placement"; 
	static String placement = "Latency Differentiated Module Placement"; 
	//static String placement = "Module Placement Edgeward";
	//static String placement = "Module Placement Edgeward Differentiated";
	//static String placement = "Latency Modified Module Placement";
	static double MobileCPUload= 0.1;
	
	public static void main(String[] args) {
		Log.print("Starting ECG transmission");	Log.print("             ECG transmission time ms: "); Log.print(ECG_TRANSMISSION_TIME);
		Log.print("     Depts/Mobiles =  "); Log.print (numOfDepts);Log.print("/"); Log.printLine (numOfMobilesPerDept);
		System.out.println("analytics VM mips  2000, Fog device mips: mobile 1000, dept  2800, proxy 16800" ); 

		
		try {
			Log.disable(); 	
			//Config.MAX_SIMULATION_TIME= 100000;
			int num_user = 1; // number of cloud users
			Calendar calendar = Calendar.getInstance();
			boolean trace_flag = false; // mean trace events
			CloudSim.init(num_user, calendar, trace_flag);						
			String appId = "ECG"; 
			FogBroker broker = new FogBroker("broker");			
			createFogDevices(broker.getId(), appId);
			
			Map<String, Double> moduledeadline= new HashMap<String, Double>();
			Map<String, Double> moduledeadline1;
			List<Map<String, Double>> moduledeadline1List;

			for(Integer id : idOfEndDevices){
				Double x= getvalue(5.00, 40.00);
				Double t1= 10.00; Double t2= 5.00; //Double t3= 5.00;
				deadlineInfo.put(id, x);
				
				if (placement.equals("Latency Differentiated Module Placement")||placement.equals("Module Placement Edgeward Differentiated")) {
						if(5.00 < x)&&x < 10.00) x=5.00;
						if(10.00 < x < 15.00) x=10.00;
						if(15.00 < x < 20.00) x=20.00;
						if(20.00 < x < 30.00) x=30.00;
						if(30.00 < x < 40.00) x=40.00;
					
							
						
					additionalMipsInfo.put(id, x*100); //1000
					moduledeadline1=  new HashMap<String,Double>();
					moduledeadline1List= new ArrayList<Map<String, Double>>();
					moduledeadline1.put("Client", x*100);
					moduledeadline1.put("Filtering", x*100);
					moduledeadline1.put("Monitoring", x*100);
					moduledeadline1.put("Caregiver", x*100);
					moduledeadline1.put("Cloud_Analytics", x*100);
					moduledeadline1List.add(moduledeadline1);
					deadlineInfomodule1.put(id, moduledeadline1List);
				}
				else {
					additionalMipsInfo.put(id, (double)mymips);
					moduledeadline1=  new HashMap<String,Double>();
					moduledeadline1List= new ArrayList<Map<String, Double>>();
					moduledeadline1.put("Client", (double)mymips);
					moduledeadline1.put("Filtering", (double)mymips);
					moduledeadline1.put("Monitoring", (double)mymips);
					moduledeadline1.put("Caregiver", (double)mymips);
					moduledeadline1.put("Cloud_Analytics", (double)mymips);
					moduledeadline1List.add(moduledeadline1);
					deadlineInfomodule1.put(id, moduledeadline1List);
				}
				moduledeadline.put("Filtering", (x+t1));
				deadlineInfomodule.put(id,moduledeadline);
				moduledeadline.put("Monitoring", (x+ t2));
				deadlineInfomodule.put(id,moduledeadline);
			}	
			
			deadlineInfo=deadlineInfo.entrySet()
		             .stream().sorted(Map.Entry.comparingByValue())
		             .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -> e1, LinkedHashMap::new));			
				
			Application application = createApplication(appId, broker.getId());
			application.setUserId(broker.getId());
			application.setdeviceById(deviceById);
			application.setidOfEndDevices(idOfEndDevices);
			application.setDeadlineInfo(deadlineInfo);
			application.setDeadlineInfomodule(deadlineInfomodule);
			application.setDeadlineInfomodule1(deadlineInfomodule1);
		    application.setAdditionalMipsInfo(additionalMipsInfo);
		    application.setplacement(placement);
		    application.setMobileCPUload(MobileCPUload);
		    
		    System.out.println(String.format("%-25s%s" ,"User Priority ASC ", application.getDeadlineInfo()));
			System.out.println(String.format("%-25s%s" ,"Module Tuble MIPS ",application.getAdditionalMipsInfo()));
		   /// System.out.println(String.format("%-25s%s" ,"Module Priority ",application.getDeadlineInfomodule()));
		    System.out.println(String.format("%-25s%s" ,"Module Priority1 ",application.getDeadlineInfomodule1()));

		    System.out.println("mobile CPU load "+ application.getMobileCPUload());
		    		
			Controller controller = null;
			ModuleMapping moduleMapping = ModuleMapping.createModuleMapping(); // initializing a module mapping			
			moduleMapping.addModuleToDevice("Cloud_Analytics", "cloud");
			for(FogDevice device : fogDevices){
				if(device.getName().startsWith("m"))
					moduleMapping.addModuleToDevice("Client", device.getName());
				}
			if(CLOUD){			 
				moduleMapping.addModuleToDevice("Caregiver", "cloud");
				moduleMapping.addModuleToDevice("Monitoring", "cloud");
				moduleMapping.addModuleToDevice("Filtering", "cloud");
				System.out.println("cloud only module placement, tuple mips= "+ mymips);
				controller = new ControllerEdgeward("master-controller", fogDevices, sensors, actuators);
				controller.submitApplication(application, 0, new ModulePlacementMapping(fogDevices, application,moduleMapping));
				}
			else {
				moduleMapping.addModuleToDevice("Caregiver", "proxy-server");
				switch (placement) { 
				case "Latency Module Placement":{			
					System.out.println("Per User Basic module placement");//", Tuple mips= "+ mymips
					controller = new Controller("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LatencyModulePlacementNear(fogDevices, sensors, actuators, application, moduleMapping));
					break;}	
				case "Latency Modified Module Placement":{
					System.out.println("Per User Modified module placement");
					controller = new Controller("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new ModulePlacementModified(fogDevices, sensors, actuators, application, moduleMapping));
					break;}
				case "Latency Differentiated Module Placement":{
					System.out.println("Per User Differentiated module placement, variable Module/Tuple mips ");
					controller = new Controller("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LatencyModulePlacementNear(fogDevices, sensors, actuators, application, moduleMapping));
					break;} //ModulePlacementDifferentiated
				case "Module Placement Edgeward":{
					System.out.println("Per module placement");
					controller = new ControllerEdgeward("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LModulePlacementEdgewards(fogDevices, sensors, actuators, application, moduleMapping));
					break;}
				case "Module Placement Edgeward Differentiated":{
					System.out.println("Per module Differentiated placement");
					controller = new ControllerEdgeward("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LModulePlacementEdgewards(fogDevices, sensors, actuators, application, moduleMapping));
					break;}
				}
				}
					
			TimeKeeper.getInstance().setSimulationStartTime(Calendar.getInstance().getTimeInMillis());
			CloudSim.startSimulation();
			CloudSim.stopSimulation();
			Log.printLine("ECG finished!");
		} catch (Exception e) {
			e.printStackTrace();
			Log.printLine("Unwanted errors happen");
		}
	}	
/****************************************************************************************
	 * Creates the fog devices in the physical topology of the simulation.
	 * @param userId
	 * @param appId
	 */
	private static void createFogDevices(int userId, String appId) {  // 44800
		FogDevice cloud = createFogDevice("cloud", 44800, 40000, 100, 10000, 0, 0.01, 16*103, 16*83.25); // creates the fog device Cloud at the apex of the hierarchy with level=0
		cloud.setParentId(-1);		 
		FogDevice proxy = createFogDevice("proxy-server", 16800 , 4000, 10000, 10000, 1, 0.0, 107.339, 83.4333); // 2800
		proxy.setParentId(cloud.getId()); // setting Cloud as parent of the Proxy Server
		proxy.setUplinkLatency(100); // latency of connection from Proxy Server to the Cloud is 100 ms		
		fogDevices.add(cloud);
		deviceById.put(cloud.getId(), cloud);
		fogDevices.add(proxy);
		deviceById.put(proxy.getId(), proxy);		
		for(int i=0;i<numOfDepts;i++){
			addGw(i+"", userId, appId, proxy.getId()); // adding a fog device for every Gateway in physical topology. The parent of each gateway is the Proxy Server
		}	
	}

	private static FogDevice addGw(String id, int userId, String appId, int parentId){
		FogDevice dept = createFogDevice("d-"+id, 2800, 4000, 10000, 10000, 2, 0.0, 107.339, 83.4333); //2800
		fogDevices.add(dept);
		deviceById.put(dept.getId(), dept);
		dept.setParentId(parentId);
		dept.setUplinkLatency(4); // latency of connection between gateways and proxy server is 4 ms
		for(int i=0;i<numOfMobilesPerDept;i++){
			String mobileId = id+"-"+i;
			FogDevice mobile = addMobile(mobileId, userId, appId, dept.getId()); // adding mobiles to the physical topology. Smartphones have been modeled as fog devices as well.
			mobile.setUplinkLatency(2); // latency of connection between the smartphone and proxy server is 4 ms
			fogDevices.add(mobile);
			deviceById.put(mobile.getId(), mobile);
		}
		return dept;
	}
	
	private static FogDevice addMobile(String id, int userId, String appId, int parentId){
		FogDevice mobile = createFogDevice("m-"+id, 1000, 1000, 10000, 270, 3, 0, 87.53, 82.44); //1000   
		mobile.setParentId(parentId);
		idOfEndDevices.add(mobile.getId());
		Sensor ecgsensor = new Sensor("s-"+id, "ECG", userId, appId, new DeterministicDistribution(ECG_TRANSMISSION_TIME)); // inter-transmission time of EEG sensor follows a deterministic distribution
		sensors.add(ecgsensor);
		Actuator display = new Actuator("a-"+id, userId, appId, "DISPLAY");
		actuators.add(display);
		ecgsensor.setGatewayDeviceId(mobile.getId());
		ecgsensor.setLatency(6.0);  // latency of connection between EEG sensors and the parent Smartphone is 6 ms
		display.setGatewayDeviceId(mobile.getId());
		display.setLatency(1.0);  // latency of connection between Display actuator and the parent Smartphone is 1 ms
		return mobile;
	}
	
/*****************************************************************************************
	 * Creates a vanilla fog device
	 * @param nodeName name of the device to be used in simulation
	 * @param mips MIPS
	 * @param ram RAM
	 * @param upBw uplink bandwidth
	 * @param downBw downlink bandwidth
	 * @param level hierarchy level of the device
	 * @param ratePerMips cost rate per MIPS used
	 * @param busyPower
	 * @param idlePower
	 * @return
	 */
	private static FogDevice createFogDevice(String nodeName, long mips,
			int ram, long upBw, long downBw, int level, double ratePerMips, double busyPower, double idlePower) {
		
		List<Pe> peList = new ArrayList<Pe>();
		// 3. Create PEs and add these into a list.
		peList.add(new Pe(0, new PeProvisionerOverbooking(mips))); // need to store Pe id and MIPS Rating
		
		int hostId = FogUtils.generateEntityId();
		long storage = 1000000; // host storage
		int bw = 10000;
		PowerHost host = new PowerHost(
				hostId,
				new RamProvisionerSimple(ram),
				new BwProvisionerOverbooking(bw),
				storage,
				peList,
				new StreamOperatorScheduler(peList),
				new FogLinearPowerModel(busyPower, idlePower)
			);

		List<Host> hostList = new ArrayList<Host>();
		hostList.add(host);

		String arch = "x86"; // system architecture
		String os = "Linux"; // operating system
		String vmm = "Xen";
		double time_zone = 10.0; // time zone this resource located
		double cost = 3.0; // the cost of using processing in this resource
		double costPerMem = 0.05; // the cost of using memory in this resource
		double costPerStorage = 0.001; // the cost of using storage in this	// resource
		double costPerBw = 0.0; // the cost of using bw in this resource
		LinkedList<Storage> storageList = new LinkedList<Storage>(); // we are not adding SAN devices by now

		FogDeviceCharacteristics characteristics = new FogDeviceCharacteristics(
				arch, os, vmm, host, time_zone, cost, costPerMem,
				costPerStorage, costPerBw);

		FogDevice fogdevice = null;
		try {
			fogdevice = new FogDevice(nodeName, characteristics, 
					new AppModuleAllocationPolicy(hostList), storageList, 10 , upBw, downBw, 0, ratePerMips); //10 : schedulingInterval  0 uplink  latency		
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		fogdevice.setLevel(level);
		return fogdevice;
	}

/******************************************************************************************
	 * Function to create the EEG Tractor Beam game application in the DDF model. 
	 * @param appId unique identifier of the application
	 * @param userId identifier of the user of the application
	 * @return
	 */
	@SuppressWarnings({"serial" })
	private static Application createApplication(String appId, int userId){
		
		Application application = Application.createApplication(appId, userId); // creates an empty application model (empty directed graph)
		
		// Adding modules (vertices) to the application model (directed graph)
		application.addAppModule("Client", 10, 2000, 1000,100,5); //250Name,int ram, int mips, long size, long bw, int modprty) size is the image size (MB)
		application.addAppModule("Filtering",10, 2000, 500, 100,4); //150
		application.addAppModule("Monitoring",10, 2000, 500,100,3); //150 
		application.addAppModule("Caregiver", 10, 2000,1000,100,2); // 150
		application.addAppModule("Cloud_Analytics",10, 3000,1000,250,1); //500("Cloud_Analytics",10, 500,1000,500,1); //
		
		// Connecting the application modules (vertices) in the application model (directed graph) with edges
		//source, destination, double tupleCpuLength, double tupleNwLength, String tupleType, int direction, int edgeType){
		application.addAppEdge("ECG", "Client", 2000, 500, "ECG", Tuple.UP, AppEdge.SENSOR);
		application.addAppEdge("Client", "Filtering", 2000, 500, "SENSOR_DATA", Tuple.UP, AppEdge.MODULE); //
		application.addAppEdge("Filtering", "Monitoring", mymips, 500, "FILTERED_DATA", Tuple.UP, AppEdge.MODULE); //
		application.addAppEdge("Monitoring", "Caregiver", mymips, 500, "ECG_REPORT", Tuple.UP, AppEdge.MODULE);  //
		application.addAppEdge("Caregiver", "Cloud_Analytics", mymips, 500, "DATA_OFFLOAD", Tuple.UP, AppEdge.MODULE); //		
		application.addAppEdge("Caregiver", "Client", mymips, 500, "State_Action", Tuple.DOWN, AppEdge.MODULE); //  
		application.addAppEdge("Client", "DISPLAY",2000, 500, "P_State_Action", Tuple.DOWN, AppEdge.ACTUATOR);  //
		application.addAppEdge("Cloud_Analytics", "Caregiver", 2000, 1000, "Advanced_Analytics", Tuple.DOWN, AppEdge.MODULE);  
		
 	    //Defining the input-output relationships (represented by selectivity) of the application modules. 
		application.addTupleMapping("Client", "ECG", "SENSOR_DATA", new FractionalSelectivity(1.0)); // 
		application.addTupleMapping("Client", "State_Action", "P_State_Action", new FractionalSelectivity(1.0)); //  
		application.addTupleMapping("Filtering", "SENSOR_DATA", "FILTERED_DATA", new FractionalSelectivity(1.0)); // 
		application.addTupleMapping("Monitoring", "FILTERED_DATA", "ECG_REPORT", new FractionalSelectivity(1.0)); //
		application.addTupleMapping("Caregiver", "ECG_REPORT", "DATA_OFFLOAD", new FractionalSelectivity(1.0)); //
		application.addTupleMapping("Caregiver", "ECG_REPORT", "State_Action", new FractionalSelectivity(1.0)); //
		application.addTupleMapping("Cloud_Analytics", "DATA_OFFLOAD", "Advanced_Analytics", new FractionalSelectivity(0.01)); //
	
		
		 // Defining application loops to monitor the latency of.
		//final AppLoop ONLY_CLOUD = new AppLoop(new ArrayList<String>(){{add("ECG");add("Client");add("Filtering");add("Monitoring");add("Caregiver");add("Client");add("DISPLAY");}}); //add("Cloud_Analytics");
        //List<AppLoop> loops = new ArrayList<AppLoop>(){{ add(ONLY_CLOUD);}};
		//final AppLoop ECG_REPORTING = new AppLoop(new ArrayList<String>(){{add("ECG");add("Client");add("Filtering");add("Monitoring");add("Caregiver");add("Client");add("DISPLAY");}});
        //List<AppLoop> loops = new ArrayList<AppLoop>(){{ add(ECG_REPORTING);}};
		final AppLoop ECG_ANALYTICS = new AppLoop(new ArrayList<String>(){{add("ECG");add("Client");add("Filtering");add("Monitoring");add("Caregiver");}});
        List<AppLoop> loops = new ArrayList<AppLoop>(){{add( ECG_ANALYTICS);}}; 
 		application.setLoops(loops);
		return application;
		}
///random number generators//////////////////////////////////////////////////////////
	private static double getvalue(double d, double e)  { 
	    Random r = new Random(); 
	    double randomValue = d + (e - d) *r.nextDouble(); 
	   // randomValue = r.nextDouble();
	    return randomValue; 
	  } 
	private static Integer getvalue(int min, int max) { 
	    Random r = new Random(); 
	    Integer randomValue = min + r.nextInt()%(max - min); 
	   // randomValue = r.nextInt(max);
	    return randomValue; 
	  }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//scheduled cloudlet processing =30,100,200,300,500 mips for filtering monitoring caregiver  
//scheduled cloudlet processing = 1000  for client and cloudanalytics modules
// mobile id, need Modulename executed with max delay (3:5)
//static Pair<String, Double> moduledeadline = new Pair <String, Double>(null,null);  // mobile id need deadline double
//static List<Pair<String, Double>> moduledeadline = new ArrayList<Pair <String, Double>>();


//if(placement.equals("Latency Differentiated Module Placement")) {		
//System.out.println(String.format("%-30s%s" ,"Per_User Differentiated Module Placement, " ," variable mips between 50 mips, "+  mymips+ " for all modules except cloud plus 1000 mips"));
//}		
//else if(placement.equals("Module Placement Edgeward")) {
//System.out.println(String.format("%-30s%20s%s%30s%10s%s" ,"Per_Module Edgeward Placement","const mips= " , mymips));
//System.out.println("Per_Module Placement,  Tuple's mips= " + mymips);
//}
///else 
//placement=="Latency Module Placement" 
//System.out.println(String.format("%-30s%20s%s%30s%10s%s" ,"Per_User Basic Module Placement","const mips= " , mymips));
//System.out.println("Per_User Basic Module Placement,  const mips= " + mymips);		

//System.out.println("Application Module mips: Client = Filtering = Monitoring = Caregiver = 300 mips , Cloud_Analytics = 600 mips");
//System.out.println("Migration Condition: Mobile Utilization >= 0.3, Proxy/Dept Utilization >= 0.9" );  //, RESOURCE_MANAGE_INTERVAL = 100 ");
//System.out.println("Enhanced Migration Conditions , RESOURCE_MANAGE_INTERVAL = 10 ");
//System.out.println("fog device scheduling interval = 10,  Application module scheduling interval = 300  ");	

//moduledeadline.put("Client", (x+ 15.0000000000000000));
//deadlineInfomodule.put(id,moduledeadline);
//moduledeadline.put("Caregiver", x);
//deadlineInfomodule.put(id,moduledeadline);				
//System.out.println("deadlineInfomodule  "+ deadlineInfomodule);
//deadlineInfomodule.put(id,moduledeadlinelist);				
//moduledeadline.clear();

/*
for(Integer id : idOfEndDevices){
	if (placement.equals("Latency Differentiated Module Placement")) {
		Integer x= getvalue(50, 500);//mymips);
		x= Math.abs(x);
		additionalMipsInfo.put(id, (double)x);  //getvalue(0,mymips)
		}
	else
		additionalMipsInfo.put(id, (double)mymips);
}
*/
/*else if(device.getName().startsWith("d")){
moduleMapping.addModuleToDevice("Filtering", device.getName());
moduleMapping.addModuleToDevice("Monitoring", device.getName());				
} */
//Controller controller = new Controller("master-controller", fogDevices, sensors, actuators);
//controller.submitApplication(application, 0, new ModulePlacementOnlyCloud(fogDevices, sensors, actuators, application));
//controller.submitApplication(application, 0, new LatencyModulePlacement(fogDevices, sensors, actuators, application, moduleMapping));
//controller.submitApplication(application, 0, new LatencyModifiedModulePlacementNew(fogDevices, sensors, actuators, application, moduleMapping));
 //LModulePlacementEdgewards  // LatencyModulePlacementNear

//TRY FogDevice cloud = createFogDevice("cloud", 448000000, 40000000, 100000, 10000000, 0, 0.01, 16*103, 16*83.25); // creates the fog device Cloud at the apex of the hierarchy with level=0
//FogDevice cloud = createFogDevice("cloud", 4480000, 4000000, 100, 10000, 0, 0.01, 16*103, 16*83.25); // creates the fog device Cloud at the apex of the hierarchy with level=0
//FogDevice proxy = createFogDevice("proxy-server", 2800, 4000, 10000, 10000, 1, 0.0, 107.339, 83.4333);

//peList.add(new Pe(0, new PeProvisionerSimple(mips))); // need to store Pe id and MIPS Rating


/*
application.addAppModule("Client", 10, 300, 1000,100,5); // adding module Client to the application model
application.addAppModule("Filtering",10, 300, 1000, 100,4); //
application.addAppModule("Monitoring",10, 300, 1000,100,3); // 
application.addAppModule("Caregiver", 10, 300,1000,100,2); // 
application.addAppModule("Cloud_Analytics",10, 600,1000,250,1); //("Cloud_Analytics",10, 500,1000,500,1); //
*/
/*application.addAppEdge("ECG", "Client", 3000, 1000, "ECG", Tuple.UP, AppEdge.SENSOR);
application.addAppEdge("Client", "Filtering", 3000, 500, "SENSOR_DATA", Tuple.UP, AppEdge.MODULE); //
application.addAppEdge("Filtering", "Monitoring", (30+ mymips), 500, "FILTERED_DATA", Tuple.UP, AppEdge.MODULE); // 
application.addAppEdge("Monitoring", "Cloud_Analytics", 1000, 500, "DATA_OFFLOAD", Tuple.UP, AppEdge.MODULE); // 
application.addAppEdge("Monitoring", "Caregiver", (60+ mymips) , 500, "ECG_REPORT", Tuple.UP, AppEdge.MODULE);  // 
application.addAppEdge("Cloud_Analytics", "Caregiver", 3500, 1000, "Advanced_Analytics", Tuple.DOWN, AppEdge.MODULE);  // 
application.addAppEdge("Caregiver", "Client", 1000 , 500, "State_Action", Tuple.DOWN, AppEdge.MODULE); // 
application.addAppEdge("Client", "DISPLAY",1000, 500, "P_State_Action", Tuple.DOWN, AppEdge.ACTUATOR);  //
 */
//application.addAppEdge("Caregiver", "Cloud_Analytics", 3000, 1000, "DECISION", Tuple.UP, AppEdge.MODULE); //
// application.addTupleMapping("Cloud_Analytics", "DECISION", "Advanced_Analytics", new FractionalSelectivity(0.001)); //
//final AppLoop HBR_Analytics = new AppLoop(new ArrayList<String>(){{add("HBR"); add("Client"); add("Monitoring"); add("Cloud_Analytics"); add("Caregiver"); add("Client"); add("DISPLAY");}});

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10052, count -3525, length 26082
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-10-15 12:35:16.145
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.StringIndexOutOfBoundsException: offset 10052, count -3525, length 26082
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:324)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10052, count -3525, length 26082
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	... 16 more
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10052, count -3525, length 26082
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2020-10-15 12:35:16.145
!MESSAGE offset 10052, count -3525, length 26082
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10052, count -3525, length 26082
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2020-10-15 12:35:16.145
!MESSAGE offset 10052, count -3525, length 26082
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10052, count -3525, length 26082
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-10-15 12:35:16.147
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.StringIndexOutOfBoundsException: offset 10052, count -3525, length 26082
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:324)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10052, count -3525, length 26082
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	... 16 more
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10052, count -3525, length 26082
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2020-10-15 12:35:16.147
!MESSAGE offset 10052, count -3525, length 26082
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10052, count -3525, length 26082
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-10-15 12:35:16.163
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10052, count -3525, length 26082
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-10-15 12:35:16.164
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10052, count -3525, length 26082
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-10-15 12:35:16.959
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10052, count -3525, length 26082
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-10-15 12:35:16.960
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10052, count -3525, length 26082
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-10-15 12:35:19.167
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
package org.fog.test.perfeval;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.stream.Collectors;
import org.apache.commons.math3.util.Pair;
import org.cloudbus.cloudsim.Host;
import org.cloudbus.cloudsim.Log;
import org.cloudbus.cloudsim.Pe;
import org.cloudbus.cloudsim.Storage;
import org.cloudbus.cloudsim.core.CloudSim;
import org.cloudbus.cloudsim.power.PowerHost;
import org.cloudbus.cloudsim.provisioners.PeProvisionerSimple;
import org.cloudbus.cloudsim.provisioners.RamProvisionerSimple;
import org.cloudbus.cloudsim.sdn.overbooking.BwProvisionerOverbooking;
import org.cloudbus.cloudsim.sdn.overbooking.PeProvisionerOverbooking;
import org.fog.application.AppEdge;
import org.fog.application.AppLoop;
import org.fog.application.Application;
import org.fog.application.selectivity.FractionalSelectivity;
import org.fog.entities.Actuator;
import org.fog.entities.FogBroker;
import org.fog.entities.FogDevice;
import org.fog.entities.FogDeviceCharacteristics;
import org.fog.entities.Sensor;
import org.fog.entities.Tuple;
import org.fog.placement.Controller;
import org.fog.placement.ControllerEdgeward;
import org.fog.placement.LModulePlacementEdgewards;
import org.fog.placement.LatencyModulePlacementNear;
import org.fog.placement.ModuleMapping;
import org.fog.placement.ModulePlacementDifferentiated;
import org.fog.placement.ModulePlacementEdgewards;
import org.fog.placement.ModulePlacementMapping;
import org.fog.placement.ModulePlacementModified;
import org.fog.placement.ModulePlacementOnlyCloud;
import org.fog.policy.AppModuleAllocationPolicy;
import org.fog.scheduler.StreamOperatorScheduler;
import org.fog.utils.Config;
import org.fog.utils.FogLinearPowerModel;
import org.fog.utils.FogUtils;
import org.fog.utils.TimeKeeper;
import org.fog.utils.distribution.DeterministicDistribution;

/**
 * Simulation setup for  ECG
 * @author Ragaa Shehab
 *
 */ //updateTimingsOnReceipt - checkCloudletCompletion --tupleEndedExecutionUser
public class ECG {
	static List<FogDevice> fogDevices = new ArrayList<FogDevice>();
	static List<Sensor> sensors = new ArrayList<Sensor>();
	static List<Actuator> actuators = new ArrayList<Actuator>();
	static Map<Integer,FogDevice> deviceById = new HashMap<Integer,FogDevice>();	
	static List<Integer> idOfEndDevices = new ArrayList<Integer>();
	static Map<Integer, Double> deadlineInfo = new	HashMap<Integer, Double>();  // mobile id has priority
	static Map<Integer, Double> additionalMipsInfo = new HashMap<Integer, Double>(); // mobile id need tuple mips
	static Map<Integer, Map<String, Double>> deadlineInfomodule = new HashMap<Integer, Map<String,Double>>();  // mobile id has modulename with module priority
	static Map<Integer,List<Map<String, Double>>> deadlineInfomodule1 = new HashMap<Integer, List<Map<String,Double>>>();  // mobile id has modulename with module priority

	static boolean CLOUD = false;
	static int numOfDepts = 1;
	static int numOfMobilesPerDept =5;
	static double ECG_TRANSMISSION_TIME = 50.0 ; // 50.0;   //100, 50, 25 ms   100 //10s= 10000
	static public int mymips= 2000;     
	//static String placement = "Latency Module Placement"; 
	static String placement = "Latency Differentiated Module Placement"; 
	//static String placement = "Module Placement Edgeward";
	//static String placement = "Module Placement Edgeward Differentiated";
	//static String placement = "Latency Modified Module Placement";
	static double MobileCPUload= 0.1;
	
	public static void main(String[] args) {
		Log.print("Starting ECG transmission");	Log.print("             ECG transmission time ms: "); Log.print(ECG_TRANSMISSION_TIME);
		Log.print("     Depts/Mobiles =  "); Log.print (numOfDepts);Log.print("/"); Log.printLine (numOfMobilesPerDept);
		System.out.println("analytics VM mips  2000, Fog device mips: mobile 1000, dept  2800, proxy 16800" ); 

		
		try {
			Log.disable(); 	
			//Config.MAX_SIMULATION_TIME= 100000;
			int num_user = 1; // number of cloud users
			Calendar calendar = Calendar.getInstance();
			boolean trace_flag = false; // mean trace events
			CloudSim.init(num_user, calendar, trace_flag);						
			String appId = "ECG"; 
			FogBroker broker = new FogBroker("broker");			
			createFogDevices(broker.getId(), appId);
			
			Map<String, Double> moduledeadline= new HashMap<String, Double>();
			Map<String, Double> moduledeadline1;
			List<Map<String, Double>> moduledeadline1List;

			for(Integer id : idOfEndDevices){
				Double x= getvalue(5.00, 40.00);
				Double t1= 10.00; Double t2= 5.00; //Double t3= 5.00;
				deadlineInfo.put(id, x);
				
				if (placement.equals("Latency Differentiated Module Placement")||placement.equals("Module Placement Edgeward Differentiated")) {
						if(5.00 < x)&&(x < 10.00) x=5.00;
						if(10.00 < x < 15.00) x=10.00;
						if(15.00 < x < 20.00) x=20.00;
						if(20.00 < x < 30.00) x=30.00;
						if(30.00 < x < 40.00) x=40.00;
					
							
						
					additionalMipsInfo.put(id, x*100); //1000
					moduledeadline1=  new HashMap<String,Double>();
					moduledeadline1List= new ArrayList<Map<String, Double>>();
					moduledeadline1.put("Client", x*100);
					moduledeadline1.put("Filtering", x*100);
					moduledeadline1.put("Monitoring", x*100);
					moduledeadline1.put("Caregiver", x*100);
					moduledeadline1.put("Cloud_Analytics", x*100);
					moduledeadline1List.add(moduledeadline1);
					deadlineInfomodule1.put(id, moduledeadline1List);
				}
				else {
					additionalMipsInfo.put(id, (double)mymips);
					moduledeadline1=  new HashMap<String,Double>();
					moduledeadline1List= new ArrayList<Map<String, Double>>();
					moduledeadline1.put("Client", (double)mymips);
					moduledeadline1.put("Filtering", (double)mymips);
					moduledeadline1.put("Monitoring", (double)mymips);
					moduledeadline1.put("Caregiver", (double)mymips);
					moduledeadline1.put("Cloud_Analytics", (double)mymips);
					moduledeadline1List.add(moduledeadline1);
					deadlineInfomodule1.put(id, moduledeadline1List);
				}
				moduledeadline.put("Filtering", (x+t1));
				deadlineInfomodule.put(id,moduledeadline);
				moduledeadline.put("Monitoring", (x+ t2));
				deadlineInfomodule.put(id,moduledeadline);
			}	
			
			deadlineInfo=deadlineInfo.entrySet()
		             .stream().sorted(Map.Entry.comparingByValue())
		             .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -> e1, LinkedHashMap::new));			
				
			Application application = createApplication(appId, broker.getId());
			application.setUserId(broker.getId());
			application.setdeviceById(deviceById);
			application.setidOfEndDevices(idOfEndDevices);
			application.setDeadlineInfo(deadlineInfo);
			application.setDeadlineInfomodule(deadlineInfomodule);
			application.setDeadlineInfomodule1(deadlineInfomodule1);
		    application.setAdditionalMipsInfo(additionalMipsInfo);
		    application.setplacement(placement);
		    application.setMobileCPUload(MobileCPUload);
		    
		    System.out.println(String.format("%-25s%s" ,"User Priority ASC ", application.getDeadlineInfo()));
			System.out.println(String.format("%-25s%s" ,"Module Tuble MIPS ",application.getAdditionalMipsInfo()));
		   /// System.out.println(String.format("%-25s%s" ,"Module Priority ",application.getDeadlineInfomodule()));
		    System.out.println(String.format("%-25s%s" ,"Module Priority1 ",application.getDeadlineInfomodule1()));

		    System.out.println("mobile CPU load "+ application.getMobileCPUload());
		    		
			Controller controller = null;
			ModuleMapping moduleMapping = ModuleMapping.createModuleMapping(); // initializing a module mapping			
			moduleMapping.addModuleToDevice("Cloud_Analytics", "cloud");
			for(FogDevice device : fogDevices){
				if(device.getName().startsWith("m"))
					moduleMapping.addModuleToDevice("Client", device.getName());
				}
			if(CLOUD){			 
				moduleMapping.addModuleToDevice("Caregiver", "cloud");
				moduleMapping.addModuleToDevice("Monitoring", "cloud");
				moduleMapping.addModuleToDevice("Filtering", "cloud");
				System.out.println("cloud only module placement, tuple mips= "+ mymips);
				controller = new ControllerEdgeward("master-controller", fogDevices, sensors, actuators);
				controller.submitApplication(application, 0, new ModulePlacementMapping(fogDevices, application,moduleMapping));
				}
			else {
				moduleMapping.addModuleToDevice("Caregiver", "proxy-server");
				switch (placement) { 
				case "Latency Module Placement":{			
					System.out.println("Per User Basic module placement");//", Tuple mips= "+ mymips
					controller = new Controller("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LatencyModulePlacementNear(fogDevices, sensors, actuators, application, moduleMapping));
					break;}	
				case "Latency Modified Module Placement":{
					System.out.println("Per User Modified module placement");
					controller = new Controller("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new ModulePlacementModified(fogDevices, sensors, actuators, application, moduleMapping));
					break;}
				case "Latency Differentiated Module Placement":{
					System.out.println("Per User Differentiated module placement, variable Module/Tuple mips ");
					controller = new Controller("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LatencyModulePlacementNear(fogDevices, sensors, actuators, application, moduleMapping));
					break;} //ModulePlacementDifferentiated
				case "Module Placement Edgeward":{
					System.out.println("Per module placement");
					controller = new ControllerEdgeward("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LModulePlacementEdgewards(fogDevices, sensors, actuators, application, moduleMapping));
					break;}
				case "Module Placement Edgeward Differentiated":{
					System.out.println("Per module Differentiated placement");
					controller = new ControllerEdgeward("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LModulePlacementEdgewards(fogDevices, sensors, actuators, application, moduleMapping));
					break;}
				}
				}
					
			TimeKeeper.getInstance().setSimulationStartTime(Calendar.getInstance().getTimeInMillis());
			CloudSim.startSimulation();
			CloudSim.stopSimulation();
			Log.printLine("ECG finished!");
		} catch (Exception e) {
			e.printStackTrace();
			Log.printLine("Unwanted errors happen");
		}
	}	
/****************************************************************************************
	 * Creates the fog devices in the physical topology of the simulation.
	 * @param userId
	 * @param appId
	 */
	private static void createFogDevices(int userId, String appId) {  // 44800
		FogDevice cloud = createFogDevice("cloud", 44800, 40000, 100, 10000, 0, 0.01, 16*103, 16*83.25); // creates the fog device Cloud at the apex of the hierarchy with level=0
		cloud.setParentId(-1);		 
		FogDevice proxy = createFogDevice("proxy-server", 16800 , 4000, 10000, 10000, 1, 0.0, 107.339, 83.4333); // 2800
		proxy.setParentId(cloud.getId()); // setting Cloud as parent of the Proxy Server
		proxy.setUplinkLatency(100); // latency of connection from Proxy Server to the Cloud is 100 ms		
		fogDevices.add(cloud);
		deviceById.put(cloud.getId(), cloud);
		fogDevices.add(proxy);
		deviceById.put(proxy.getId(), proxy);		
		for(int i=0;i<numOfDepts;i++){
			addGw(i+"", userId, appId, proxy.getId()); // adding a fog device for every Gateway in physical topology. The parent of each gateway is the Proxy Server
		}	
	}

	private static FogDevice addGw(String id, int userId, String appId, int parentId){
		FogDevice dept = createFogDevice("d-"+id, 2800, 4000, 10000, 10000, 2, 0.0, 107.339, 83.4333); //2800
		fogDevices.add(dept);
		deviceById.put(dept.getId(), dept);
		dept.setParentId(parentId);
		dept.setUplinkLatency(4); // latency of connection between gateways and proxy server is 4 ms
		for(int i=0;i<numOfMobilesPerDept;i++){
			String mobileId = id+"-"+i;
			FogDevice mobile = addMobile(mobileId, userId, appId, dept.getId()); // adding mobiles to the physical topology. Smartphones have been modeled as fog devices as well.
			mobile.setUplinkLatency(2); // latency of connection between the smartphone and proxy server is 4 ms
			fogDevices.add(mobile);
			deviceById.put(mobile.getId(), mobile);
		}
		return dept;
	}
	
	private static FogDevice addMobile(String id, int userId, String appId, int parentId){
		FogDevice mobile = createFogDevice("m-"+id, 1000, 1000, 10000, 270, 3, 0, 87.53, 82.44); //1000   
		mobile.setParentId(parentId);
		idOfEndDevices.add(mobile.getId());
		Sensor ecgsensor = new Sensor("s-"+id, "ECG", userId, appId, new DeterministicDistribution(ECG_TRANSMISSION_TIME)); // inter-transmission time of EEG sensor follows a deterministic distribution
		sensors.add(ecgsensor);
		Actuator display = new Actuator("a-"+id, userId, appId, "DISPLAY");
		actuators.add(display);
		ecgsensor.setGatewayDeviceId(mobile.getId());
		ecgsensor.setLatency(6.0);  // latency of connection between EEG sensors and the parent Smartphone is 6 ms
		display.setGatewayDeviceId(mobile.getId());
		display.setLatency(1.0);  // latency of connection between Display actuator and the parent Smartphone is 1 ms
		return mobile;
	}
	
/*****************************************************************************************
	 * Creates a vanilla fog device
	 * @param nodeName name of the device to be used in simulation
	 * @param mips MIPS
	 * @param ram RAM
	 * @param upBw uplink bandwidth
	 * @param downBw downlink bandwidth
	 * @param level hierarchy level of the device
	 * @param ratePerMips cost rate per MIPS used
	 * @param busyPower
	 * @param idlePower
	 * @return
	 */
	private static FogDevice createFogDevice(String nodeName, long mips,
			int ram, long upBw, long downBw, int level, double ratePerMips, double busyPower, double idlePower) {
		
		List<Pe> peList = new ArrayList<Pe>();
		// 3. Create PEs and add these into a list.
		peList.add(new Pe(0, new PeProvisionerOverbooking(mips))); // need to store Pe id and MIPS Rating
		
		int hostId = FogUtils.generateEntityId();
		long storage = 1000000; // host storage
		int bw = 10000;
		PowerHost host = new PowerHost(
				hostId,
				new RamProvisionerSimple(ram),
				new BwProvisionerOverbooking(bw),
				storage,
				peList,
				new StreamOperatorScheduler(peList),
				new FogLinearPowerModel(busyPower, idlePower)
			);

		List<Host> hostList = new ArrayList<Host>();
		hostList.add(host);

		String arch = "x86"; // system architecture
		String os = "Linux"; // operating system
		String vmm = "Xen";
		double time_zone = 10.0; // time zone this resource located
		double cost = 3.0; // the cost of using processing in this resource
		double costPerMem = 0.05; // the cost of using memory in this resource
		double costPerStorage = 0.001; // the cost of using storage in this	// resource
		double costPerBw = 0.0; // the cost of using bw in this resource
		LinkedList<Storage> storageList = new LinkedList<Storage>(); // we are not adding SAN devices by now

		FogDeviceCharacteristics characteristics = new FogDeviceCharacteristics(
				arch, os, vmm, host, time_zone, cost, costPerMem,
				costPerStorage, costPerBw);

		FogDevice fogdevice = null;
		try {
			fogdevice = new FogDevice(nodeName, characteristics, 
					new AppModuleAllocationPolicy(hostList), storageList, 10 , upBw, downBw, 0, ratePerMips); //10 : schedulingInterval  0 uplink  latency		
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		fogdevice.setLevel(level);
		return fogdevice;
	}

/******************************************************************************************
	 * Function to create the EEG Tractor Beam game application in the DDF model. 
	 * @param appId unique identifier of the application
	 * @param userId identifier of the user of the application
	 * @return
	 */
	@SuppressWarnings({"serial" })
	private static Application createApplication(String appId, int userId){
		
		Application application = Application.createApplication(appId, userId); // creates an empty application model (empty directed graph)
		
		// Adding modules (vertices) to the application model (directed graph)
		application.addAppModule("Client", 10, 2000, 1000,100,5); //250Name,int ram, int mips, long size, long bw, int modprty) size is the image size (MB)
		application.addAppModule("Filtering",10, 2000, 500, 100,4); //150
		application.addAppModule("Monitoring",10, 2000, 500,100,3); //150 
		application.addAppModule("Caregiver", 10, 2000,1000,100,2); // 150
		application.addAppModule("Cloud_Analytics",10, 3000,1000,250,1); //500("Cloud_Analytics",10, 500,1000,500,1); //
		
		// Connecting the application modules (vertices) in the application model (directed graph) with edges
		//source, destination, double tupleCpuLength, double tupleNwLength, String tupleType, int direction, int edgeType){
		application.addAppEdge("ECG", "Client", 2000, 500, "ECG", Tuple.UP, AppEdge.SENSOR);
		application.addAppEdge("Client", "Filtering", 2000, 500, "SENSOR_DATA", Tuple.UP, AppEdge.MODULE); //
		application.addAppEdge("Filtering", "Monitoring", mymips, 500, "FILTERED_DATA", Tuple.UP, AppEdge.MODULE); //
		application.addAppEdge("Monitoring", "Caregiver", mymips, 500, "ECG_REPORT", Tuple.UP, AppEdge.MODULE);  //
		application.addAppEdge("Caregiver", "Cloud_Analytics", mymips, 500, "DATA_OFFLOAD", Tuple.UP, AppEdge.MODULE); //		
		application.addAppEdge("Caregiver", "Client", mymips, 500, "State_Action", Tuple.DOWN, AppEdge.MODULE); //  
		application.addAppEdge("Client", "DISPLAY",2000, 500, "P_State_Action", Tuple.DOWN, AppEdge.ACTUATOR);  //
		application.addAppEdge("Cloud_Analytics", "Caregiver", 2000, 1000, "Advanced_Analytics", Tuple.DOWN, AppEdge.MODULE);  
		
 	    //Defining the input-output relationships (represented by selectivity) of the application modules. 
		application.addTupleMapping("Client", "ECG", "SENSOR_DATA", new FractionalSelectivity(1.0)); // 
		application.addTupleMapping("Client", "State_Action", "P_State_Action", new FractionalSelectivity(1.0)); //  
		application.addTupleMapping("Filtering", "SENSOR_DATA", "FILTERED_DATA", new FractionalSelectivity(1.0)); // 
		application.addTupleMapping("Monitoring", "FILTERED_DATA", "ECG_REPORT", new FractionalSelectivity(1.0)); //
		application.addTupleMapping("Caregiver", "ECG_REPORT", "DATA_OFFLOAD", new FractionalSelectivity(1.0)); //
		application.addTupleMapping("Caregiver", "ECG_REPORT", "State_Action", new FractionalSelectivity(1.0)); //
		application.addTupleMapping("Cloud_Analytics", "DATA_OFFLOAD", "Advanced_Analytics", new FractionalSelectivity(0.01)); //
	
		
		 // Defining application loops to monitor the latency of.
		//final AppLoop ONLY_CLOUD = new AppLoop(new ArrayList<String>(){{add("ECG");add("Client");add("Filtering");add("Monitoring");add("Caregiver");add("Client");add("DISPLAY");}}); //add("Cloud_Analytics");
        //List<AppLoop> loops = new ArrayList<AppLoop>(){{ add(ONLY_CLOUD);}};
		//final AppLoop ECG_REPORTING = new AppLoop(new ArrayList<String>(){{add("ECG");add("Client");add("Filtering");add("Monitoring");add("Caregiver");add("Client");add("DISPLAY");}});
        //List<AppLoop> loops = new ArrayList<AppLoop>(){{ add(ECG_REPORTING);}};
		final AppLoop ECG_ANALYTICS = new AppLoop(new ArrayList<String>(){{add("ECG");add("Client");add("Filtering");add("Monitoring");add("Caregiver");}});
        List<AppLoop> loops = new ArrayList<AppLoop>(){{add( ECG_ANALYTICS);}}; 
 		application.setLoops(loops);
		return application;
		}
///random number generators//////////////////////////////////////////////////////////
	private static double getvalue(double d, double e)  { 
	    Random r = new Random(); 
	    double randomValue = d + (e - d) *r.nextDouble(); 
	   // randomValue = r.nextDouble();
	    return randomValue; 
	  } 
	private static Integer getvalue(int min, int max) { 
	    Random r = new Random(); 
	    Integer randomValue = min + r.nextInt()%(max - min); 
	   // randomValue = r.nextInt(max);
	    return randomValue; 
	  }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//scheduled cloudlet processing =30,100,200,300,500 mips for filtering monitoring caregiver  
//scheduled cloudlet processing = 1000  for client and cloudanalytics modules
// mobile id, need Modulename executed with max delay (3:5)
//static Pair<String, Double> moduledeadline = new Pair <String, Double>(null,null);  // mobile id need deadline double
//static List<Pair<String, Double>> moduledeadline = new ArrayList<Pair <String, Double>>();


//if(placement.equals("Latency Differentiated Module Placement")) {		
//System.out.println(String.format("%-30s%s" ,"Per_User Differentiated Module Placement, " ," variable mips between 50 mips, "+  mymips+ " for all modules except cloud plus 1000 mips"));
//}		
//else if(placement.equals("Module Placement Edgeward")) {
//System.out.println(String.format("%-30s%20s%s%30s%10s%s" ,"Per_Module Edgeward Placement","const mips= " , mymips));
//System.out.println("Per_Module Placement,  Tuple's mips= " + mymips);
//}
///else 
//placement=="Latency Module Placement" 
//System.out.println(String.format("%-30s%20s%s%30s%10s%s" ,"Per_User Basic Module Placement","const mips= " , mymips));
//System.out.println("Per_User Basic Module Placement,  const mips= " + mymips);		

//System.out.println("Application Module mips: Client = Filtering = Monitoring = Caregiver = 300 mips , Cloud_Analytics = 600 mips");
//System.out.println("Migration Condition: Mobile Utilization >= 0.3, Proxy/Dept Utilization >= 0.9" );  //, RESOURCE_MANAGE_INTERVAL = 100 ");
//System.out.println("Enhanced Migration Conditions , RESOURCE_MANAGE_INTERVAL = 10 ");
//System.out.println("fog device scheduling interval = 10,  Application module scheduling interval = 300  ");	

//moduledeadline.put("Client", (x+ 15.0000000000000000));
//deadlineInfomodule.put(id,moduledeadline);
//moduledeadline.put("Caregiver", x);
//deadlineInfomodule.put(id,moduledeadline);				
//System.out.println("deadlineInfomodule  "+ deadlineInfomodule);
//deadlineInfomodule.put(id,moduledeadlinelist);				
//moduledeadline.clear();

/*
for(Integer id : idOfEndDevices){
	if (placement.equals("Latency Differentiated Module Placement")) {
		Integer x= getvalue(50, 500);//mymips);
		x= Math.abs(x);
		additionalMipsInfo.put(id, (double)x);  //getvalue(0,mymips)
		}
	else
		additionalMipsInfo.put(id, (double)mymips);
}
*/
/*else if(device.getName().startsWith("d")){
moduleMapping.addModuleToDevice("Filtering", device.getName());
moduleMapping.addModuleToDevice("Monitoring", device.getName());				
} */
//Controller controller = new Controller("master-controller", fogDevices, sensors, actuators);
//controller.submitApplication(application, 0, new ModulePlacementOnlyCloud(fogDevices, sensors, actuators, application));
//controller.submitApplication(application, 0, new LatencyModulePlacement(fogDevices, sensors, actuators, application, moduleMapping));
//controller.submitApplication(application, 0, new LatencyModifiedModulePlacementNew(fogDevices, sensors, actuators, application, moduleMapping));
 //LModulePlacementEdgewards  // LatencyModulePlacementNear

//TRY FogDevice cloud = createFogDevice("cloud", 448000000, 40000000, 100000, 10000000, 0, 0.01, 16*103, 16*83.25); // creates the fog device Cloud at the apex of the hierarchy with level=0
//FogDevice cloud = createFogDevice("cloud", 4480000, 4000000, 100, 10000, 0, 0.01, 16*103, 16*83.25); // creates the fog device Cloud at the apex of the hierarchy with level=0
//FogDevice proxy = createFogDevice("proxy-server", 2800, 4000, 10000, 10000, 1, 0.0, 107.339, 83.4333);

//peList.add(new Pe(0, new PeProvisionerSimple(mips))); // need to store Pe id and MIPS Rating


/*
application.addAppModule("Client", 10, 300, 1000,100,5); // adding module Client to the application model
application.addAppModule("Filtering",10, 300, 1000, 100,4); //
application.addAppModule("Monitoring",10, 300, 1000,100,3); // 
application.addAppModule("Caregiver", 10, 300,1000,100,2); // 
application.addAppModule("Cloud_Analytics",10, 600,1000,250,1); //("Cloud_Analytics",10, 500,1000,500,1); //
*/
/*application.addAppEdge("ECG", "Client", 3000, 1000, "ECG", Tuple.UP, AppEdge.SENSOR);
application.addAppEdge("Client", "Filtering", 3000, 500, "SENSOR_DATA", Tuple.UP, AppEdge.MODULE); //
application.addAppEdge("Filtering", "Monitoring", (30+ mymips), 500, "FILTERED_DATA", Tuple.UP, AppEdge.MODULE); // 
application.addAppEdge("Monitoring", "Cloud_Analytics", 1000, 500, "DATA_OFFLOAD", Tuple.UP, AppEdge.MODULE); // 
application.addAppEdge("Monitoring", "Caregiver", (60+ mymips) , 500, "ECG_REPORT", Tuple.UP, AppEdge.MODULE);  // 
application.addAppEdge("Cloud_Analytics", "Caregiver", 3500, 1000, "Advanced_Analytics", Tuple.DOWN, AppEdge.MODULE);  // 
application.addAppEdge("Caregiver", "Client", 1000 , 500, "State_Action", Tuple.DOWN, AppEdge.MODULE); // 
application.addAppEdge("Client", "DISPLAY",1000, 500, "P_State_Action", Tuple.DOWN, AppEdge.ACTUATOR);  //
 */
//application.addAppEdge("Caregiver", "Cloud_Analytics", 3000, 1000, "DECISION", Tuple.UP, AppEdge.MODULE); //
// application.addTupleMapping("Cloud_Analytics", "DECISION", "Advanced_Analytics", new FractionalSelectivity(0.001)); //
//final AppLoop HBR_Analytics = new AppLoop(new ArrayList<String>(){{add("HBR"); add("Client"); add("Monitoring"); add("Cloud_Analytics"); add("Caregiver"); add("Client"); add("DISPLAY");}});

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10053, count -3525, length 26083
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-10-15 12:35:19.168
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.StringIndexOutOfBoundsException: offset 10053, count -3525, length 26083
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:324)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10053, count -3525, length 26083
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	... 16 more
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10053, count -3525, length 26083
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2020-10-15 12:35:19.168
!MESSAGE offset 10053, count -3525, length 26083
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10053, count -3525, length 26083
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2020-10-15 12:35:19.168
!MESSAGE offset 10053, count -3525, length 26083
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10053, count -3525, length 26083
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-10-15 12:35:19.169
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.StringIndexOutOfBoundsException: offset 10053, count -3525, length 26083
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:324)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10053, count -3525, length 26083
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	... 16 more
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10053, count -3525, length 26083
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2020-10-15 12:35:19.169
!MESSAGE offset 10053, count -3525, length 26083
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10053, count -3525, length 26083
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-10-15 12:35:19.178
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10053, count -3525, length 26083
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-10-15 12:35:19.179
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10053, count -3525, length 26083
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-10-15 12:35:20.181
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
package org.fog.test.perfeval;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.stream.Collectors;
import org.apache.commons.math3.util.Pair;
import org.cloudbus.cloudsim.Host;
import org.cloudbus.cloudsim.Log;
import org.cloudbus.cloudsim.Pe;
import org.cloudbus.cloudsim.Storage;
import org.cloudbus.cloudsim.core.CloudSim;
import org.cloudbus.cloudsim.power.PowerHost;
import org.cloudbus.cloudsim.provisioners.PeProvisionerSimple;
import org.cloudbus.cloudsim.provisioners.RamProvisionerSimple;
import org.cloudbus.cloudsim.sdn.overbooking.BwProvisionerOverbooking;
import org.cloudbus.cloudsim.sdn.overbooking.PeProvisionerOverbooking;
import org.fog.application.AppEdge;
import org.fog.application.AppLoop;
import org.fog.application.Application;
import org.fog.application.selectivity.FractionalSelectivity;
import org.fog.entities.Actuator;
import org.fog.entities.FogBroker;
import org.fog.entities.FogDevice;
import org.fog.entities.FogDeviceCharacteristics;
import org.fog.entities.Sensor;
import org.fog.entities.Tuple;
import org.fog.placement.Controller;
import org.fog.placement.ControllerEdgeward;
import org.fog.placement.LModulePlacementEdgewards;
import org.fog.placement.LatencyModulePlacementNear;
import org.fog.placement.ModuleMapping;
import org.fog.placement.ModulePlacementDifferentiated;
import org.fog.placement.ModulePlacementEdgewards;
import org.fog.placement.ModulePlacementMapping;
import org.fog.placement.ModulePlacementModified;
import org.fog.placement.ModulePlacementOnlyCloud;
import org.fog.policy.AppModuleAllocationPolicy;
import org.fog.scheduler.StreamOperatorScheduler;
import org.fog.utils.Config;
import org.fog.utils.FogLinearPowerModel;
import org.fog.utils.FogUtils;
import org.fog.utils.TimeKeeper;
import org.fog.utils.distribution.DeterministicDistribution;

/**
 * Simulation setup for  ECG
 * @author Ragaa Shehab
 *
 */ //updateTimingsOnReceipt - checkCloudletCompletion --tupleEndedExecutionUser
public class ECG {
	static List<FogDevice> fogDevices = new ArrayList<FogDevice>();
	static List<Sensor> sensors = new ArrayList<Sensor>();
	static List<Actuator> actuators = new ArrayList<Actuator>();
	static Map<Integer,FogDevice> deviceById = new HashMap<Integer,FogDevice>();	
	static List<Integer> idOfEndDevices = new ArrayList<Integer>();
	static Map<Integer, Double> deadlineInfo = new	HashMap<Integer, Double>();  // mobile id has priority
	static Map<Integer, Double> additionalMipsInfo = new HashMap<Integer, Double>(); // mobile id need tuple mips
	static Map<Integer, Map<String, Double>> deadlineInfomodule = new HashMap<Integer, Map<String,Double>>();  // mobile id has modulename with module priority
	static Map<Integer,List<Map<String, Double>>> deadlineInfomodule1 = new HashMap<Integer, List<Map<String,Double>>>();  // mobile id has modulename with module priority

	static boolean CLOUD = false;
	static int numOfDepts = 1;
	static int numOfMobilesPerDept =5;
	static double ECG_TRANSMISSION_TIME = 50.0 ; // 50.0;   //100, 50, 25 ms   100 //10s= 10000
	static public int mymips= 2000;     
	//static String placement = "Latency Module Placement"; 
	static String placement = "Latency Differentiated Module Placement"; 
	//static String placement = "Module Placement Edgeward";
	//static String placement = "Module Placement Edgeward Differentiated";
	//static String placement = "Latency Modified Module Placement";
	static double MobileCPUload= 0.1;
	
	public static void main(String[] args) {
		Log.print("Starting ECG transmission");	Log.print("             ECG transmission time ms: "); Log.print(ECG_TRANSMISSION_TIME);
		Log.print("     Depts/Mobiles =  "); Log.print (numOfDepts);Log.print("/"); Log.printLine (numOfMobilesPerDept);
		System.out.println("analytics VM mips  2000, Fog device mips: mobile 1000, dept  2800, proxy 16800" ); 

		
		try {
			Log.disable(); 	
			//Config.MAX_SIMULATION_TIME= 100000;
			int num_user = 1; // number of cloud users
			Calendar calendar = Calendar.getInstance();
			boolean trace_flag = false; // mean trace events
			CloudSim.init(num_user, calendar, trace_flag);						
			String appId = "ECG"; 
			FogBroker broker = new FogBroker("broker");			
			createFogDevices(broker.getId(), appId);
			
			Map<String, Double> moduledeadline= new HashMap<String, Double>();
			Map<String, Double> moduledeadline1;
			List<Map<String, Double>> moduledeadline1List;

			for(Integer id : idOfEndDevices){
				Double x= getvalue(5.00, 40.00);
				Double t1= 10.00; Double t2= 5.00; //Double t3= 5.00;
				deadlineInfo.put(id, x);
				
				if (placement.equals("Latency Differentiated Module Placement")||placement.equals("Module Placement Edgeward Differentiated")) {
						if(5.00 < x)&& (x < 10.00) x=5.00;
						if(10.00 < x < 15.00) x=10.00;
						if(15.00 < x < 20.00) x=20.00;
						if(20.00 < x < 30.00) x=30.00;
						if(30.00 < x < 40.00) x=40.00;
					
							
						
					additionalMipsInfo.put(id, x*100); //1000
					moduledeadline1=  new HashMap<String,Double>();
					moduledeadline1List= new ArrayList<Map<String, Double>>();
					moduledeadline1.put("Client", x*100);
					moduledeadline1.put("Filtering", x*100);
					moduledeadline1.put("Monitoring", x*100);
					moduledeadline1.put("Caregiver", x*100);
					moduledeadline1.put("Cloud_Analytics", x*100);
					moduledeadline1List.add(moduledeadline1);
					deadlineInfomodule1.put(id, moduledeadline1List);
				}
				else {
					additionalMipsInfo.put(id, (double)mymips);
					moduledeadline1=  new HashMap<String,Double>();
					moduledeadline1List= new ArrayList<Map<String, Double>>();
					moduledeadline1.put("Client", (double)mymips);
					moduledeadline1.put("Filtering", (double)mymips);
					moduledeadline1.put("Monitoring", (double)mymips);
					moduledeadline1.put("Caregiver", (double)mymips);
					moduledeadline1.put("Cloud_Analytics", (double)mymips);
					moduledeadline1List.add(moduledeadline1);
					deadlineInfomodule1.put(id, moduledeadline1List);
				}
				moduledeadline.put("Filtering", (x+t1));
				deadlineInfomodule.put(id,moduledeadline);
				moduledeadline.put("Monitoring", (x+ t2));
				deadlineInfomodule.put(id,moduledeadline);
			}	
			
			deadlineInfo=deadlineInfo.entrySet()
		             .stream().sorted(Map.Entry.comparingByValue())
		             .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -> e1, LinkedHashMap::new));			
				
			Application application = createApplication(appId, broker.getId());
			application.setUserId(broker.getId());
			application.setdeviceById(deviceById);
			application.setidOfEndDevices(idOfEndDevices);
			application.setDeadlineInfo(deadlineInfo);
			application.setDeadlineInfomodule(deadlineInfomodule);
			application.setDeadlineInfomodule1(deadlineInfomodule1);
		    application.setAdditionalMipsInfo(additionalMipsInfo);
		    application.setplacement(placement);
		    application.setMobileCPUload(MobileCPUload);
		    
		    System.out.println(String.format("%-25s%s" ,"User Priority ASC ", application.getDeadlineInfo()));
			System.out.println(String.format("%-25s%s" ,"Module Tuble MIPS ",application.getAdditionalMipsInfo()));
		   /// System.out.println(String.format("%-25s%s" ,"Module Priority ",application.getDeadlineInfomodule()));
		    System.out.println(String.format("%-25s%s" ,"Module Priority1 ",application.getDeadlineInfomodule1()));

		    System.out.println("mobile CPU load "+ application.getMobileCPUload());
		    		
			Controller controller = null;
			ModuleMapping moduleMapping = ModuleMapping.createModuleMapping(); // initializing a module mapping			
			moduleMapping.addModuleToDevice("Cloud_Analytics", "cloud");
			for(FogDevice device : fogDevices){
				if(device.getName().startsWith("m"))
					moduleMapping.addModuleToDevice("Client", device.getName());
				}
			if(CLOUD){			 
				moduleMapping.addModuleToDevice("Caregiver", "cloud");
				moduleMapping.addModuleToDevice("Monitoring", "cloud");
				moduleMapping.addModuleToDevice("Filtering", "cloud");
				System.out.println("cloud only module placement, tuple mips= "+ mymips);
				controller = new ControllerEdgeward("master-controller", fogDevices, sensors, actuators);
				controller.submitApplication(application, 0, new ModulePlacementMapping(fogDevices, application,moduleMapping));
				}
			else {
				moduleMapping.addModuleToDevice("Caregiver", "proxy-server");
				switch (placement) { 
				case "Latency Module Placement":{			
					System.out.println("Per User Basic module placement");//", Tuple mips= "+ mymips
					controller = new Controller("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LatencyModulePlacementNear(fogDevices, sensors, actuators, application, moduleMapping));
					break;}	
				case "Latency Modified Module Placement":{
					System.out.println("Per User Modified module placement");
					controller = new Controller("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new ModulePlacementModified(fogDevices, sensors, actuators, application, moduleMapping));
					break;}
				case "Latency Differentiated Module Placement":{
					System.out.println("Per User Differentiated module placement, variable Module/Tuple mips ");
					controller = new Controller("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LatencyModulePlacementNear(fogDevices, sensors, actuators, application, moduleMapping));
					break;} //ModulePlacementDifferentiated
				case "Module Placement Edgeward":{
					System.out.println("Per module placement");
					controller = new ControllerEdgeward("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LModulePlacementEdgewards(fogDevices, sensors, actuators, application, moduleMapping));
					break;}
				case "Module Placement Edgeward Differentiated":{
					System.out.println("Per module Differentiated placement");
					controller = new ControllerEdgeward("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LModulePlacementEdgewards(fogDevices, sensors, actuators, application, moduleMapping));
					break;}
				}
				}
					
			TimeKeeper.getInstance().setSimulationStartTime(Calendar.getInstance().getTimeInMillis());
			CloudSim.startSimulation();
			CloudSim.stopSimulation();
			Log.printLine("ECG finished!");
		} catch (Exception e) {
			e.printStackTrace();
			Log.printLine("Unwanted errors happen");
		}
	}	
/****************************************************************************************
	 * Creates the fog devices in the physical topology of the simulation.
	 * @param userId
	 * @param appId
	 */
	private static void createFogDevices(int userId, String appId) {  // 44800
		FogDevice cloud = createFogDevice("cloud", 44800, 40000, 100, 10000, 0, 0.01, 16*103, 16*83.25); // creates the fog device Cloud at the apex of the hierarchy with level=0
		cloud.setParentId(-1);		 
		FogDevice proxy = createFogDevice("proxy-server", 16800 , 4000, 10000, 10000, 1, 0.0, 107.339, 83.4333); // 2800
		proxy.setParentId(cloud.getId()); // setting Cloud as parent of the Proxy Server
		proxy.setUplinkLatency(100); // latency of connection from Proxy Server to the Cloud is 100 ms		
		fogDevices.add(cloud);
		deviceById.put(cloud.getId(), cloud);
		fogDevices.add(proxy);
		deviceById.put(proxy.getId(), proxy);		
		for(int i=0;i<numOfDepts;i++){
			addGw(i+"", userId, appId, proxy.getId()); // adding a fog device for every Gateway in physical topology. The parent of each gateway is the Proxy Server
		}	
	}

	private static FogDevice addGw(String id, int userId, String appId, int parentId){
		FogDevice dept = createFogDevice("d-"+id, 2800, 4000, 10000, 10000, 2, 0.0, 107.339, 83.4333); //2800
		fogDevices.add(dept);
		deviceById.put(dept.getId(), dept);
		dept.setParentId(parentId);
		dept.setUplinkLatency(4); // latency of connection between gateways and proxy server is 4 ms
		for(int i=0;i<numOfMobilesPerDept;i++){
			String mobileId = id+"-"+i;
			FogDevice mobile = addMobile(mobileId, userId, appId, dept.getId()); // adding mobiles to the physical topology. Smartphones have been modeled as fog devices as well.
			mobile.setUplinkLatency(2); // latency of connection between the smartphone and proxy server is 4 ms
			fogDevices.add(mobile);
			deviceById.put(mobile.getId(), mobile);
		}
		return dept;
	}
	
	private static FogDevice addMobile(String id, int userId, String appId, int parentId){
		FogDevice mobile = createFogDevice("m-"+id, 1000, 1000, 10000, 270, 3, 0, 87.53, 82.44); //1000   
		mobile.setParentId(parentId);
		idOfEndDevices.add(mobile.getId());
		Sensor ecgsensor = new Sensor("s-"+id, "ECG", userId, appId, new DeterministicDistribution(ECG_TRANSMISSION_TIME)); // inter-transmission time of EEG sensor follows a deterministic distribution
		sensors.add(ecgsensor);
		Actuator display = new Actuator("a-"+id, userId, appId, "DISPLAY");
		actuators.add(display);
		ecgsensor.setGatewayDeviceId(mobile.getId());
		ecgsensor.setLatency(6.0);  // latency of connection between EEG sensors and the parent Smartphone is 6 ms
		display.setGatewayDeviceId(mobile.getId());
		display.setLatency(1.0);  // latency of connection between Display actuator and the parent Smartphone is 1 ms
		return mobile;
	}
	
/*****************************************************************************************
	 * Creates a vanilla fog device
	 * @param nodeName name of the device to be used in simulation
	 * @param mips MIPS
	 * @param ram RAM
	 * @param upBw uplink bandwidth
	 * @param downBw downlink bandwidth
	 * @param level hierarchy level of the device
	 * @param ratePerMips cost rate per MIPS used
	 * @param busyPower
	 * @param idlePower
	 * @return
	 */
	private static FogDevice createFogDevice(String nodeName, long mips,
			int ram, long upBw, long downBw, int level, double ratePerMips, double busyPower, double idlePower) {
		
		List<Pe> peList = new ArrayList<Pe>();
		// 3. Create PEs and add these into a list.
		peList.add(new Pe(0, new PeProvisionerOverbooking(mips))); // need to store Pe id and MIPS Rating
		
		int hostId = FogUtils.generateEntityId();
		long storage = 1000000; // host storage
		int bw = 10000;
		PowerHost host = new PowerHost(
				hostId,
				new RamProvisionerSimple(ram),
				new BwProvisionerOverbooking(bw),
				storage,
				peList,
				new StreamOperatorScheduler(peList),
				new FogLinearPowerModel(busyPower, idlePower)
			);

		List<Host> hostList = new ArrayList<Host>();
		hostList.add(host);

		String arch = "x86"; // system architecture
		String os = "Linux"; // operating system
		String vmm = "Xen";
		double time_zone = 10.0; // time zone this resource located
		double cost = 3.0; // the cost of using processing in this resource
		double costPerMem = 0.05; // the cost of using memory in this resource
		double costPerStorage = 0.001; // the cost of using storage in this	// resource
		double costPerBw = 0.0; // the cost of using bw in this resource
		LinkedList<Storage> storageList = new LinkedList<Storage>(); // we are not adding SAN devices by now

		FogDeviceCharacteristics characteristics = new FogDeviceCharacteristics(
				arch, os, vmm, host, time_zone, cost, costPerMem,
				costPerStorage, costPerBw);

		FogDevice fogdevice = null;
		try {
			fogdevice = new FogDevice(nodeName, characteristics, 
					new AppModuleAllocationPolicy(hostList), storageList, 10 , upBw, downBw, 0, ratePerMips); //10 : schedulingInterval  0 uplink  latency		
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		fogdevice.setLevel(level);
		return fogdevice;
	}

/******************************************************************************************
	 * Function to create the EEG Tractor Beam game application in the DDF model. 
	 * @param appId unique identifier of the application
	 * @param userId identifier of the user of the application
	 * @return
	 */
	@SuppressWarnings({"serial" })
	private static Application createApplication(String appId, int userId){
		
		Application application = Application.createApplication(appId, userId); // creates an empty application model (empty directed graph)
		
		// Adding modules (vertices) to the application model (directed graph)
		application.addAppModule("Client", 10, 2000, 1000,100,5); //250Name,int ram, int mips, long size, long bw, int modprty) size is the image size (MB)
		application.addAppModule("Filtering",10, 2000, 500, 100,4); //150
		application.addAppModule("Monitoring",10, 2000, 500,100,3); //150 
		application.addAppModule("Caregiver", 10, 2000,1000,100,2); // 150
		application.addAppModule("Cloud_Analytics",10, 3000,1000,250,1); //500("Cloud_Analytics",10, 500,1000,500,1); //
		
		// Connecting the application modules (vertices) in the application model (directed graph) with edges
		//source, destination, double tupleCpuLength, double tupleNwLength, String tupleType, int direction, int edgeType){
		application.addAppEdge("ECG", "Client", 2000, 500, "ECG", Tuple.UP, AppEdge.SENSOR);
		application.addAppEdge("Client", "Filtering", 2000, 500, "SENSOR_DATA", Tuple.UP, AppEdge.MODULE); //
		application.addAppEdge("Filtering", "Monitoring", mymips, 500, "FILTERED_DATA", Tuple.UP, AppEdge.MODULE); //
		application.addAppEdge("Monitoring", "Caregiver", mymips, 500, "ECG_REPORT", Tuple.UP, AppEdge.MODULE);  //
		application.addAppEdge("Caregiver", "Cloud_Analytics", mymips, 500, "DATA_OFFLOAD", Tuple.UP, AppEdge.MODULE); //		
		application.addAppEdge("Caregiver", "Client", mymips, 500, "State_Action", Tuple.DOWN, AppEdge.MODULE); //  
		application.addAppEdge("Client", "DISPLAY",2000, 500, "P_State_Action", Tuple.DOWN, AppEdge.ACTUATOR);  //
		application.addAppEdge("Cloud_Analytics", "Caregiver", 2000, 1000, "Advanced_Analytics", Tuple.DOWN, AppEdge.MODULE);  
		
 	    //Defining the input-output relationships (represented by selectivity) of the application modules. 
		application.addTupleMapping("Client", "ECG", "SENSOR_DATA", new FractionalSelectivity(1.0)); // 
		application.addTupleMapping("Client", "State_Action", "P_State_Action", new FractionalSelectivity(1.0)); //  
		application.addTupleMapping("Filtering", "SENSOR_DATA", "FILTERED_DATA", new FractionalSelectivity(1.0)); // 
		application.addTupleMapping("Monitoring", "FILTERED_DATA", "ECG_REPORT", new FractionalSelectivity(1.0)); //
		application.addTupleMapping("Caregiver", "ECG_REPORT", "DATA_OFFLOAD", new FractionalSelectivity(1.0)); //
		application.addTupleMapping("Caregiver", "ECG_REPORT", "State_Action", new FractionalSelectivity(1.0)); //
		application.addTupleMapping("Cloud_Analytics", "DATA_OFFLOAD", "Advanced_Analytics", new FractionalSelectivity(0.01)); //
	
		
		 // Defining application loops to monitor the latency of.
		//final AppLoop ONLY_CLOUD = new AppLoop(new ArrayList<String>(){{add("ECG");add("Client");add("Filtering");add("Monitoring");add("Caregiver");add("Client");add("DISPLAY");}}); //add("Cloud_Analytics");
        //List<AppLoop> loops = new ArrayList<AppLoop>(){{ add(ONLY_CLOUD);}};
		//final AppLoop ECG_REPORTING = new AppLoop(new ArrayList<String>(){{add("ECG");add("Client");add("Filtering");add("Monitoring");add("Caregiver");add("Client");add("DISPLAY");}});
        //List<AppLoop> loops = new ArrayList<AppLoop>(){{ add(ECG_REPORTING);}};
		final AppLoop ECG_ANALYTICS = new AppLoop(new ArrayList<String>(){{add("ECG");add("Client");add("Filtering");add("Monitoring");add("Caregiver");}});
        List<AppLoop> loops = new ArrayList<AppLoop>(){{add( ECG_ANALYTICS);}}; 
 		application.setLoops(loops);
		return application;
		}
///random number generators//////////////////////////////////////////////////////////
	private static double getvalue(double d, double e)  { 
	    Random r = new Random(); 
	    double randomValue = d + (e - d) *r.nextDouble(); 
	   // randomValue = r.nextDouble();
	    return randomValue; 
	  } 
	private static Integer getvalue(int min, int max) { 
	    Random r = new Random(); 
	    Integer randomValue = min + r.nextInt()%(max - min); 
	   // randomValue = r.nextInt(max);
	    return randomValue; 
	  }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//scheduled cloudlet processing =30,100,200,300,500 mips for filtering monitoring caregiver  
//scheduled cloudlet processing = 1000  for client and cloudanalytics modules
// mobile id, need Modulename executed with max delay (3:5)
//static Pair<String, Double> moduledeadline = new Pair <String, Double>(null,null);  // mobile id need deadline double
//static List<Pair<String, Double>> moduledeadline = new ArrayList<Pair <String, Double>>();


//if(placement.equals("Latency Differentiated Module Placement")) {		
//System.out.println(String.format("%-30s%s" ,"Per_User Differentiated Module Placement, " ," variable mips between 50 mips, "+  mymips+ " for all modules except cloud plus 1000 mips"));
//}		
//else if(placement.equals("Module Placement Edgeward")) {
//System.out.println(String.format("%-30s%20s%s%30s%10s%s" ,"Per_Module Edgeward Placement","const mips= " , mymips));
//System.out.println("Per_Module Placement,  Tuple's mips= " + mymips);
//}
///else 
//placement=="Latency Module Placement" 
//System.out.println(String.format("%-30s%20s%s%30s%10s%s" ,"Per_User Basic Module Placement","const mips= " , mymips));
//System.out.println("Per_User Basic Module Placement,  const mips= " + mymips);		

//System.out.println("Application Module mips: Client = Filtering = Monitoring = Caregiver = 300 mips , Cloud_Analytics = 600 mips");
//System.out.println("Migration Condition: Mobile Utilization >= 0.3, Proxy/Dept Utilization >= 0.9" );  //, RESOURCE_MANAGE_INTERVAL = 100 ");
//System.out.println("Enhanced Migration Conditions , RESOURCE_MANAGE_INTERVAL = 10 ");
//System.out.println("fog device scheduling interval = 10,  Application module scheduling interval = 300  ");	

//moduledeadline.put("Client", (x+ 15.0000000000000000));
//deadlineInfomodule.put(id,moduledeadline);
//moduledeadline.put("Caregiver", x);
//deadlineInfomodule.put(id,moduledeadline);				
//System.out.println("deadlineInfomodule  "+ deadlineInfomodule);
//deadlineInfomodule.put(id,moduledeadlinelist);				
//moduledeadline.clear();

/*
for(Integer id : idOfEndDevices){
	if (placement.equals("Latency Differentiated Module Placement")) {
		Integer x= getvalue(50, 500);//mymips);
		x= Math.abs(x);
		additionalMipsInfo.put(id, (double)x);  //getvalue(0,mymips)
		}
	else
		additionalMipsInfo.put(id, (double)mymips);
}
*/
/*else if(device.getName().startsWith("d")){
moduleMapping.addModuleToDevice("Filtering", device.getName());
moduleMapping.addModuleToDevice("Monitoring", device.getName());				
} */
//Controller controller = new Controller("master-controller", fogDevices, sensors, actuators);
//controller.submitApplication(application, 0, new ModulePlacementOnlyCloud(fogDevices, sensors, actuators, application));
//controller.submitApplication(application, 0, new LatencyModulePlacement(fogDevices, sensors, actuators, application, moduleMapping));
//controller.submitApplication(application, 0, new LatencyModifiedModulePlacementNew(fogDevices, sensors, actuators, application, moduleMapping));
 //LModulePlacementEdgewards  // LatencyModulePlacementNear

//TRY FogDevice cloud = createFogDevice("cloud", 448000000, 40000000, 100000, 10000000, 0, 0.01, 16*103, 16*83.25); // creates the fog device Cloud at the apex of the hierarchy with level=0
//FogDevice cloud = createFogDevice("cloud", 4480000, 4000000, 100, 10000, 0, 0.01, 16*103, 16*83.25); // creates the fog device Cloud at the apex of the hierarchy with level=0
//FogDevice proxy = createFogDevice("proxy-server", 2800, 4000, 10000, 10000, 1, 0.0, 107.339, 83.4333);

//peList.add(new Pe(0, new PeProvisionerSimple(mips))); // need to store Pe id and MIPS Rating


/*
application.addAppModule("Client", 10, 300, 1000,100,5); // adding module Client to the application model
application.addAppModule("Filtering",10, 300, 1000, 100,4); //
application.addAppModule("Monitoring",10, 300, 1000,100,3); // 
application.addAppModule("Caregiver", 10, 300,1000,100,2); // 
application.addAppModule("Cloud_Analytics",10, 600,1000,250,1); //("Cloud_Analytics",10, 500,1000,500,1); //
*/
/*application.addAppEdge("ECG", "Client", 3000, 1000, "ECG", Tuple.UP, AppEdge.SENSOR);
application.addAppEdge("Client", "Filtering", 3000, 500, "SENSOR_DATA", Tuple.UP, AppEdge.MODULE); //
application.addAppEdge("Filtering", "Monitoring", (30+ mymips), 500, "FILTERED_DATA", Tuple.UP, AppEdge.MODULE); // 
application.addAppEdge("Monitoring", "Cloud_Analytics", 1000, 500, "DATA_OFFLOAD", Tuple.UP, AppEdge.MODULE); // 
application.addAppEdge("Monitoring", "Caregiver", (60+ mymips) , 500, "ECG_REPORT", Tuple.UP, AppEdge.MODULE);  // 
application.addAppEdge("Cloud_Analytics", "Caregiver", 3500, 1000, "Advanced_Analytics", Tuple.DOWN, AppEdge.MODULE);  // 
application.addAppEdge("Caregiver", "Client", 1000 , 500, "State_Action", Tuple.DOWN, AppEdge.MODULE); // 
application.addAppEdge("Client", "DISPLAY",1000, 500, "P_State_Action", Tuple.DOWN, AppEdge.ACTUATOR);  //
 */
//application.addAppEdge("Caregiver", "Cloud_Analytics", 3000, 1000, "DECISION", Tuple.UP, AppEdge.MODULE); //
// application.addTupleMapping("Cloud_Analytics", "DECISION", "Advanced_Analytics", new FractionalSelectivity(0.001)); //
//final AppLoop HBR_Analytics = new AppLoop(new ArrayList<String>(){{add("HBR"); add("Client"); add("Monitoring"); add("Cloud_Analytics"); add("Caregiver"); add("Client"); add("DISPLAY");}});

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10054, count -3525, length 26084
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-10-15 12:35:20.182
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.StringIndexOutOfBoundsException: offset 10054, count -3525, length 26084
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:324)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10054, count -3525, length 26084
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	... 19 more
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10054, count -3525, length 26084
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2020-10-15 12:35:20.182
!MESSAGE offset 10054, count -3525, length 26084
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10054, count -3525, length 26084
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2020-10-15 12:35:20.182
!MESSAGE offset 10054, count -3525, length 26084
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10054, count -3525, length 26084
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-10-15 12:35:20.183
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.StringIndexOutOfBoundsException: offset 10054, count -3525, length 26084
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:324)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10054, count -3525, length 26084
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	... 19 more
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10054, count -3525, length 26084
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2020-10-15 12:35:20.183
!MESSAGE offset 10054, count -3525, length 26084
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10054, count -3525, length 26084
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2020-10-15 12:35:21.192
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
package org.fog.test.perfeval;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.stream.Collectors;
import org.apache.commons.math3.util.Pair;
import org.cloudbus.cloudsim.Host;
import org.cloudbus.cloudsim.Log;
import org.cloudbus.cloudsim.Pe;
import org.cloudbus.cloudsim.Storage;
import org.cloudbus.cloudsim.core.CloudSim;
import org.cloudbus.cloudsim.power.PowerHost;
import org.cloudbus.cloudsim.provisioners.PeProvisionerSimple;
import org.cloudbus.cloudsim.provisioners.RamProvisionerSimple;
import org.cloudbus.cloudsim.sdn.overbooking.BwProvisionerOverbooking;
import org.cloudbus.cloudsim.sdn.overbooking.PeProvisionerOverbooking;
import org.fog.application.AppEdge;
import org.fog.application.AppLoop;
import org.fog.application.Application;
import org.fog.application.selectivity.FractionalSelectivity;
import org.fog.entities.Actuator;
import org.fog.entities.FogBroker;
import org.fog.entities.FogDevice;
import org.fog.entities.FogDeviceCharacteristics;
import org.fog.entities.Sensor;
import org.fog.entities.Tuple;
import org.fog.placement.Controller;
import org.fog.placement.ControllerEdgeward;
import org.fog.placement.LModulePlacementEdgewards;
import org.fog.placement.LatencyModulePlacementNear;
import org.fog.placement.ModuleMapping;
import org.fog.placement.ModulePlacementDifferentiated;
import org.fog.placement.ModulePlacementEdgewards;
import org.fog.placement.ModulePlacementMapping;
import org.fog.placement.ModulePlacementModified;
import org.fog.placement.ModulePlacementOnlyCloud;
import org.fog.policy.AppModuleAllocationPolicy;
import org.fog.scheduler.StreamOperatorScheduler;
import org.fog.utils.Config;
import org.fog.utils.FogLinearPowerModel;
import org.fog.utils.FogUtils;
import org.fog.utils.TimeKeeper;
import org.fog.utils.distribution.DeterministicDistribution;

/**
 * Simulation setup for  ECG
 * @author Ragaa Shehab
 *
 */ //updateTimingsOnReceipt - checkCloudletCompletion --tupleEndedExecutionUser
public class ECG {
	static List<FogDevice> fogDevices = new ArrayList<FogDevice>();
	static List<Sensor> sensors = new ArrayList<Sensor>();
	static List<Actuator> actuators = new ArrayList<Actuator>();
	static Map<Integer,FogDevice> deviceById = new HashMap<Integer,FogDevice>();	
	static List<Integer> idOfEndDevices = new ArrayList<Integer>();
	static Map<Integer, Double> deadlineInfo = new	HashMap<Integer, Double>();  // mobile id has priority
	static Map<Integer, Double> additionalMipsInfo = new HashMap<Integer, Double>(); // mobile id need tuple mips
	static Map<Integer, Map<String, Double>> deadlineInfomodule = new HashMap<Integer, Map<String,Double>>();  // mobile id has modulename with module priority
	static Map<Integer,List<Map<String, Double>>> deadlineInfomodule1 = new HashMap<Integer, List<Map<String,Double>>>();  // mobile id has modulename with module priority

	static boolean CLOUD = false;
	static int numOfDepts = 1;
	static int numOfMobilesPerDept =5;
	static double ECG_TRANSMISSION_TIME = 50.0 ; // 50.0;   //100, 50, 25 ms   100 //10s= 10000
	static public int mymips= 2000;     
	//static String placement = "Latency Module Placement"; 
	static String placement = "Latency Differentiated Module Placement"; 
	//static String placement = "Module Placement Edgeward";
	//static String placement = "Module Placement Edgeward Differentiated";
	//static String placement = "Latency Modified Module Placement";
	static double MobileCPUload= 0.1;
	
	public static void main(String[] args) {
		Log.print("Starting ECG transmission");	Log.print("             ECG transmission time ms: "); Log.print(ECG_TRANSMISSION_TIME);
		Log.print("     Depts/Mobiles =  "); Log.print (numOfDepts);Log.print("/"); Log.printLine (numOfMobilesPerDept);
		System.out.println("analytics VM mips  2000, Fog device mips: mobile 1000, dept  2800, proxy 16800" ); 

		
		try {
			Log.disable(); 	
			//Config.MAX_SIMULATION_TIME= 100000;
			int num_user = 1; // number of cloud users
			Calendar calendar = Calendar.getInstance();
			boolean trace_flag = false; // mean trace events
			CloudSim.init(num_user, calendar, trace_flag);						
			String appId = "ECG"; 
			FogBroker broker = new FogBroker("broker");			
			createFogDevices(broker.getId(), appId);
			
			Map<String, Double> moduledeadline= new HashMap<String, Double>();
			Map<String, Double> moduledeadline1;
			List<Map<String, Double>> moduledeadline1List;

			for(Integer id : idOfEndDevices){
				Double x= getvalue(5.00, 40.00);
				Double t1= 10.00; Double t2= 5.00; //Double t3= 5.00;
				deadlineInfo.put(id, x);
				
				if (placement.equals("Latency Differentiated Module Placement")||placement.equals("Module Placement Edgeward Differentiated")) {
						if(5.00 < x)&& (x < 10.00) x=5.00;
						if(10.00 < x < 15.00) x=10.00;
						if(15.00 < x < 20.00) x=20.00;
						if(20.00 < x < 30.00) x=30.00;
						if(30.00 < x < 40.00) x=40.00;
					
							
						
					additionalMipsInfo.put(id, x*100); //1000
					moduledeadline1=  new HashMap<String,Double>();
					moduledeadline1List= new ArrayList<Map<String, Double>>();
					moduledeadline1.put("Client", x*100);
					moduledeadline1.put("Filtering", x*100);
					moduledeadline1.put("Monitoring", x*100);
					moduledeadline1.put("Caregiver", x*100);
					moduledeadline1.put("Cloud_Analytics", x*100);
					moduledeadline1List.add(moduledeadline1);
					deadlineInfomodule1.put(id, moduledeadline1List);
				}
				else {
					additionalMipsInfo.put(id, (double)mymips);
					moduledeadline1=  new HashMap<String,Double>();
					moduledeadline1List= new ArrayList<Map<String, Double>>();
					moduledeadline1.put("Client", (double)mymips);
					moduledeadline1.put("Filtering", (double)mymips);
					moduledeadline1.put("Monitoring", (double)mymips);
					moduledeadline1.put("Caregiver", (double)mymips);
					moduledeadline1.put("Cloud_Analytics", (double)mymips);
					moduledeadline1List.add(moduledeadline1);
					deadlineInfomodule1.put(id, moduledeadline1List);
				}
				moduledeadline.put("Filtering", (x+t1));
				deadlineInfomodule.put(id,moduledeadline);
				moduledeadline.put("Monitoring", (x+ t2));
				deadlineInfomodule.put(id,moduledeadline);
			}	
			
			deadlineInfo=deadlineInfo.entrySet()
		             .stream().sorted(Map.Entry.comparingByValue())
		             .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -> e1, LinkedHashMap::new));			
				
			Application application = createApplication(appId, broker.getId());
			application.setUserId(broker.getId());
			application.setdeviceById(deviceById);
			application.setidOfEndDevices(idOfEndDevices);
			application.setDeadlineInfo(deadlineInfo);
			application.setDeadlineInfomodule(deadlineInfomodule);
			application.setDeadlineInfomodule1(deadlineInfomodule1);
		    application.setAdditionalMipsInfo(additionalMipsInfo);
		    application.setplacement(placement);
		    application.setMobileCPUload(MobileCPUload);
		    
		    System.out.println(String.format("%-25s%s" ,"User Priority ASC ", application.getDeadlineInfo()));
			System.out.println(String.format("%-25s%s" ,"Module Tuble MIPS ",application.getAdditionalMipsInfo()));
		   /// System.out.println(String.format("%-25s%s" ,"Module Priority ",application.getDeadlineInfomodule()));
		    System.out.println(String.format("%-25s%s" ,"Module Priority1 ",application.getDeadlineInfomodule1()));

		    System.out.println("mobile CPU load "+ application.getMobileCPUload());
		    		
			Controller controller = null;
			ModuleMapping moduleMapping = ModuleMapping.createModuleMapping(); // initializing a module mapping			
			moduleMapping.addModuleToDevice("Cloud_Analytics", "cloud");
			for(FogDevice device : fogDevices){
				if(device.getName().startsWith("m"))
					moduleMapping.addModuleToDevice("Client", device.getName());
				}
			if(CLOUD){			 
				moduleMapping.addModuleToDevice("Caregiver", "cloud");
				moduleMapping.addModuleToDevice("Monitoring", "cloud");
				moduleMapping.addModuleToDevice("Filtering", "cloud");
				System.out.println("cloud only module placement, tuple mips= "+ mymips);
				controller = new ControllerEdgeward("master-controller", fogDevices, sensors, actuators);
				controller.submitApplication(application, 0, new ModulePlacementMapping(fogDevices, application,moduleMapping));
				}
			else {
				moduleMapping.addModuleToDevice("Caregiver", "proxy-server");
				switch (placement) { 
				case "Latency Module Placement":{			
					System.out.println("Per User Basic module placement");//", Tuple mips= "+ mymips
					controller = new Controller("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LatencyModulePlacementNear(fogDevices, sensors, actuators, application, moduleMapping));
					break;}	
				case "Latency Modified Module Placement":{
					System.out.println("Per User Modified module placement");
					controller = new Controller("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new ModulePlacementModified(fogDevices, sensors, actuators, application, moduleMapping));
					break;}
				case "Latency Differentiated Module Placement":{
					System.out.println("Per User Differentiated module placement, variable Module/Tuple mips ");
					controller = new Controller("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LatencyModulePlacementNear(fogDevices, sensors, actuators, application, moduleMapping));
					break;} //ModulePlacementDifferentiated
				case "Module Placement Edgeward":{
					System.out.println("Per module placement");
					controller = new ControllerEdgeward("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LModulePlacementEdgewards(fogDevices, sensors, actuators, application, moduleMapping));
					break;}
				case "Module Placement Edgeward Differentiated":{
					System.out.println("Per module Differentiated placement");
					controller = new ControllerEdgeward("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LModulePlacementEdgewards(fogDevices, sensors, actuators, application, moduleMapping));
					break;}
				}
				}
					
			TimeKeeper.getInstance().setSimulationStartTime(Calendar.getInstance().getTimeInMillis());
			CloudSim.startSimulation();
			CloudSim.stopSimulation();
			Log.printLine("ECG finished!");
		} catch (Exception e) {
			e.printStackTrace();
			Log.printLine("Unwanted errors happen");
		}
	}	
/****************************************************************************************
	 * Creates the fog devices in the physical topology of the simulation.
	 * @param userId
	 * @param appId
	 */
	private static void createFogDevices(int userId, String appId) {  // 44800
		FogDevice cloud = createFogDevice("cloud", 44800, 40000, 100, 10000, 0, 0.01, 16*103, 16*83.25); // creates the fog device Cloud at the apex of the hierarchy with level=0
		cloud.setParentId(-1);		 
		FogDevice proxy = createFogDevice("proxy-server", 16800 , 4000, 10000, 10000, 1, 0.0, 107.339, 83.4333); // 2800
		proxy.setParentId(cloud.getId()); // setting Cloud as parent of the Proxy Server
		proxy.setUplinkLatency(100); // latency of connection from Proxy Server to the Cloud is 100 ms		
		fogDevices.add(cloud);
		deviceById.put(cloud.getId(), cloud);
		fogDevices.add(proxy);
		deviceById.put(proxy.getId(), proxy);		
		for(int i=0;i<numOfDepts;i++){
			addGw(i+"", userId, appId, proxy.getId()); // adding a fog device for every Gateway in physical topology. The parent of each gateway is the Proxy Server
		}	
	}

	private static FogDevice addGw(String id, int userId, String appId, int parentId){
		FogDevice dept = createFogDevice("d-"+id, 2800, 4000, 10000, 10000, 2, 0.0, 107.339, 83.4333); //2800
		fogDevices.add(dept);
		deviceById.put(dept.getId(), dept);
		dept.setParentId(parentId);
		dept.setUplinkLatency(4); // latency of connection between gateways and proxy server is 4 ms
		for(int i=0;i<numOfMobilesPerDept;i++){
			String mobileId = id+"-"+i;
			FogDevice mobile = addMobile(mobileId, userId, appId, dept.getId()); // adding mobiles to the physical topology. Smartphones have been modeled as fog devices as well.
			mobile.setUplinkLatency(2); // latency of connection between the smartphone and proxy server is 4 ms
			fogDevices.add(mobile);
			deviceById.put(mobile.getId(), mobile);
		}
		return dept;
	}
	
	private static FogDevice addMobile(String id, int userId, String appId, int parentId){
		FogDevice mobile = createFogDevice("m-"+id, 1000, 1000, 10000, 270, 3, 0, 87.53, 82.44); //1000   
		mobile.setParentId(parentId);
		idOfEndDevices.add(mobile.getId());
		Sensor ecgsensor = new Sensor("s-"+id, "ECG", userId, appId, new DeterministicDistribution(ECG_TRANSMISSION_TIME)); // inter-transmission time of EEG sensor follows a deterministic distribution
		sensors.add(ecgsensor);
		Actuator display = new Actuator("a-"+id, userId, appId, "DISPLAY");
		actuators.add(display);
		ecgsensor.setGatewayDeviceId(mobile.getId());
		ecgsensor.setLatency(6.0);  // latency of connection between EEG sensors and the parent Smartphone is 6 ms
		display.setGatewayDeviceId(mobile.getId());
		display.setLatency(1.0);  // latency of connection between Display actuator and the parent Smartphone is 1 ms
		return mobile;
	}
	
/*****************************************************************************************
	 * Creates a vanilla fog device
	 * @param nodeName name of the device to be used in simulation
	 * @param mips MIPS
	 * @param ram RAM
	 * @param upBw uplink bandwidth
	 * @param downBw downlink bandwidth
	 * @param level hierarchy level of the device
	 * @param ratePerMips cost rate per MIPS used
	 * @param busyPower
	 * @param idlePower
	 * @return
	 */
	private static FogDevice createFogDevice(String nodeName, long mips,
			int ram, long upBw, long downBw, int level, double ratePerMips, double busyPower, double idlePower) {
		
		List<Pe> peList = new ArrayList<Pe>();
		// 3. Create PEs and add these into a list.
		peList.add(new Pe(0, new PeProvisionerOverbooking(mips))); // need to store Pe id and MIPS Rating
		
		int hostId = FogUtils.generateEntityId();
		long storage = 1000000; // host storage
		int bw = 10000;
		PowerHost host = new PowerHost(
				hostId,
				new RamProvisionerSimple(ram),
				new BwProvisionerOverbooking(bw),
				storage,
				peList,
				new StreamOperatorScheduler(peList),
				new FogLinearPowerModel(busyPower, idlePower)
			);

		List<Host> hostList = new ArrayList<Host>();
		hostList.add(host);

		String arch = "x86"; // system architecture
		String os = "Linux"; // operating system
		String vmm = "Xen";
		double time_zone = 10.0; // time zone this resource located
		double cost = 3.0; // the cost of using processing in this resource
		double costPerMem = 0.05; // the cost of using memory in this resource
		double costPerStorage = 0.001; // the cost of using storage in this	// resource
		double costPerBw = 0.0; // the cost of using bw in this resource
		LinkedList<Storage> storageList = new LinkedList<Storage>(); // we are not adding SAN devices by now

		FogDeviceCharacteristics characteristics = new FogDeviceCharacteristics(
				arch, os, vmm, host, time_zone, cost, costPerMem,
				costPerStorage, costPerBw);

		FogDevice fogdevice = null;
		try {
			fogdevice = new FogDevice(nodeName, characteristics, 
					new AppModuleAllocationPolicy(hostList), storageList, 10 , upBw, downBw, 0, ratePerMips); //10 : schedulingInterval  0 uplink  latency		
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		fogdevice.setLevel(level);
		return fogdevice;
	}

/******************************************************************************************
	 * Function to create the EEG Tractor Beam game application in the DDF model. 
	 * @param appId unique identifier of the application
	 * @param userId identifier of the user of the application
	 * @return
	 */
	@SuppressWarnings({"serial" })
	private static Application createApplication(String appId, int userId){
		
		Application application = Application.createApplication(appId, userId); // creates an empty application model (empty directed graph)
		
		// Adding modules (vertices) to the application model (directed graph)
		application.addAppModule("Client", 10, 2000, 1000,100,5); //250Name,int ram, int mips, long size, long bw, int modprty) size is the image size (MB)
		application.addAppModule("Filtering",10, 2000, 500, 100,4); //150
		application.addAppModule("Monitoring",10, 2000, 500,100,3); //150 
		application.addAppModule("Caregiver", 10, 2000,1000,100,2); // 150
		application.addAppModule("Cloud_Analytics",10, 3000,1000,250,1); //500("Cloud_Analytics",10, 500,1000,500,1); //
		
		// Connecting the application modules (vertices) in the application model (directed graph) with edges
		//source, destination, double tupleCpuLength, double tupleNwLength, String tupleType, int direction, int edgeType){
		application.addAppEdge("ECG", "Client", 2000, 500, "ECG", Tuple.UP, AppEdge.SENSOR);
		application.addAppEdge("Client", "Filtering", 2000, 500, "SENSOR_DATA", Tuple.UP, AppEdge.MODULE); //
		application.addAppEdge("Filtering", "Monitoring", mymips, 500, "FILTERED_DATA", Tuple.UP, AppEdge.MODULE); //
		application.addAppEdge("Monitoring", "Caregiver", mymips, 500, "ECG_REPORT", Tuple.UP, AppEdge.MODULE);  //
		application.addAppEdge("Caregiver", "Cloud_Analytics", mymips, 500, "DATA_OFFLOAD", Tuple.UP, AppEdge.MODULE); //		
		application.addAppEdge("Caregiver", "Client", mymips, 500, "State_Action", Tuple.DOWN, AppEdge.MODULE); //  
		application.addAppEdge("Client", "DISPLAY",2000, 500, "P_State_Action", Tuple.DOWN, AppEdge.ACTUATOR);  //
		application.addAppEdge("Cloud_Analytics", "Caregiver", 2000, 1000, "Advanced_Analytics", Tuple.DOWN, AppEdge.MODULE);  
		
 	    //Defining the input-output relationships (represented by selectivity) of the application modules. 
		application.addTupleMapping("Client", "ECG", "SENSOR_DATA", new FractionalSelectivity(1.0)); // 
		application.addTupleMapping("Client", "State_Action", "P_State_Action", new FractionalSelectivity(1.0)); //  
		application.addTupleMapping("Filtering", "SENSOR_DATA", "FILTERED_DATA", new FractionalSelectivity(1.0)); // 
		application.addTupleMapping("Monitoring", "FILTERED_DATA", "ECG_REPORT", new FractionalSelectivity(1.0)); //
		application.addTupleMapping("Caregiver", "ECG_REPORT", "DATA_OFFLOAD", new FractionalSelectivity(1.0)); //
		application.addTupleMapping("Caregiver", "ECG_REPORT", "State_Action", new FractionalSelectivity(1.0)); //
		application.addTupleMapping("Cloud_Analytics", "DATA_OFFLOAD", "Advanced_Analytics", new FractionalSelectivity(0.01)); //
	
		
		 // Defining application loops to monitor the latency of.
		//final AppLoop ONLY_CLOUD = new AppLoop(new ArrayList<String>(){{add("ECG");add("Client");add("Filtering");add("Monitoring");add("Caregiver");add("Client");add("DISPLAY");}}); //add("Cloud_Analytics");
        //List<AppLoop> loops = new ArrayList<AppLoop>(){{ add(ONLY_CLOUD);}};
		//final AppLoop ECG_REPORTING = new AppLoop(new ArrayList<String>(){{add("ECG");add("Client");add("Filtering");add("Monitoring");add("Caregiver");add("Client");add("DISPLAY");}});
        //List<AppLoop> loops = new ArrayList<AppLoop>(){{ add(ECG_REPORTING);}};
		final AppLoop ECG_ANALYTICS = new AppLoop(new ArrayList<String>(){{add("ECG");add("Client");add("Filtering");add("Monitoring");add("Caregiver");}});
        List<AppLoop> loops = new ArrayList<AppLoop>(){{add( ECG_ANALYTICS);}}; 
 		application.setLoops(loops);
		return application;
		}
///random number generators//////////////////////////////////////////////////////////
	private static double getvalue(double d, double e)  { 
	    Random r = new Random(); 
	    double randomValue = d + (e - d) *r.nextDouble(); 
	   // randomValue = r.nextDouble();
	    return randomValue; 
	  } 
	private static Integer getvalue(int min, int max) { 
	    Random r = new Random(); 
	    Integer randomValue = min + r.nextInt()%(max - min); 
	   // randomValue = r.nextInt(max);
	    return randomValue; 
	  }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//scheduled cloudlet processing =30,100,200,300,500 mips for filtering monitoring caregiver  
//scheduled cloudlet processing = 1000  for client and cloudanalytics modules
// mobile id, need Modulename executed with max delay (3:5)
//static Pair<String, Double> moduledeadline = new Pair <String, Double>(null,null);  // mobile id need deadline double
//static List<Pair<String, Double>> moduledeadline = new ArrayList<Pair <String, Double>>();


//if(placement.equals("Latency Differentiated Module Placement")) {		
//System.out.println(String.format("%-30s%s" ,"Per_User Differentiated Module Placement, " ," variable mips between 50 mips, "+  mymips+ " for all modules except cloud plus 1000 mips"));
//}		
//else if(placement.equals("Module Placement Edgeward")) {
//System.out.println(String.format("%-30s%20s%s%30s%10s%s" ,"Per_Module Edgeward Placement","const mips= " , mymips));
//System.out.println("Per_Module Placement,  Tuple's mips= " + mymips);
//}
///else 
//placement=="Latency Module Placement" 
//System.out.println(String.format("%-30s%20s%s%30s%10s%s" ,"Per_User Basic Module Placement","const mips= " , mymips));
//System.out.println("Per_User Basic Module Placement,  const mips= " + mymips);		

//System.out.println("Application Module mips: Client = Filtering = Monitoring = Caregiver = 300 mips , Cloud_Analytics = 600 mips");
//System.out.println("Migration Condition: Mobile Utilization >= 0.3, Proxy/Dept Utilization >= 0.9" );  //, RESOURCE_MANAGE_INTERVAL = 100 ");
//System.out.println("Enhanced Migration Conditions , RESOURCE_MANAGE_INTERVAL = 10 ");
//System.out.println("fog device scheduling interval = 10,  Application module scheduling interval = 300  ");	

//moduledeadline.put("Client", (x+ 15.0000000000000000));
//deadlineInfomodule.put(id,moduledeadline);
//moduledeadline.put("Caregiver", x);
//deadlineInfomodule.put(id,moduledeadline);				
//System.out.println("deadlineInfomodule  "+ deadlineInfomodule);
//deadlineInfomodule.put(id,moduledeadlinelist);				
//moduledeadline.clear();

/*
for(Integer id : idOfEndDevices){
	if (placement.equals("Latency Differentiated Module Placement")) {
		Integer x= getvalue(50, 500);//mymips);
		x= Math.abs(x);
		additionalMipsInfo.put(id, (double)x);  //getvalue(0,mymips)
		}
	else
		additionalMipsInfo.put(id, (double)mymips);
}
*/
/*else if(device.getName().startsWith("d")){
moduleMapping.addModuleToDevice("Filtering", device.getName());
moduleMapping.addModuleToDevice("Monitoring", device.getName());				
} */
//Controller controller = new Controller("master-controller", fogDevices, sensors, actuators);
//controller.submitApplication(application, 0, new ModulePlacementOnlyCloud(fogDevices, sensors, actuators, application));
//controller.submitApplication(application, 0, new LatencyModulePlacement(fogDevices, sensors, actuators, application, moduleMapping));
//controller.submitApplication(application, 0, new LatencyModifiedModulePlacementNew(fogDevices, sensors, actuators, application, moduleMapping));
 //LModulePlacementEdgewards  // LatencyModulePlacementNear

//TRY FogDevice cloud = createFogDevice("cloud", 448000000, 40000000, 100000, 10000000, 0, 0.01, 16*103, 16*83.25); // creates the fog device Cloud at the apex of the hierarchy with level=0
//FogDevice cloud = createFogDevice("cloud", 4480000, 4000000, 100, 10000, 0, 0.01, 16*103, 16*83.25); // creates the fog device Cloud at the apex of the hierarchy with level=0
//FogDevice proxy = createFogDevice("proxy-server", 2800, 4000, 10000, 10000, 1, 0.0, 107.339, 83.4333);

//peList.add(new Pe(0, new PeProvisionerSimple(mips))); // need to store Pe id and MIPS Rating


/*
application.addAppModule("Client", 10, 300, 1000,100,5); // adding module Client to the application model
application.addAppModule("Filtering",10, 300, 1000, 100,4); //
application.addAppModule("Monitoring",10, 300, 1000,100,3); // 
application.addAppModule("Caregiver", 10, 300,1000,100,2); // 
application.addAppModule("Cloud_Analytics",10, 600,1000,250,1); //("Cloud_Analytics",10, 500,1000,500,1); //
*/
/*application.addAppEdge("ECG", "Client", 3000, 1000, "ECG", Tuple.UP, AppEdge.SENSOR);
application.addAppEdge("Client", "Filtering", 3000, 500, "SENSOR_DATA", Tuple.UP, AppEdge.MODULE); //
application.addAppEdge("Filtering", "Monitoring", (30+ mymips), 500, "FILTERED_DATA", Tuple.UP, AppEdge.MODULE); // 
application.addAppEdge("Monitoring", "Cloud_Analytics", 1000, 500, "DATA_OFFLOAD", Tuple.UP, AppEdge.MODULE); // 
application.addAppEdge("Monitoring", "Caregiver", (60+ mymips) , 500, "ECG_REPORT", Tuple.UP, AppEdge.MODULE);  // 
application.addAppEdge("Cloud_Analytics", "Caregiver", 3500, 1000, "Advanced_Analytics", Tuple.DOWN, AppEdge.MODULE);  // 
application.addAppEdge("Caregiver", "Client", 1000 , 500, "State_Action", Tuple.DOWN, AppEdge.MODULE); // 
application.addAppEdge("Client", "DISPLAY",1000, 500, "P_State_Action", Tuple.DOWN, AppEdge.ACTUATOR);  //
 */
//application.addAppEdge("Caregiver", "Cloud_Analytics", 3000, 1000, "DECISION", Tuple.UP, AppEdge.MODULE); //
// application.addTupleMapping("Cloud_Analytics", "DECISION", "Advanced_Analytics", new FractionalSelectivity(0.001)); //
//final AppLoop HBR_Analytics = new AppLoop(new ArrayList<String>(){{add("HBR"); add("Client"); add("Monitoring"); add("Cloud_Analytics"); add("Caregiver"); add("Client"); add("DISPLAY");}});

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10054, count -3525, length 26084
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-10-15 12:35:21.193
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.StringIndexOutOfBoundsException: offset 10054, count -3525, length 26084
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:324)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10054, count -3525, length 26084
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	... 16 more
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10054, count -3525, length 26084
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2020-10-15 12:35:21.193
!MESSAGE offset 10054, count -3525, length 26084
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10054, count -3525, length 26084
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2020-10-15 12:35:21.193
!MESSAGE offset 10054, count -3525, length 26084
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10054, count -3525, length 26084
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-10-15 12:35:21.194
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.StringIndexOutOfBoundsException: offset 10054, count -3525, length 26084
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:324)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10054, count -3525, length 26084
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	... 16 more
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10054, count -3525, length 26084
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2020-10-15 12:35:21.194
!MESSAGE offset 10054, count -3525, length 26084
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10054, count -3525, length 26084
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-10-15 12:35:21.203
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10054, count -3525, length 26084
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-10-15 12:35:21.204
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10054, count -3525, length 26084
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-10-15 12:35:23.506
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10054, count -3525, length 26084
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-10-15 12:35:23.506
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10054, count -3525, length 26084
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-10-15 12:35:28.585
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10054, count -3525, length 26084
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-10-15 12:35:28.586
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10054, count -3525, length 26084
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-10-15 12:35:30.800
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10054, count -3525, length 26084
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-10-15 12:35:30.801
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10054, count -3525, length 26084
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-10-15 12:35:31.569
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10054, count -3525, length 26084
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-10-15 12:35:31.569
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10054, count -3525, length 26084
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-10-15 12:35:32.711
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
package org.fog.test.perfeval;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.stream.Collectors;
import org.apache.commons.math3.util.Pair;
import org.cloudbus.cloudsim.Host;
import org.cloudbus.cloudsim.Log;
import org.cloudbus.cloudsim.Pe;
import org.cloudbus.cloudsim.Storage;
import org.cloudbus.cloudsim.core.CloudSim;
import org.cloudbus.cloudsim.power.PowerHost;
import org.cloudbus.cloudsim.provisioners.PeProvisionerSimple;
import org.cloudbus.cloudsim.provisioners.RamProvisionerSimple;
import org.cloudbus.cloudsim.sdn.overbooking.BwProvisionerOverbooking;
import org.cloudbus.cloudsim.sdn.overbooking.PeProvisionerOverbooking;
import org.fog.application.AppEdge;
import org.fog.application.AppLoop;
import org.fog.application.Application;
import org.fog.application.selectivity.FractionalSelectivity;
import org.fog.entities.Actuator;
import org.fog.entities.FogBroker;
import org.fog.entities.FogDevice;
import org.fog.entities.FogDeviceCharacteristics;
import org.fog.entities.Sensor;
import org.fog.entities.Tuple;
import org.fog.placement.Controller;
import org.fog.placement.ControllerEdgeward;
import org.fog.placement.LModulePlacementEdgewards;
import org.fog.placement.LatencyModulePlacementNear;
import org.fog.placement.ModuleMapping;
import org.fog.placement.ModulePlacementDifferentiated;
import org.fog.placement.ModulePlacementEdgewards;
import org.fog.placement.ModulePlacementMapping;
import org.fog.placement.ModulePlacementModified;
import org.fog.placement.ModulePlacementOnlyCloud;
import org.fog.policy.AppModuleAllocationPolicy;
import org.fog.scheduler.StreamOperatorScheduler;
import org.fog.utils.Config;
import org.fog.utils.FogLinearPowerModel;
import org.fog.utils.FogUtils;
import org.fog.utils.TimeKeeper;
import org.fog.utils.distribution.DeterministicDistribution;

/**
 * Simulation setup for  ECG
 * @author Ragaa Shehab
 *
 */ //updateTimingsOnReceipt - checkCloudletCompletion --tupleEndedExecutionUser
public class ECG {
	static List<FogDevice> fogDevices = new ArrayList<FogDevice>();
	static List<Sensor> sensors = new ArrayList<Sensor>();
	static List<Actuator> actuators = new ArrayList<Actuator>();
	static Map<Integer,FogDevice> deviceById = new HashMap<Integer,FogDevice>();	
	static List<Integer> idOfEndDevices = new ArrayList<Integer>();
	static Map<Integer, Double> deadlineInfo = new	HashMap<Integer, Double>();  // mobile id has priority
	static Map<Integer, Double> additionalMipsInfo = new HashMap<Integer, Double>(); // mobile id need tuple mips
	static Map<Integer, Map<String, Double>> deadlineInfomodule = new HashMap<Integer, Map<String,Double>>();  // mobile id has modulename with module priority
	static Map<Integer,List<Map<String, Double>>> deadlineInfomodule1 = new HashMap<Integer, List<Map<String,Double>>>();  // mobile id has modulename with module priority

	static boolean CLOUD = false;
	static int numOfDepts = 1;
	static int numOfMobilesPerDept =5;
	static double ECG_TRANSMISSION_TIME = 50.0 ; // 50.0;   //100, 50, 25 ms   100 //10s= 10000
	static public int mymips= 2000;     
	//static String placement = "Latency Module Placement"; 
	static String placement = "Latency Differentiated Module Placement"; 
	//static String placement = "Module Placement Edgeward";
	//static String placement = "Module Placement Edgeward Differentiated";
	//static String placement = "Latency Modified Module Placement";
	static double MobileCPUload= 0.1;
	
	public static void main(String[] args) {
		Log.print("Starting ECG transmission");	Log.print("             ECG transmission time ms: "); Log.print(ECG_TRANSMISSION_TIME);
		Log.print("     Depts/Mobiles =  "); Log.print (numOfDepts);Log.print("/"); Log.printLine (numOfMobilesPerDept);
		System.out.println("analytics VM mips  2000, Fog device mips: mobile 1000, dept  2800, proxy 16800" ); 

		
		try {
			Log.disable(); 	
			//Config.MAX_SIMULATION_TIME= 100000;
			int num_user = 1; // number of cloud users
			Calendar calendar = Calendar.getInstance();
			boolean trace_flag = false; // mean trace events
			CloudSim.init(num_user, calendar, trace_flag);						
			String appId = "ECG"; 
			FogBroker broker = new FogBroker("broker");			
			createFogDevices(broker.getId(), appId);
			
			Map<String, Double> moduledeadline= new HashMap<String, Double>();
			Map<String, Double> moduledeadline1;
			List<Map<String, Double>> moduledeadline1List;

			for(Integer id : idOfEndDevices){
				Double x= getvalue(5.00, 40.00);
				Double t1= 10.00; Double t2= 5.00; //Double t3= 5.00;
				deadlineInfo.put(id, x);
				
				if (placement.equals("Latency Differentiated Module Placement")||placement.equals("Module Placement Edgeward Differentiated")) {
						if(5.00 < x)&& (x < 10.00)) x=5.00;
						if(10.00 < x < 15.00) x=10.00;
						if(15.00 < x < 20.00) x=20.00;
						if(20.00 < x < 30.00) x=30.00;
						if(30.00 < x < 40.00) x=40.00;
					
							
						
					additionalMipsInfo.put(id, x*100); //1000
					moduledeadline1=  new HashMap<String,Double>();
					moduledeadline1List= new ArrayList<Map<String, Double>>();
					moduledeadline1.put("Client", x*100);
					moduledeadline1.put("Filtering", x*100);
					moduledeadline1.put("Monitoring", x*100);
					moduledeadline1.put("Caregiver", x*100);
					moduledeadline1.put("Cloud_Analytics", x*100);
					moduledeadline1List.add(moduledeadline1);
					deadlineInfomodule1.put(id, moduledeadline1List);
				}
				else {
					additionalMipsInfo.put(id, (double)mymips);
					moduledeadline1=  new HashMap<String,Double>();
					moduledeadline1List= new ArrayList<Map<String, Double>>();
					moduledeadline1.put("Client", (double)mymips);
					moduledeadline1.put("Filtering", (double)mymips);
					moduledeadline1.put("Monitoring", (double)mymips);
					moduledeadline1.put("Caregiver", (double)mymips);
					moduledeadline1.put("Cloud_Analytics", (double)mymips);
					moduledeadline1List.add(moduledeadline1);
					deadlineInfomodule1.put(id, moduledeadline1List);
				}
				moduledeadline.put("Filtering", (x+t1));
				deadlineInfomodule.put(id,moduledeadline);
				moduledeadline.put("Monitoring", (x+ t2));
				deadlineInfomodule.put(id,moduledeadline);
			}	
			
			deadlineInfo=deadlineInfo.entrySet()
		             .stream().sorted(Map.Entry.comparingByValue())
		             .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -> e1, LinkedHashMap::new));			
				
			Application application = createApplication(appId, broker.getId());
			application.setUserId(broker.getId());
			application.setdeviceById(deviceById);
			application.setidOfEndDevices(idOfEndDevices);
			application.setDeadlineInfo(deadlineInfo);
			application.setDeadlineInfomodule(deadlineInfomodule);
			application.setDeadlineInfomodule1(deadlineInfomodule1);
		    application.setAdditionalMipsInfo(additionalMipsInfo);
		    application.setplacement(placement);
		    application.setMobileCPUload(MobileCPUload);
		    
		    System.out.println(String.format("%-25s%s" ,"User Priority ASC ", application.getDeadlineInfo()));
			System.out.println(String.format("%-25s%s" ,"Module Tuble MIPS ",application.getAdditionalMipsInfo()));
		   /// System.out.println(String.format("%-25s%s" ,"Module Priority ",application.getDeadlineInfomodule()));
		    System.out.println(String.format("%-25s%s" ,"Module Priority1 ",application.getDeadlineInfomodule1()));

		    System.out.println("mobile CPU load "+ application.getMobileCPUload());
		    		
			Controller controller = null;
			ModuleMapping moduleMapping = ModuleMapping.createModuleMapping(); // initializing a module mapping			
			moduleMapping.addModuleToDevice("Cloud_Analytics", "cloud");
			for(FogDevice device : fogDevices){
				if(device.getName().startsWith("m"))
					moduleMapping.addModuleToDevice("Client", device.getName());
				}
			if(CLOUD){			 
				moduleMapping.addModuleToDevice("Caregiver", "cloud");
				moduleMapping.addModuleToDevice("Monitoring", "cloud");
				moduleMapping.addModuleToDevice("Filtering", "cloud");
				System.out.println("cloud only module placement, tuple mips= "+ mymips);
				controller = new ControllerEdgeward("master-controller", fogDevices, sensors, actuators);
				controller.submitApplication(application, 0, new ModulePlacementMapping(fogDevices, application,moduleMapping));
				}
			else {
				moduleMapping.addModuleToDevice("Caregiver", "proxy-server");
				switch (placement) { 
				case "Latency Module Placement":{			
					System.out.println("Per User Basic module placement");//", Tuple mips= "+ mymips
					controller = new Controller("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LatencyModulePlacementNear(fogDevices, sensors, actuators, application, moduleMapping));
					break;}	
				case "Latency Modified Module Placement":{
					System.out.println("Per User Modified module placement");
					controller = new Controller("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new ModulePlacementModified(fogDevices, sensors, actuators, application, moduleMapping));
					break;}
				case "Latency Differentiated Module Placement":{
					System.out.println("Per User Differentiated module placement, variable Module/Tuple mips ");
					controller = new Controller("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LatencyModulePlacementNear(fogDevices, sensors, actuators, application, moduleMapping));
					break;} //ModulePlacementDifferentiated
				case "Module Placement Edgeward":{
					System.out.println("Per module placement");
					controller = new ControllerEdgeward("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LModulePlacementEdgewards(fogDevices, sensors, actuators, application, moduleMapping));
					break;}
				case "Module Placement Edgeward Differentiated":{
					System.out.println("Per module Differentiated placement");
					controller = new ControllerEdgeward("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LModulePlacementEdgewards(fogDevices, sensors, actuators, application, moduleMapping));
					break;}
				}
				}
					
			TimeKeeper.getInstance().setSimulationStartTime(Calendar.getInstance().getTimeInMillis());
			CloudSim.startSimulation();
			CloudSim.stopSimulation();
			Log.printLine("ECG finished!");
		} catch (Exception e) {
			e.printStackTrace();
			Log.printLine("Unwanted errors happen");
		}
	}	
/****************************************************************************************
	 * Creates the fog devices in the physical topology of the simulation.
	 * @param userId
	 * @param appId
	 */
	private static void createFogDevices(int userId, String appId) {  // 44800
		FogDevice cloud = createFogDevice("cloud", 44800, 40000, 100, 10000, 0, 0.01, 16*103, 16*83.25); // creates the fog device Cloud at the apex of the hierarchy with level=0
		cloud.setParentId(-1);		 
		FogDevice proxy = createFogDevice("proxy-server", 16800 , 4000, 10000, 10000, 1, 0.0, 107.339, 83.4333); // 2800
		proxy.setParentId(cloud.getId()); // setting Cloud as parent of the Proxy Server
		proxy.setUplinkLatency(100); // latency of connection from Proxy Server to the Cloud is 100 ms		
		fogDevices.add(cloud);
		deviceById.put(cloud.getId(), cloud);
		fogDevices.add(proxy);
		deviceById.put(proxy.getId(), proxy);		
		for(int i=0;i<numOfDepts;i++){
			addGw(i+"", userId, appId, proxy.getId()); // adding a fog device for every Gateway in physical topology. The parent of each gateway is the Proxy Server
		}	
	}

	private static FogDevice addGw(String id, int userId, String appId, int parentId){
		FogDevice dept = createFogDevice("d-"+id, 2800, 4000, 10000, 10000, 2, 0.0, 107.339, 83.4333); //2800
		fogDevices.add(dept);
		deviceById.put(dept.getId(), dept);
		dept.setParentId(parentId);
		dept.setUplinkLatency(4); // latency of connection between gateways and proxy server is 4 ms
		for(int i=0;i<numOfMobilesPerDept;i++){
			String mobileId = id+"-"+i;
			FogDevice mobile = addMobile(mobileId, userId, appId, dept.getId()); // adding mobiles to the physical topology. Smartphones have been modeled as fog devices as well.
			mobile.setUplinkLatency(2); // latency of connection between the smartphone and proxy server is 4 ms
			fogDevices.add(mobile);
			deviceById.put(mobile.getId(), mobile);
		}
		return dept;
	}
	
	private static FogDevice addMobile(String id, int userId, String appId, int parentId){
		FogDevice mobile = createFogDevice("m-"+id, 1000, 1000, 10000, 270, 3, 0, 87.53, 82.44); //1000   
		mobile.setParentId(parentId);
		idOfEndDevices.add(mobile.getId());
		Sensor ecgsensor = new Sensor("s-"+id, "ECG", userId, appId, new DeterministicDistribution(ECG_TRANSMISSION_TIME)); // inter-transmission time of EEG sensor follows a deterministic distribution
		sensors.add(ecgsensor);
		Actuator display = new Actuator("a-"+id, userId, appId, "DISPLAY");
		actuators.add(display);
		ecgsensor.setGatewayDeviceId(mobile.getId());
		ecgsensor.setLatency(6.0);  // latency of connection between EEG sensors and the parent Smartphone is 6 ms
		display.setGatewayDeviceId(mobile.getId());
		display.setLatency(1.0);  // latency of connection between Display actuator and the parent Smartphone is 1 ms
		return mobile;
	}
	
/*****************************************************************************************
	 * Creates a vanilla fog device
	 * @param nodeName name of the device to be used in simulation
	 * @param mips MIPS
	 * @param ram RAM
	 * @param upBw uplink bandwidth
	 * @param downBw downlink bandwidth
	 * @param level hierarchy level of the device
	 * @param ratePerMips cost rate per MIPS used
	 * @param busyPower
	 * @param idlePower
	 * @return
	 */
	private static FogDevice createFogDevice(String nodeName, long mips,
			int ram, long upBw, long downBw, int level, double ratePerMips, double busyPower, double idlePower) {
		
		List<Pe> peList = new ArrayList<Pe>();
		// 3. Create PEs and add these into a list.
		peList.add(new Pe(0, new PeProvisionerOverbooking(mips))); // need to store Pe id and MIPS Rating
		
		int hostId = FogUtils.generateEntityId();
		long storage = 1000000; // host storage
		int bw = 10000;
		PowerHost host = new PowerHost(
				hostId,
				new RamProvisionerSimple(ram),
				new BwProvisionerOverbooking(bw),
				storage,
				peList,
				new StreamOperatorScheduler(peList),
				new FogLinearPowerModel(busyPower, idlePower)
			);

		List<Host> hostList = new ArrayList<Host>();
		hostList.add(host);

		String arch = "x86"; // system architecture
		String os = "Linux"; // operating system
		String vmm = "Xen";
		double time_zone = 10.0; // time zone this resource located
		double cost = 3.0; // the cost of using processing in this resource
		double costPerMem = 0.05; // the cost of using memory in this resource
		double costPerStorage = 0.001; // the cost of using storage in this	// resource
		double costPerBw = 0.0; // the cost of using bw in this resource
		LinkedList<Storage> storageList = new LinkedList<Storage>(); // we are not adding SAN devices by now

		FogDeviceCharacteristics characteristics = new FogDeviceCharacteristics(
				arch, os, vmm, host, time_zone, cost, costPerMem,
				costPerStorage, costPerBw);

		FogDevice fogdevice = null;
		try {
			fogdevice = new FogDevice(nodeName, characteristics, 
					new AppModuleAllocationPolicy(hostList), storageList, 10 , upBw, downBw, 0, ratePerMips); //10 : schedulingInterval  0 uplink  latency		
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		fogdevice.setLevel(level);
		return fogdevice;
	}

/******************************************************************************************
	 * Function to create the EEG Tractor Beam game application in the DDF model. 
	 * @param appId unique identifier of the application
	 * @param userId identifier of the user of the application
	 * @return
	 */
	@SuppressWarnings({"serial" })
	private static Application createApplication(String appId, int userId){
		
		Application application = Application.createApplication(appId, userId); // creates an empty application model (empty directed graph)
		
		// Adding modules (vertices) to the application model (directed graph)
		application.addAppModule("Client", 10, 2000, 1000,100,5); //250Name,int ram, int mips, long size, long bw, int modprty) size is the image size (MB)
		application.addAppModule("Filtering",10, 2000, 500, 100,4); //150
		application.addAppModule("Monitoring",10, 2000, 500,100,3); //150 
		application.addAppModule("Caregiver", 10, 2000,1000,100,2); // 150
		application.addAppModule("Cloud_Analytics",10, 3000,1000,250,1); //500("Cloud_Analytics",10, 500,1000,500,1); //
		
		// Connecting the application modules (vertices) in the application model (directed graph) with edges
		//source, destination, double tupleCpuLength, double tupleNwLength, String tupleType, int direction, int edgeType){
		application.addAppEdge("ECG", "Client", 2000, 500, "ECG", Tuple.UP, AppEdge.SENSOR);
		application.addAppEdge("Client", "Filtering", 2000, 500, "SENSOR_DATA", Tuple.UP, AppEdge.MODULE); //
		application.addAppEdge("Filtering", "Monitoring", mymips, 500, "FILTERED_DATA", Tuple.UP, AppEdge.MODULE); //
		application.addAppEdge("Monitoring", "Caregiver", mymips, 500, "ECG_REPORT", Tuple.UP, AppEdge.MODULE);  //
		application.addAppEdge("Caregiver", "Cloud_Analytics", mymips, 500, "DATA_OFFLOAD", Tuple.UP, AppEdge.MODULE); //		
		application.addAppEdge("Caregiver", "Client", mymips, 500, "State_Action", Tuple.DOWN, AppEdge.MODULE); //  
		application.addAppEdge("Client", "DISPLAY",2000, 500, "P_State_Action", Tuple.DOWN, AppEdge.ACTUATOR);  //
		application.addAppEdge("Cloud_Analytics", "Caregiver", 2000, 1000, "Advanced_Analytics", Tuple.DOWN, AppEdge.MODULE);  
		
 	    //Defining the input-output relationships (represented by selectivity) of the application modules. 
		application.addTupleMapping("Client", "ECG", "SENSOR_DATA", new FractionalSelectivity(1.0)); // 
		application.addTupleMapping("Client", "State_Action", "P_State_Action", new FractionalSelectivity(1.0)); //  
		application.addTupleMapping("Filtering", "SENSOR_DATA", "FILTERED_DATA", new FractionalSelectivity(1.0)); // 
		application.addTupleMapping("Monitoring", "FILTERED_DATA", "ECG_REPORT", new FractionalSelectivity(1.0)); //
		application.addTupleMapping("Caregiver", "ECG_REPORT", "DATA_OFFLOAD", new FractionalSelectivity(1.0)); //
		application.addTupleMapping("Caregiver", "ECG_REPORT", "State_Action", new FractionalSelectivity(1.0)); //
		application.addTupleMapping("Cloud_Analytics", "DATA_OFFLOAD", "Advanced_Analytics", new FractionalSelectivity(0.01)); //
	
		
		 // Defining application loops to monitor the latency of.
		//final AppLoop ONLY_CLOUD = new AppLoop(new ArrayList<String>(){{add("ECG");add("Client");add("Filtering");add("Monitoring");add("Caregiver");add("Client");add("DISPLAY");}}); //add("Cloud_Analytics");
        //List<AppLoop> loops = new ArrayList<AppLoop>(){{ add(ONLY_CLOUD);}};
		//final AppLoop ECG_REPORTING = new AppLoop(new ArrayList<String>(){{add("ECG");add("Client");add("Filtering");add("Monitoring");add("Caregiver");add("Client");add("DISPLAY");}});
        //List<AppLoop> loops = new ArrayList<AppLoop>(){{ add(ECG_REPORTING);}};
		final AppLoop ECG_ANALYTICS = new AppLoop(new ArrayList<String>(){{add("ECG");add("Client");add("Filtering");add("Monitoring");add("Caregiver");}});
        List<AppLoop> loops = new ArrayList<AppLoop>(){{add( ECG_ANALYTICS);}}; 
 		application.setLoops(loops);
		return application;
		}
///random number generators//////////////////////////////////////////////////////////
	private static double getvalue(double d, double e)  { 
	    Random r = new Random(); 
	    double randomValue = d + (e - d) *r.nextDouble(); 
	   // randomValue = r.nextDouble();
	    return randomValue; 
	  } 
	private static Integer getvalue(int min, int max) { 
	    Random r = new Random(); 
	    Integer randomValue = min + r.nextInt()%(max - min); 
	   // randomValue = r.nextInt(max);
	    return randomValue; 
	  }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//scheduled cloudlet processing =30,100,200,300,500 mips for filtering monitoring caregiver  
//scheduled cloudlet processing = 1000  for client and cloudanalytics modules
// mobile id, need Modulename executed with max delay (3:5)
//static Pair<String, Double> moduledeadline = new Pair <String, Double>(null,null);  // mobile id need deadline double
//static List<Pair<String, Double>> moduledeadline = new ArrayList<Pair <String, Double>>();


//if(placement.equals("Latency Differentiated Module Placement")) {		
//System.out.println(String.format("%-30s%s" ,"Per_User Differentiated Module Placement, " ," variable mips between 50 mips, "+  mymips+ " for all modules except cloud plus 1000 mips"));
//}		
//else if(placement.equals("Module Placement Edgeward")) {
//System.out.println(String.format("%-30s%20s%s%30s%10s%s" ,"Per_Module Edgeward Placement","const mips= " , mymips));
//System.out.println("Per_Module Placement,  Tuple's mips= " + mymips);
//}
///else 
//placement=="Latency Module Placement" 
//System.out.println(String.format("%-30s%20s%s%30s%10s%s" ,"Per_User Basic Module Placement","const mips= " , mymips));
//System.out.println("Per_User Basic Module Placement,  const mips= " + mymips);		

//System.out.println("Application Module mips: Client = Filtering = Monitoring = Caregiver = 300 mips , Cloud_Analytics = 600 mips");
//System.out.println("Migration Condition: Mobile Utilization >= 0.3, Proxy/Dept Utilization >= 0.9" );  //, RESOURCE_MANAGE_INTERVAL = 100 ");
//System.out.println("Enhanced Migration Conditions , RESOURCE_MANAGE_INTERVAL = 10 ");
//System.out.println("fog device scheduling interval = 10,  Application module scheduling interval = 300  ");	

//moduledeadline.put("Client", (x+ 15.0000000000000000));
//deadlineInfomodule.put(id,moduledeadline);
//moduledeadline.put("Caregiver", x);
//deadlineInfomodule.put(id,moduledeadline);				
//System.out.println("deadlineInfomodule  "+ deadlineInfomodule);
//deadlineInfomodule.put(id,moduledeadlinelist);				
//moduledeadline.clear();

/*
for(Integer id : idOfEndDevices){
	if (placement.equals("Latency Differentiated Module Placement")) {
		Integer x= getvalue(50, 500);//mymips);
		x= Math.abs(x);
		additionalMipsInfo.put(id, (double)x);  //getvalue(0,mymips)
		}
	else
		additionalMipsInfo.put(id, (double)mymips);
}
*/
/*else if(device.getName().startsWith("d")){
moduleMapping.addModuleToDevice("Filtering", device.getName());
moduleMapping.addModuleToDevice("Monitoring", device.getName());				
} */
//Controller controller = new Controller("master-controller", fogDevices, sensors, actuators);
//controller.submitApplication(application, 0, new ModulePlacementOnlyCloud(fogDevices, sensors, actuators, application));
//controller.submitApplication(application, 0, new LatencyModulePlacement(fogDevices, sensors, actuators, application, moduleMapping));
//controller.submitApplication(application, 0, new LatencyModifiedModulePlacementNew(fogDevices, sensors, actuators, application, moduleMapping));
 //LModulePlacementEdgewards  // LatencyModulePlacementNear

//TRY FogDevice cloud = createFogDevice("cloud", 448000000, 40000000, 100000, 10000000, 0, 0.01, 16*103, 16*83.25); // creates the fog device Cloud at the apex of the hierarchy with level=0
//FogDevice cloud = createFogDevice("cloud", 4480000, 4000000, 100, 10000, 0, 0.01, 16*103, 16*83.25); // creates the fog device Cloud at the apex of the hierarchy with level=0
//FogDevice proxy = createFogDevice("proxy-server", 2800, 4000, 10000, 10000, 1, 0.0, 107.339, 83.4333);

//peList.add(new Pe(0, new PeProvisionerSimple(mips))); // need to store Pe id and MIPS Rating


/*
application.addAppModule("Client", 10, 300, 1000,100,5); // adding module Client to the application model
application.addAppModule("Filtering",10, 300, 1000, 100,4); //
application.addAppModule("Monitoring",10, 300, 1000,100,3); // 
application.addAppModule("Caregiver", 10, 300,1000,100,2); // 
application.addAppModule("Cloud_Analytics",10, 600,1000,250,1); //("Cloud_Analytics",10, 500,1000,500,1); //
*/
/*application.addAppEdge("ECG", "Client", 3000, 1000, "ECG", Tuple.UP, AppEdge.SENSOR);
application.addAppEdge("Client", "Filtering", 3000, 500, "SENSOR_DATA", Tuple.UP, AppEdge.MODULE); //
application.addAppEdge("Filtering", "Monitoring", (30+ mymips), 500, "FILTERED_DATA", Tuple.UP, AppEdge.MODULE); // 
application.addAppEdge("Monitoring", "Cloud_Analytics", 1000, 500, "DATA_OFFLOAD", Tuple.UP, AppEdge.MODULE); // 
application.addAppEdge("Monitoring", "Caregiver", (60+ mymips) , 500, "ECG_REPORT", Tuple.UP, AppEdge.MODULE);  // 
application.addAppEdge("Cloud_Analytics", "Caregiver", 3500, 1000, "Advanced_Analytics", Tuple.DOWN, AppEdge.MODULE);  // 
application.addAppEdge("Caregiver", "Client", 1000 , 500, "State_Action", Tuple.DOWN, AppEdge.MODULE); // 
application.addAppEdge("Client", "DISPLAY",1000, 500, "P_State_Action", Tuple.DOWN, AppEdge.ACTUATOR);  //
 */
//application.addAppEdge("Caregiver", "Cloud_Analytics", 3000, 1000, "DECISION", Tuple.UP, AppEdge.MODULE); //
// application.addTupleMapping("Cloud_Analytics", "DECISION", "Advanced_Analytics", new FractionalSelectivity(0.001)); //
//final AppLoop HBR_Analytics = new AppLoop(new ArrayList<String>(){{add("HBR"); add("Client"); add("Monitoring"); add("Cloud_Analytics"); add("Caregiver"); add("Client"); add("DISPLAY");}});

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10055, count -3525, length 26085
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-10-15 12:35:32.713
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.StringIndexOutOfBoundsException: offset 10055, count -3525, length 26085
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:324)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10055, count -3525, length 26085
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	... 19 more
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10055, count -3525, length 26085
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2020-10-15 12:35:32.713
!MESSAGE offset 10055, count -3525, length 26085
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10055, count -3525, length 26085
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2020-10-15 12:35:32.713
!MESSAGE offset 10055, count -3525, length 26085
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10055, count -3525, length 26085
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-10-15 12:35:32.713
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.StringIndexOutOfBoundsException: offset 10055, count -3525, length 26085
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:324)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10055, count -3525, length 26085
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	... 19 more
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10055, count -3525, length 26085
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2020-10-15 12:35:32.713
!MESSAGE offset 10055, count -3525, length 26085
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10055, count -3525, length 26085
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2020-10-15 12:35:33.725
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
package org.fog.test.perfeval;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.stream.Collectors;
import org.apache.commons.math3.util.Pair;
import org.cloudbus.cloudsim.Host;
import org.cloudbus.cloudsim.Log;
import org.cloudbus.cloudsim.Pe;
import org.cloudbus.cloudsim.Storage;
import org.cloudbus.cloudsim.core.CloudSim;
import org.cloudbus.cloudsim.power.PowerHost;
import org.cloudbus.cloudsim.provisioners.PeProvisionerSimple;
import org.cloudbus.cloudsim.provisioners.RamProvisionerSimple;
import org.cloudbus.cloudsim.sdn.overbooking.BwProvisionerOverbooking;
import org.cloudbus.cloudsim.sdn.overbooking.PeProvisionerOverbooking;
import org.fog.application.AppEdge;
import org.fog.application.AppLoop;
import org.fog.application.Application;
import org.fog.application.selectivity.FractionalSelectivity;
import org.fog.entities.Actuator;
import org.fog.entities.FogBroker;
import org.fog.entities.FogDevice;
import org.fog.entities.FogDeviceCharacteristics;
import org.fog.entities.Sensor;
import org.fog.entities.Tuple;
import org.fog.placement.Controller;
import org.fog.placement.ControllerEdgeward;
import org.fog.placement.LModulePlacementEdgewards;
import org.fog.placement.LatencyModulePlacementNear;
import org.fog.placement.ModuleMapping;
import org.fog.placement.ModulePlacementDifferentiated;
import org.fog.placement.ModulePlacementEdgewards;
import org.fog.placement.ModulePlacementMapping;
import org.fog.placement.ModulePlacementModified;
import org.fog.placement.ModulePlacementOnlyCloud;
import org.fog.policy.AppModuleAllocationPolicy;
import org.fog.scheduler.StreamOperatorScheduler;
import org.fog.utils.Config;
import org.fog.utils.FogLinearPowerModel;
import org.fog.utils.FogUtils;
import org.fog.utils.TimeKeeper;
import org.fog.utils.distribution.DeterministicDistribution;

/**
 * Simulation setup for  ECG
 * @author Ragaa Shehab
 *
 */ //updateTimingsOnReceipt - checkCloudletCompletion --tupleEndedExecutionUser
public class ECG {
	static List<FogDevice> fogDevices = new ArrayList<FogDevice>();
	static List<Sensor> sensors = new ArrayList<Sensor>();
	static List<Actuator> actuators = new ArrayList<Actuator>();
	static Map<Integer,FogDevice> deviceById = new HashMap<Integer,FogDevice>();	
	static List<Integer> idOfEndDevices = new ArrayList<Integer>();
	static Map<Integer, Double> deadlineInfo = new	HashMap<Integer, Double>();  // mobile id has priority
	static Map<Integer, Double> additionalMipsInfo = new HashMap<Integer, Double>(); // mobile id need tuple mips
	static Map<Integer, Map<String, Double>> deadlineInfomodule = new HashMap<Integer, Map<String,Double>>();  // mobile id has modulename with module priority
	static Map<Integer,List<Map<String, Double>>> deadlineInfomodule1 = new HashMap<Integer, List<Map<String,Double>>>();  // mobile id has modulename with module priority

	static boolean CLOUD = false;
	static int numOfDepts = 1;
	static int numOfMobilesPerDept =5;
	static double ECG_TRANSMISSION_TIME = 50.0 ; // 50.0;   //100, 50, 25 ms   100 //10s= 10000
	static public int mymips= 2000;     
	//static String placement = "Latency Module Placement"; 
	static String placement = "Latency Differentiated Module Placement"; 
	//static String placement = "Module Placement Edgeward";
	//static String placement = "Module Placement Edgeward Differentiated";
	//static String placement = "Latency Modified Module Placement";
	static double MobileCPUload= 0.1;
	
	public static void main(String[] args) {
		Log.print("Starting ECG transmission");	Log.print("             ECG transmission time ms: "); Log.print(ECG_TRANSMISSION_TIME);
		Log.print("     Depts/Mobiles =  "); Log.print (numOfDepts);Log.print("/"); Log.printLine (numOfMobilesPerDept);
		System.out.println("analytics VM mips  2000, Fog device mips: mobile 1000, dept  2800, proxy 16800" ); 

		
		try {
			Log.disable(); 	
			//Config.MAX_SIMULATION_TIME= 100000;
			int num_user = 1; // number of cloud users
			Calendar calendar = Calendar.getInstance();
			boolean trace_flag = false; // mean trace events
			CloudSim.init(num_user, calendar, trace_flag);						
			String appId = "ECG"; 
			FogBroker broker = new FogBroker("broker");			
			createFogDevices(broker.getId(), appId);
			
			Map<String, Double> moduledeadline= new HashMap<String, Double>();
			Map<String, Double> moduledeadline1;
			List<Map<String, Double>> moduledeadline1List;

			for(Integer id : idOfEndDevices){
				Double x= getvalue(5.00, 40.00);
				Double t1= 10.00; Double t2= 5.00; //Double t3= 5.00;
				deadlineInfo.put(id, x);
				
				if (placement.equals("Latency Differentiated Module Placement")||placement.equals("Module Placement Edgeward Differentiated")) {
						if(5.00 < x)&& (x < 10.00)) x=5.00;
						if(10.00 < x < 15.00) x=10.00;
						if(15.00 < x < 20.00) x=20.00;
						if(20.00 < x < 30.00) x=30.00;
						if(30.00 < x < 40.00) x=40.00;
					
							
						
					additionalMipsInfo.put(id, x*100); //1000
					moduledeadline1=  new HashMap<String,Double>();
					moduledeadline1List= new ArrayList<Map<String, Double>>();
					moduledeadline1.put("Client", x*100);
					moduledeadline1.put("Filtering", x*100);
					moduledeadline1.put("Monitoring", x*100);
					moduledeadline1.put("Caregiver", x*100);
					moduledeadline1.put("Cloud_Analytics", x*100);
					moduledeadline1List.add(moduledeadline1);
					deadlineInfomodule1.put(id, moduledeadline1List);
				}
				else {
					additionalMipsInfo.put(id, (double)mymips);
					moduledeadline1=  new HashMap<String,Double>();
					moduledeadline1List= new ArrayList<Map<String, Double>>();
					moduledeadline1.put("Client", (double)mymips);
					moduledeadline1.put("Filtering", (double)mymips);
					moduledeadline1.put("Monitoring", (double)mymips);
					moduledeadline1.put("Caregiver", (double)mymips);
					moduledeadline1.put("Cloud_Analytics", (double)mymips);
					moduledeadline1List.add(moduledeadline1);
					deadlineInfomodule1.put(id, moduledeadline1List);
				}
				moduledeadline.put("Filtering", (x+t1));
				deadlineInfomodule.put(id,moduledeadline);
				moduledeadline.put("Monitoring", (x+ t2));
				deadlineInfomodule.put(id,moduledeadline);
			}	
			
			deadlineInfo=deadlineInfo.entrySet()
		             .stream().sorted(Map.Entry.comparingByValue())
		             .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -> e1, LinkedHashMap::new));			
				
			Application application = createApplication(appId, broker.getId());
			application.setUserId(broker.getId());
			application.setdeviceById(deviceById);
			application.setidOfEndDevices(idOfEndDevices);
			application.setDeadlineInfo(deadlineInfo);
			application.setDeadlineInfomodule(deadlineInfomodule);
			application.setDeadlineInfomodule1(deadlineInfomodule1);
		    application.setAdditionalMipsInfo(additionalMipsInfo);
		    application.setplacement(placement);
		    application.setMobileCPUload(MobileCPUload);
		    
		    System.out.println(String.format("%-25s%s" ,"User Priority ASC ", application.getDeadlineInfo()));
			System.out.println(String.format("%-25s%s" ,"Module Tuble MIPS ",application.getAdditionalMipsInfo()));
		   /// System.out.println(String.format("%-25s%s" ,"Module Priority ",application.getDeadlineInfomodule()));
		    System.out.println(String.format("%-25s%s" ,"Module Priority1 ",application.getDeadlineInfomodule1()));

		    System.out.println("mobile CPU load "+ application.getMobileCPUload());
		    		
			Controller controller = null;
			ModuleMapping moduleMapping = ModuleMapping.createModuleMapping(); // initializing a module mapping			
			moduleMapping.addModuleToDevice("Cloud_Analytics", "cloud");
			for(FogDevice device : fogDevices){
				if(device.getName().startsWith("m"))
					moduleMapping.addModuleToDevice("Client", device.getName());
				}
			if(CLOUD){			 
				moduleMapping.addModuleToDevice("Caregiver", "cloud");
				moduleMapping.addModuleToDevice("Monitoring", "cloud");
				moduleMapping.addModuleToDevice("Filtering", "cloud");
				System.out.println("cloud only module placement, tuple mips= "+ mymips);
				controller = new ControllerEdgeward("master-controller", fogDevices, sensors, actuators);
				controller.submitApplication(application, 0, new ModulePlacementMapping(fogDevices, application,moduleMapping));
				}
			else {
				moduleMapping.addModuleToDevice("Caregiver", "proxy-server");
				switch (placement) { 
				case "Latency Module Placement":{			
					System.out.println("Per User Basic module placement");//", Tuple mips= "+ mymips
					controller = new Controller("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LatencyModulePlacementNear(fogDevices, sensors, actuators, application, moduleMapping));
					break;}	
				case "Latency Modified Module Placement":{
					System.out.println("Per User Modified module placement");
					controller = new Controller("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new ModulePlacementModified(fogDevices, sensors, actuators, application, moduleMapping));
					break;}
				case "Latency Differentiated Module Placement":{
					System.out.println("Per User Differentiated module placement, variable Module/Tuple mips ");
					controller = new Controller("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LatencyModulePlacementNear(fogDevices, sensors, actuators, application, moduleMapping));
					break;} //ModulePlacementDifferentiated
				case "Module Placement Edgeward":{
					System.out.println("Per module placement");
					controller = new ControllerEdgeward("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LModulePlacementEdgewards(fogDevices, sensors, actuators, application, moduleMapping));
					break;}
				case "Module Placement Edgeward Differentiated":{
					System.out.println("Per module Differentiated placement");
					controller = new ControllerEdgeward("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LModulePlacementEdgewards(fogDevices, sensors, actuators, application, moduleMapping));
					break;}
				}
				}
					
			TimeKeeper.getInstance().setSimulationStartTime(Calendar.getInstance().getTimeInMillis());
			CloudSim.startSimulation();
			CloudSim.stopSimulation();
			Log.printLine("ECG finished!");
		} catch (Exception e) {
			e.printStackTrace();
			Log.printLine("Unwanted errors happen");
		}
	}	
/****************************************************************************************
	 * Creates the fog devices in the physical topology of the simulation.
	 * @param userId
	 * @param appId
	 */
	private static void createFogDevices(int userId, String appId) {  // 44800
		FogDevice cloud = createFogDevice("cloud", 44800, 40000, 100, 10000, 0, 0.01, 16*103, 16*83.25); // creates the fog device Cloud at the apex of the hierarchy with level=0
		cloud.setParentId(-1);		 
		FogDevice proxy = createFogDevice("proxy-server", 16800 , 4000, 10000, 10000, 1, 0.0, 107.339, 83.4333); // 2800
		proxy.setParentId(cloud.getId()); // setting Cloud as parent of the Proxy Server
		proxy.setUplinkLatency(100); // latency of connection from Proxy Server to the Cloud is 100 ms		
		fogDevices.add(cloud);
		deviceById.put(cloud.getId(), cloud);
		fogDevices.add(proxy);
		deviceById.put(proxy.getId(), proxy);		
		for(int i=0;i<numOfDepts;i++){
			addGw(i+"", userId, appId, proxy.getId()); // adding a fog device for every Gateway in physical topology. The parent of each gateway is the Proxy Server
		}	
	}

	private static FogDevice addGw(String id, int userId, String appId, int parentId){
		FogDevice dept = createFogDevice("d-"+id, 2800, 4000, 10000, 10000, 2, 0.0, 107.339, 83.4333); //2800
		fogDevices.add(dept);
		deviceById.put(dept.getId(), dept);
		dept.setParentId(parentId);
		dept.setUplinkLatency(4); // latency of connection between gateways and proxy server is 4 ms
		for(int i=0;i<numOfMobilesPerDept;i++){
			String mobileId = id+"-"+i;
			FogDevice mobile = addMobile(mobileId, userId, appId, dept.getId()); // adding mobiles to the physical topology. Smartphones have been modeled as fog devices as well.
			mobile.setUplinkLatency(2); // latency of connection between the smartphone and proxy server is 4 ms
			fogDevices.add(mobile);
			deviceById.put(mobile.getId(), mobile);
		}
		return dept;
	}
	
	private static FogDevice addMobile(String id, int userId, String appId, int parentId){
		FogDevice mobile = createFogDevice("m-"+id, 1000, 1000, 10000, 270, 3, 0, 87.53, 82.44); //1000   
		mobile.setParentId(parentId);
		idOfEndDevices.add(mobile.getId());
		Sensor ecgsensor = new Sensor("s-"+id, "ECG", userId, appId, new DeterministicDistribution(ECG_TRANSMISSION_TIME)); // inter-transmission time of EEG sensor follows a deterministic distribution
		sensors.add(ecgsensor);
		Actuator display = new Actuator("a-"+id, userId, appId, "DISPLAY");
		actuators.add(display);
		ecgsensor.setGatewayDeviceId(mobile.getId());
		ecgsensor.setLatency(6.0);  // latency of connection between EEG sensors and the parent Smartphone is 6 ms
		display.setGatewayDeviceId(mobile.getId());
		display.setLatency(1.0);  // latency of connection between Display actuator and the parent Smartphone is 1 ms
		return mobile;
	}
	
/*****************************************************************************************
	 * Creates a vanilla fog device
	 * @param nodeName name of the device to be used in simulation
	 * @param mips MIPS
	 * @param ram RAM
	 * @param upBw uplink bandwidth
	 * @param downBw downlink bandwidth
	 * @param level hierarchy level of the device
	 * @param ratePerMips cost rate per MIPS used
	 * @param busyPower
	 * @param idlePower
	 * @return
	 */
	private static FogDevice createFogDevice(String nodeName, long mips,
			int ram, long upBw, long downBw, int level, double ratePerMips, double busyPower, double idlePower) {
		
		List<Pe> peList = new ArrayList<Pe>();
		// 3. Create PEs and add these into a list.
		peList.add(new Pe(0, new PeProvisionerOverbooking(mips))); // need to store Pe id and MIPS Rating
		
		int hostId = FogUtils.generateEntityId();
		long storage = 1000000; // host storage
		int bw = 10000;
		PowerHost host = new PowerHost(
				hostId,
				new RamProvisionerSimple(ram),
				new BwProvisionerOverbooking(bw),
				storage,
				peList,
				new StreamOperatorScheduler(peList),
				new FogLinearPowerModel(busyPower, idlePower)
			);

		List<Host> hostList = new ArrayList<Host>();
		hostList.add(host);

		String arch = "x86"; // system architecture
		String os = "Linux"; // operating system
		String vmm = "Xen";
		double time_zone = 10.0; // time zone this resource located
		double cost = 3.0; // the cost of using processing in this resource
		double costPerMem = 0.05; // the cost of using memory in this resource
		double costPerStorage = 0.001; // the cost of using storage in this	// resource
		double costPerBw = 0.0; // the cost of using bw in this resource
		LinkedList<Storage> storageList = new LinkedList<Storage>(); // we are not adding SAN devices by now

		FogDeviceCharacteristics characteristics = new FogDeviceCharacteristics(
				arch, os, vmm, host, time_zone, cost, costPerMem,
				costPerStorage, costPerBw);

		FogDevice fogdevice = null;
		try {
			fogdevice = new FogDevice(nodeName, characteristics, 
					new AppModuleAllocationPolicy(hostList), storageList, 10 , upBw, downBw, 0, ratePerMips); //10 : schedulingInterval  0 uplink  latency		
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		fogdevice.setLevel(level);
		return fogdevice;
	}

/******************************************************************************************
	 * Function to create the EEG Tractor Beam game application in the DDF model. 
	 * @param appId unique identifier of the application
	 * @param userId identifier of the user of the application
	 * @return
	 */
	@SuppressWarnings({"serial" })
	private static Application createApplication(String appId, int userId){
		
		Application application = Application.createApplication(appId, userId); // creates an empty application model (empty directed graph)
		
		// Adding modules (vertices) to the application model (directed graph)
		application.addAppModule("Client", 10, 2000, 1000,100,5); //250Name,int ram, int mips, long size, long bw, int modprty) size is the image size (MB)
		application.addAppModule("Filtering",10, 2000, 500, 100,4); //150
		application.addAppModule("Monitoring",10, 2000, 500,100,3); //150 
		application.addAppModule("Caregiver", 10, 2000,1000,100,2); // 150
		application.addAppModule("Cloud_Analytics",10, 3000,1000,250,1); //500("Cloud_Analytics",10, 500,1000,500,1); //
		
		// Connecting the application modules (vertices) in the application model (directed graph) with edges
		//source, destination, double tupleCpuLength, double tupleNwLength, String tupleType, int direction, int edgeType){
		application.addAppEdge("ECG", "Client", 2000, 500, "ECG", Tuple.UP, AppEdge.SENSOR);
		application.addAppEdge("Client", "Filtering", 2000, 500, "SENSOR_DATA", Tuple.UP, AppEdge.MODULE); //
		application.addAppEdge("Filtering", "Monitoring", mymips, 500, "FILTERED_DATA", Tuple.UP, AppEdge.MODULE); //
		application.addAppEdge("Monitoring", "Caregiver", mymips, 500, "ECG_REPORT", Tuple.UP, AppEdge.MODULE);  //
		application.addAppEdge("Caregiver", "Cloud_Analytics", mymips, 500, "DATA_OFFLOAD", Tuple.UP, AppEdge.MODULE); //		
		application.addAppEdge("Caregiver", "Client", mymips, 500, "State_Action", Tuple.DOWN, AppEdge.MODULE); //  
		application.addAppEdge("Client", "DISPLAY",2000, 500, "P_State_Action", Tuple.DOWN, AppEdge.ACTUATOR);  //
		application.addAppEdge("Cloud_Analytics", "Caregiver", 2000, 1000, "Advanced_Analytics", Tuple.DOWN, AppEdge.MODULE);  
		
 	    //Defining the input-output relationships (represented by selectivity) of the application modules. 
		application.addTupleMapping("Client", "ECG", "SENSOR_DATA", new FractionalSelectivity(1.0)); // 
		application.addTupleMapping("Client", "State_Action", "P_State_Action", new FractionalSelectivity(1.0)); //  
		application.addTupleMapping("Filtering", "SENSOR_DATA", "FILTERED_DATA", new FractionalSelectivity(1.0)); // 
		application.addTupleMapping("Monitoring", "FILTERED_DATA", "ECG_REPORT", new FractionalSelectivity(1.0)); //
		application.addTupleMapping("Caregiver", "ECG_REPORT", "DATA_OFFLOAD", new FractionalSelectivity(1.0)); //
		application.addTupleMapping("Caregiver", "ECG_REPORT", "State_Action", new FractionalSelectivity(1.0)); //
		application.addTupleMapping("Cloud_Analytics", "DATA_OFFLOAD", "Advanced_Analytics", new FractionalSelectivity(0.01)); //
	
		
		 // Defining application loops to monitor the latency of.
		//final AppLoop ONLY_CLOUD = new AppLoop(new ArrayList<String>(){{add("ECG");add("Client");add("Filtering");add("Monitoring");add("Caregiver");add("Client");add("DISPLAY");}}); //add("Cloud_Analytics");
        //List<AppLoop> loops = new ArrayList<AppLoop>(){{ add(ONLY_CLOUD);}};
		//final AppLoop ECG_REPORTING = new AppLoop(new ArrayList<String>(){{add("ECG");add("Client");add("Filtering");add("Monitoring");add("Caregiver");add("Client");add("DISPLAY");}});
        //List<AppLoop> loops = new ArrayList<AppLoop>(){{ add(ECG_REPORTING);}};
		final AppLoop ECG_ANALYTICS = new AppLoop(new ArrayList<String>(){{add("ECG");add("Client");add("Filtering");add("Monitoring");add("Caregiver");}});
        List<AppLoop> loops = new ArrayList<AppLoop>(){{add( ECG_ANALYTICS);}}; 
 		application.setLoops(loops);
		return application;
		}
///random number generators//////////////////////////////////////////////////////////
	private static double getvalue(double d, double e)  { 
	    Random r = new Random(); 
	    double randomValue = d + (e - d) *r.nextDouble(); 
	   // randomValue = r.nextDouble();
	    return randomValue; 
	  } 
	private static Integer getvalue(int min, int max) { 
	    Random r = new Random(); 
	    Integer randomValue = min + r.nextInt()%(max - min); 
	   // randomValue = r.nextInt(max);
	    return randomValue; 
	  }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//scheduled cloudlet processing =30,100,200,300,500 mips for filtering monitoring caregiver  
//scheduled cloudlet processing = 1000  for client and cloudanalytics modules
// mobile id, need Modulename executed with max delay (3:5)
//static Pair<String, Double> moduledeadline = new Pair <String, Double>(null,null);  // mobile id need deadline double
//static List<Pair<String, Double>> moduledeadline = new ArrayList<Pair <String, Double>>();


//if(placement.equals("Latency Differentiated Module Placement")) {		
//System.out.println(String.format("%-30s%s" ,"Per_User Differentiated Module Placement, " ," variable mips between 50 mips, "+  mymips+ " for all modules except cloud plus 1000 mips"));
//}		
//else if(placement.equals("Module Placement Edgeward")) {
//System.out.println(String.format("%-30s%20s%s%30s%10s%s" ,"Per_Module Edgeward Placement","const mips= " , mymips));
//System.out.println("Per_Module Placement,  Tuple's mips= " + mymips);
//}
///else 
//placement=="Latency Module Placement" 
//System.out.println(String.format("%-30s%20s%s%30s%10s%s" ,"Per_User Basic Module Placement","const mips= " , mymips));
//System.out.println("Per_User Basic Module Placement,  const mips= " + mymips);		

//System.out.println("Application Module mips: Client = Filtering = Monitoring = Caregiver = 300 mips , Cloud_Analytics = 600 mips");
//System.out.println("Migration Condition: Mobile Utilization >= 0.3, Proxy/Dept Utilization >= 0.9" );  //, RESOURCE_MANAGE_INTERVAL = 100 ");
//System.out.println("Enhanced Migration Conditions , RESOURCE_MANAGE_INTERVAL = 10 ");
//System.out.println("fog device scheduling interval = 10,  Application module scheduling interval = 300  ");	

//moduledeadline.put("Client", (x+ 15.0000000000000000));
//deadlineInfomodule.put(id,moduledeadline);
//moduledeadline.put("Caregiver", x);
//deadlineInfomodule.put(id,moduledeadline);				
//System.out.println("deadlineInfomodule  "+ deadlineInfomodule);
//deadlineInfomodule.put(id,moduledeadlinelist);				
//moduledeadline.clear();

/*
for(Integer id : idOfEndDevices){
	if (placement.equals("Latency Differentiated Module Placement")) {
		Integer x= getvalue(50, 500);//mymips);
		x= Math.abs(x);
		additionalMipsInfo.put(id, (double)x);  //getvalue(0,mymips)
		}
	else
		additionalMipsInfo.put(id, (double)mymips);
}
*/
/*else if(device.getName().startsWith("d")){
moduleMapping.addModuleToDevice("Filtering", device.getName());
moduleMapping.addModuleToDevice("Monitoring", device.getName());				
} */
//Controller controller = new Controller("master-controller", fogDevices, sensors, actuators);
//controller.submitApplication(application, 0, new ModulePlacementOnlyCloud(fogDevices, sensors, actuators, application));
//controller.submitApplication(application, 0, new LatencyModulePlacement(fogDevices, sensors, actuators, application, moduleMapping));
//controller.submitApplication(application, 0, new LatencyModifiedModulePlacementNew(fogDevices, sensors, actuators, application, moduleMapping));
 //LModulePlacementEdgewards  // LatencyModulePlacementNear

//TRY FogDevice cloud = createFogDevice("cloud", 448000000, 40000000, 100000, 10000000, 0, 0.01, 16*103, 16*83.25); // creates the fog device Cloud at the apex of the hierarchy with level=0
//FogDevice cloud = createFogDevice("cloud", 4480000, 4000000, 100, 10000, 0, 0.01, 16*103, 16*83.25); // creates the fog device Cloud at the apex of the hierarchy with level=0
//FogDevice proxy = createFogDevice("proxy-server", 2800, 4000, 10000, 10000, 1, 0.0, 107.339, 83.4333);

//peList.add(new Pe(0, new PeProvisionerSimple(mips))); // need to store Pe id and MIPS Rating


/*
application.addAppModule("Client", 10, 300, 1000,100,5); // adding module Client to the application model
application.addAppModule("Filtering",10, 300, 1000, 100,4); //
application.addAppModule("Monitoring",10, 300, 1000,100,3); // 
application.addAppModule("Caregiver", 10, 300,1000,100,2); // 
application.addAppModule("Cloud_Analytics",10, 600,1000,250,1); //("Cloud_Analytics",10, 500,1000,500,1); //
*/
/*application.addAppEdge("ECG", "Client", 3000, 1000, "ECG", Tuple.UP, AppEdge.SENSOR);
application.addAppEdge("Client", "Filtering", 3000, 500, "SENSOR_DATA", Tuple.UP, AppEdge.MODULE); //
application.addAppEdge("Filtering", "Monitoring", (30+ mymips), 500, "FILTERED_DATA", Tuple.UP, AppEdge.MODULE); // 
application.addAppEdge("Monitoring", "Cloud_Analytics", 1000, 500, "DATA_OFFLOAD", Tuple.UP, AppEdge.MODULE); // 
application.addAppEdge("Monitoring", "Caregiver", (60+ mymips) , 500, "ECG_REPORT", Tuple.UP, AppEdge.MODULE);  // 
application.addAppEdge("Cloud_Analytics", "Caregiver", 3500, 1000, "Advanced_Analytics", Tuple.DOWN, AppEdge.MODULE);  // 
application.addAppEdge("Caregiver", "Client", 1000 , 500, "State_Action", Tuple.DOWN, AppEdge.MODULE); // 
application.addAppEdge("Client", "DISPLAY",1000, 500, "P_State_Action", Tuple.DOWN, AppEdge.ACTUATOR);  //
 */
//application.addAppEdge("Caregiver", "Cloud_Analytics", 3000, 1000, "DECISION", Tuple.UP, AppEdge.MODULE); //
// application.addTupleMapping("Cloud_Analytics", "DECISION", "Advanced_Analytics", new FractionalSelectivity(0.001)); //
//final AppLoop HBR_Analytics = new AppLoop(new ArrayList<String>(){{add("HBR"); add("Client"); add("Monitoring"); add("Cloud_Analytics"); add("Caregiver"); add("Client"); add("DISPLAY");}});

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10055, count -3525, length 26085
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-10-15 12:35:33.727
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.StringIndexOutOfBoundsException: offset 10055, count -3525, length 26085
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:324)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10055, count -3525, length 26085
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	... 16 more
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10055, count -3525, length 26085
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2020-10-15 12:35:33.727
!MESSAGE offset 10055, count -3525, length 26085
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10055, count -3525, length 26085
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2020-10-15 12:35:33.727
!MESSAGE offset 10055, count -3525, length 26085
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10055, count -3525, length 26085
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-10-15 12:35:33.728
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.StringIndexOutOfBoundsException: offset 10055, count -3525, length 26085
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:324)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10055, count -3525, length 26085
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	... 16 more
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10055, count -3525, length 26085
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2020-10-15 12:35:33.728
!MESSAGE offset 10055, count -3525, length 26085
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10055, count -3525, length 26085
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-10-15 12:35:33.736
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10055, count -3525, length 26085
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-10-15 12:35:33.737
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10055, count -3525, length 26085
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-10-15 12:35:36.396
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10055, count -3525, length 26085
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-10-15 12:35:36.397
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10055, count -3525, length 26085
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-10-15 12:36:18.320
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
package org.fog.test.perfeval;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.stream.Collectors;
import org.apache.commons.math3.util.Pair;
import org.cloudbus.cloudsim.Host;
import org.cloudbus.cloudsim.Log;
import org.cloudbus.cloudsim.Pe;
import org.cloudbus.cloudsim.Storage;
import org.cloudbus.cloudsim.core.CloudSim;
import org.cloudbus.cloudsim.power.PowerHost;
import org.cloudbus.cloudsim.provisioners.PeProvisionerSimple;
import org.cloudbus.cloudsim.provisioners.RamProvisionerSimple;
import org.cloudbus.cloudsim.sdn.overbooking.BwProvisionerOverbooking;
import org.cloudbus.cloudsim.sdn.overbooking.PeProvisionerOverbooking;
import org.fog.application.AppEdge;
import org.fog.application.AppLoop;
import org.fog.application.Application;
import org.fog.application.selectivity.FractionalSelectivity;
import org.fog.entities.Actuator;
import org.fog.entities.FogBroker;
import org.fog.entities.FogDevice;
import org.fog.entities.FogDeviceCharacteristics;
import org.fog.entities.Sensor;
import org.fog.entities.Tuple;
import org.fog.placement.Controller;
import org.fog.placement.ControllerEdgeward;
import org.fog.placement.LModulePlacementEdgewards;
import org.fog.placement.LatencyModulePlacementNear;
import org.fog.placement.ModuleMapping;
import org.fog.placement.ModulePlacementDifferentiated;
import org.fog.placement.ModulePlacementEdgewards;
import org.fog.placement.ModulePlacementMapping;
import org.fog.placement.ModulePlacementModified;
import org.fog.placement.ModulePlacementOnlyCloud;
import org.fog.policy.AppModuleAllocationPolicy;
import org.fog.scheduler.StreamOperatorScheduler;
import org.fog.utils.Config;
import org.fog.utils.FogLinearPowerModel;
import org.fog.utils.FogUtils;
import org.fog.utils.TimeKeeper;
import org.fog.utils.distribution.DeterministicDistribution;

/**
 * Simulation setup for  ECG
 * @author Ragaa Shehab
 *
 */ //updateTimingsOnReceipt - checkCloudletCompletion --tupleEndedExecutionUser
public class ECG {
	static List<FogDevice> fogDevices = new ArrayList<FogDevice>();
	static List<Sensor> sensors = new ArrayList<Sensor>();
	static List<Actuator> actuators = new ArrayList<Actuator>();
	static Map<Integer,FogDevice> deviceById = new HashMap<Integer,FogDevice>();	
	static List<Integer> idOfEndDevices = new ArrayList<Integer>();
	static Map<Integer, Double> deadlineInfo = new	HashMap<Integer, Double>();  // mobile id has priority
	static Map<Integer, Double> additionalMipsInfo = new HashMap<Integer, Double>(); // mobile id need tuple mips
	static Map<Integer, Map<String, Double>> deadlineInfomodule = new HashMap<Integer, Map<String,Double>>();  // mobile id has modulename with module priority
	static Map<Integer,List<Map<String, Double>>> deadlineInfomodule1 = new HashMap<Integer, List<Map<String,Double>>>();  // mobile id has modulename with module priority

	static boolean CLOUD = false;
	static int numOfDepts = 1;
	static int numOfMobilesPerDept =5;
	static double ECG_TRANSMISSION_TIME = 50.0 ; // 50.0;   //100, 50, 25 ms   100 //10s= 10000
	static public int mymips= 2000;     
	//static String placement = "Latency Module Placement"; 
	static String placement = "Latency Differentiated Module Placement"; 
	//static String placement = "Module Placement Edgeward";
	//static String placement = "Module Placement Edgeward Differentiated";
	//static String placement = "Latency Modified Module Placement";
	static double MobileCPUload= 0.1;
	
	public static void main(String[] args) {
		Log.print("Starting ECG transmission");	Log.print("             ECG transmission time ms: "); Log.print(ECG_TRANSMISSION_TIME);
		Log.print("     Depts/Mobiles =  "); Log.print (numOfDepts);Log.print("/"); Log.printLine (numOfMobilesPerDept);
		System.out.println("analytics VM mips  2000, Fog device mips: mobile 1000, dept  2800, proxy 16800" ); 

		
		try {
			Log.disable(); 	
			//Config.MAX_SIMULATION_TIME= 100000;
			int num_user = 1; // number of cloud users
			Calendar calendar = Calendar.getInstance();
			boolean trace_flag = false; // mean trace events
			CloudSim.init(num_user, calendar, trace_flag);						
			String appId = "ECG"; 
			FogBroker broker = new FogBroker("broker");			
			createFogDevices(broker.getId(), appId);
			
			Map<String, Double> moduledeadline= new HashMap<String, Double>();
			Map<String, Double> moduledeadline1;
			List<Map<String, Double>> moduledeadline1List;

			for(Integer id : idOfEndDevices){
				Double x= getvalue(5.00, 40.00);
				Double t1= 10.00; Double t2= 5.00; //Double t3= 5.00;
				deadlineInfo.put(id, x);
				
				if (placement.equals("Latency Differentiated Module Placement")||placement.equals("Module Placement Edgeward Differentiated")) {
						if((5.00 < x)&& (x < 10.00)) x=5.00;
						if(10.00 < x)&& ( < 15.00) x=10.00;
						if(15.00 < x < 20.00) x=20.00;
						if(20.00 < x < 30.00) x=30.00;
						if(30.00 < x < 40.00) x=40.00;
					
							
						
					additionalMipsInfo.put(id, x*100); //1000
					moduledeadline1=  new HashMap<String,Double>();
					moduledeadline1List= new ArrayList<Map<String, Double>>();
					moduledeadline1.put("Client", x*100);
					moduledeadline1.put("Filtering", x*100);
					moduledeadline1.put("Monitoring", x*100);
					moduledeadline1.put("Caregiver", x*100);
					moduledeadline1.put("Cloud_Analytics", x*100);
					moduledeadline1List.add(moduledeadline1);
					deadlineInfomodule1.put(id, moduledeadline1List);
				}
				else {
					additionalMipsInfo.put(id, (double)mymips);
					moduledeadline1=  new HashMap<String,Double>();
					moduledeadline1List= new ArrayList<Map<String, Double>>();
					moduledeadline1.put("Client", (double)mymips);
					moduledeadline1.put("Filtering", (double)mymips);
					moduledeadline1.put("Monitoring", (double)mymips);
					moduledeadline1.put("Caregiver", (double)mymips);
					moduledeadline1.put("Cloud_Analytics", (double)mymips);
					moduledeadline1List.add(moduledeadline1);
					deadlineInfomodule1.put(id, moduledeadline1List);
				}
				moduledeadline.put("Filtering", (x+t1));
				deadlineInfomodule.put(id,moduledeadline);
				moduledeadline.put("Monitoring", (x+ t2));
				deadlineInfomodule.put(id,moduledeadline);
			}	
			
			deadlineInfo=deadlineInfo.entrySet()
		             .stream().sorted(Map.Entry.comparingByValue())
		             .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -> e1, LinkedHashMap::new));			
				
			Application application = createApplication(appId, broker.getId());
			application.setUserId(broker.getId());
			application.setdeviceById(deviceById);
			application.setidOfEndDevices(idOfEndDevices);
			application.setDeadlineInfo(deadlineInfo);
			application.setDeadlineInfomodule(deadlineInfomodule);
			application.setDeadlineInfomodule1(deadlineInfomodule1);
		    application.setAdditionalMipsInfo(additionalMipsInfo);
		    application.setplacement(placement);
		    application.setMobileCPUload(MobileCPUload);
		    
		    System.out.println(String.format("%-25s%s" ,"User Priority ASC ", application.getDeadlineInfo()));
			System.out.println(String.format("%-25s%s" ,"Module Tuble MIPS ",application.getAdditionalMipsInfo()));
		   /// System.out.println(String.format("%-25s%s" ,"Module Priority ",application.getDeadlineInfomodule()));
		    System.out.println(String.format("%-25s%s" ,"Module Priority1 ",application.getDeadlineInfomodule1()));

		    System.out.println("mobile CPU load "+ application.getMobileCPUload());
		    		
			Controller controller = null;
			ModuleMapping moduleMapping = ModuleMapping.createModuleMapping(); // initializing a module mapping			
			moduleMapping.addModuleToDevice("Cloud_Analytics", "cloud");
			for(FogDevice device : fogDevices){
				if(device.getName().startsWith("m"))
					moduleMapping.addModuleToDevice("Client", device.getName());
				}
			if(CLOUD){			 
				moduleMapping.addModuleToDevice("Caregiver", "cloud");
				moduleMapping.addModuleToDevice("Monitoring", "cloud");
				moduleMapping.addModuleToDevice("Filtering", "cloud");
				System.out.println("cloud only module placement, tuple mips= "+ mymips);
				controller = new ControllerEdgeward("master-controller", fogDevices, sensors, actuators);
				controller.submitApplication(application, 0, new ModulePlacementMapping(fogDevices, application,moduleMapping));
				}
			else {
				moduleMapping.addModuleToDevice("Caregiver", "proxy-server");
				switch (placement) { 
				case "Latency Module Placement":{			
					System.out.println("Per User Basic module placement");//", Tuple mips= "+ mymips
					controller = new Controller("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LatencyModulePlacementNear(fogDevices, sensors, actuators, application, moduleMapping));
					break;}	
				case "Latency Modified Module Placement":{
					System.out.println("Per User Modified module placement");
					controller = new Controller("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new ModulePlacementModified(fogDevices, sensors, actuators, application, moduleMapping));
					break;}
				case "Latency Differentiated Module Placement":{
					System.out.println("Per User Differentiated module placement, variable Module/Tuple mips ");
					controller = new Controller("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LatencyModulePlacementNear(fogDevices, sensors, actuators, application, moduleMapping));
					break;} //ModulePlacementDifferentiated
				case "Module Placement Edgeward":{
					System.out.println("Per module placement");
					controller = new ControllerEdgeward("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LModulePlacementEdgewards(fogDevices, sensors, actuators, application, moduleMapping));
					break;}
				case "Module Placement Edgeward Differentiated":{
					System.out.println("Per module Differentiated placement");
					controller = new ControllerEdgeward("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LModulePlacementEdgewards(fogDevices, sensors, actuators, application, moduleMapping));
					break;}
				}
				}
					
			TimeKeeper.getInstance().setSimulationStartTime(Calendar.getInstance().getTimeInMillis());
			CloudSim.startSimulation();
			CloudSim.stopSimulation();
			Log.printLine("ECG finished!");
		} catch (Exception e) {
			e.printStackTrace();
			Log.printLine("Unwanted errors happen");
		}
	}	
/****************************************************************************************
	 * Creates the fog devices in the physical topology of the simulation.
	 * @param userId
	 * @param appId
	 */
	private static void createFogDevices(int userId, String appId) {  // 44800
		FogDevice cloud = createFogDevice("cloud", 44800, 40000, 100, 10000, 0, 0.01, 16*103, 16*83.25); // creates the fog device Cloud at the apex of the hierarchy with level=0
		cloud.setParentId(-1);		 
		FogDevice proxy = createFogDevice("proxy-server", 16800 , 4000, 10000, 10000, 1, 0.0, 107.339, 83.4333); // 2800
		proxy.setParentId(cloud.getId()); // setting Cloud as parent of the Proxy Server
		proxy.setUplinkLatency(100); // latency of connection from Proxy Server to the Cloud is 100 ms		
		fogDevices.add(cloud);
		deviceById.put(cloud.getId(), cloud);
		fogDevices.add(proxy);
		deviceById.put(proxy.getId(), proxy);		
		for(int i=0;i<numOfDepts;i++){
			addGw(i+"", userId, appId, proxy.getId()); // adding a fog device for every Gateway in physical topology. The parent of each gateway is the Proxy Server
		}	
	}

	private static FogDevice addGw(String id, int userId, String appId, int parentId){
		FogDevice dept = createFogDevice("d-"+id, 2800, 4000, 10000, 10000, 2, 0.0, 107.339, 83.4333); //2800
		fogDevices.add(dept);
		deviceById.put(dept.getId(), dept);
		dept.setParentId(parentId);
		dept.setUplinkLatency(4); // latency of connection between gateways and proxy server is 4 ms
		for(int i=0;i<numOfMobilesPerDept;i++){
			String mobileId = id+"-"+i;
			FogDevice mobile = addMobile(mobileId, userId, appId, dept.getId()); // adding mobiles to the physical topology. Smartphones have been modeled as fog devices as well.
			mobile.setUplinkLatency(2); // latency of connection between the smartphone and proxy server is 4 ms
			fogDevices.add(mobile);
			deviceById.put(mobile.getId(), mobile);
		}
		return dept;
	}
	
	private static FogDevice addMobile(String id, int userId, String appId, int parentId){
		FogDevice mobile = createFogDevice("m-"+id, 1000, 1000, 10000, 270, 3, 0, 87.53, 82.44); //1000   
		mobile.setParentId(parentId);
		idOfEndDevices.add(mobile.getId());
		Sensor ecgsensor = new Sensor("s-"+id, "ECG", userId, appId, new DeterministicDistribution(ECG_TRANSMISSION_TIME)); // inter-transmission time of EEG sensor follows a deterministic distribution
		sensors.add(ecgsensor);
		Actuator display = new Actuator("a-"+id, userId, appId, "DISPLAY");
		actuators.add(display);
		ecgsensor.setGatewayDeviceId(mobile.getId());
		ecgsensor.setLatency(6.0);  // latency of connection between EEG sensors and the parent Smartphone is 6 ms
		display.setGatewayDeviceId(mobile.getId());
		display.setLatency(1.0);  // latency of connection between Display actuator and the parent Smartphone is 1 ms
		return mobile;
	}
	
/*****************************************************************************************
	 * Creates a vanilla fog device
	 * @param nodeName name of the device to be used in simulation
	 * @param mips MIPS
	 * @param ram RAM
	 * @param upBw uplink bandwidth
	 * @param downBw downlink bandwidth
	 * @param level hierarchy level of the device
	 * @param ratePerMips cost rate per MIPS used
	 * @param busyPower
	 * @param idlePower
	 * @return
	 */
	private static FogDevice createFogDevice(String nodeName, long mips,
			int ram, long upBw, long downBw, int level, double ratePerMips, double busyPower, double idlePower) {
		
		List<Pe> peList = new ArrayList<Pe>();
		// 3. Create PEs and add these into a list.
		peList.add(new Pe(0, new PeProvisionerOverbooking(mips))); // need to store Pe id and MIPS Rating
		
		int hostId = FogUtils.generateEntityId();
		long storage = 1000000; // host storage
		int bw = 10000;
		PowerHost host = new PowerHost(
				hostId,
				new RamProvisionerSimple(ram),
				new BwProvisionerOverbooking(bw),
				storage,
				peList,
				new StreamOperatorScheduler(peList),
				new FogLinearPowerModel(busyPower, idlePower)
			);

		List<Host> hostList = new ArrayList<Host>();
		hostList.add(host);

		String arch = "x86"; // system architecture
		String os = "Linux"; // operating system
		String vmm = "Xen";
		double time_zone = 10.0; // time zone this resource located
		double cost = 3.0; // the cost of using processing in this resource
		double costPerMem = 0.05; // the cost of using memory in this resource
		double costPerStorage = 0.001; // the cost of using storage in this	// resource
		double costPerBw = 0.0; // the cost of using bw in this resource
		LinkedList<Storage> storageList = new LinkedList<Storage>(); // we are not adding SAN devices by now

		FogDeviceCharacteristics characteristics = new FogDeviceCharacteristics(
				arch, os, vmm, host, time_zone, cost, costPerMem,
				costPerStorage, costPerBw);

		FogDevice fogdevice = null;
		try {
			fogdevice = new FogDevice(nodeName, characteristics, 
					new AppModuleAllocationPolicy(hostList), storageList, 10 , upBw, downBw, 0, ratePerMips); //10 : schedulingInterval  0 uplink  latency		
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		fogdevice.setLevel(level);
		return fogdevice;
	}

/******************************************************************************************
	 * Function to create the EEG Tractor Beam game application in the DDF model. 
	 * @param appId unique identifier of the application
	 * @param userId identifier of the user of the application
	 * @return
	 */
	@SuppressWarnings({"serial" })
	private static Application createApplication(String appId, int userId){
		
		Application application = Application.createApplication(appId, userId); // creates an empty application model (empty directed graph)
		
		// Adding modules (vertices) to the application model (directed graph)
		application.addAppModule("Client", 10, 2000, 1000,100,5); //250Name,int ram, int mips, long size, long bw, int modprty) size is the image size (MB)
		application.addAppModule("Filtering",10, 2000, 500, 100,4); //150
		application.addAppModule("Monitoring",10, 2000, 500,100,3); //150 
		application.addAppModule("Caregiver", 10, 2000,1000,100,2); // 150
		application.addAppModule("Cloud_Analytics",10, 3000,1000,250,1); //500("Cloud_Analytics",10, 500,1000,500,1); //
		
		// Connecting the application modules (vertices) in the application model (directed graph) with edges
		//source, destination, double tupleCpuLength, double tupleNwLength, String tupleType, int direction, int edgeType){
		application.addAppEdge("ECG", "Client", 2000, 500, "ECG", Tuple.UP, AppEdge.SENSOR);
		application.addAppEdge("Client", "Filtering", 2000, 500, "SENSOR_DATA", Tuple.UP, AppEdge.MODULE); //
		application.addAppEdge("Filtering", "Monitoring", mymips, 500, "FILTERED_DATA", Tuple.UP, AppEdge.MODULE); //
		application.addAppEdge("Monitoring", "Caregiver", mymips, 500, "ECG_REPORT", Tuple.UP, AppEdge.MODULE);  //
		application.addAppEdge("Caregiver", "Cloud_Analytics", mymips, 500, "DATA_OFFLOAD", Tuple.UP, AppEdge.MODULE); //		
		application.addAppEdge("Caregiver", "Client", mymips, 500, "State_Action", Tuple.DOWN, AppEdge.MODULE); //  
		application.addAppEdge("Client", "DISPLAY",2000, 500, "P_State_Action", Tuple.DOWN, AppEdge.ACTUATOR);  //
		application.addAppEdge("Cloud_Analytics", "Caregiver", 2000, 1000, "Advanced_Analytics", Tuple.DOWN, AppEdge.MODULE);  
		
 	    //Defining the input-output relationships (represented by selectivity) of the application modules. 
		application.addTupleMapping("Client", "ECG", "SENSOR_DATA", new FractionalSelectivity(1.0)); // 
		application.addTupleMapping("Client", "State_Action", "P_State_Action", new FractionalSelectivity(1.0)); //  
		application.addTupleMapping("Filtering", "SENSOR_DATA", "FILTERED_DATA", new FractionalSelectivity(1.0)); // 
		application.addTupleMapping("Monitoring", "FILTERED_DATA", "ECG_REPORT", new FractionalSelectivity(1.0)); //
		application.addTupleMapping("Caregiver", "ECG_REPORT", "DATA_OFFLOAD", new FractionalSelectivity(1.0)); //
		application.addTupleMapping("Caregiver", "ECG_REPORT", "State_Action", new FractionalSelectivity(1.0)); //
		application.addTupleMapping("Cloud_Analytics", "DATA_OFFLOAD", "Advanced_Analytics", new FractionalSelectivity(0.01)); //
	
		
		 // Defining application loops to monitor the latency of.
		//final AppLoop ONLY_CLOUD = new AppLoop(new ArrayList<String>(){{add("ECG");add("Client");add("Filtering");add("Monitoring");add("Caregiver");add("Client");add("DISPLAY");}}); //add("Cloud_Analytics");
        //List<AppLoop> loops = new ArrayList<AppLoop>(){{ add(ONLY_CLOUD);}};
		//final AppLoop ECG_REPORTING = new AppLoop(new ArrayList<String>(){{add("ECG");add("Client");add("Filtering");add("Monitoring");add("Caregiver");add("Client");add("DISPLAY");}});
        //List<AppLoop> loops = new ArrayList<AppLoop>(){{ add(ECG_REPORTING);}};
		final AppLoop ECG_ANALYTICS = new AppLoop(new ArrayList<String>(){{add("ECG");add("Client");add("Filtering");add("Monitoring");add("Caregiver");}});
        List<AppLoop> loops = new ArrayList<AppLoop>(){{add( ECG_ANALYTICS);}}; 
 		application.setLoops(loops);
		return application;
		}
///random number generators//////////////////////////////////////////////////////////
	private static double getvalue(double d, double e)  { 
	    Random r = new Random(); 
	    double randomValue = d + (e - d) *r.nextDouble(); 
	   // randomValue = r.nextDouble();
	    return randomValue; 
	  } 
	private static Integer getvalue(int min, int max) { 
	    Random r = new Random(); 
	    Integer randomValue = min + r.nextInt()%(max - min); 
	   // randomValue = r.nextInt(max);
	    return randomValue; 
	  }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//scheduled cloudlet processing =30,100,200,300,500 mips for filtering monitoring caregiver  
//scheduled cloudlet processing = 1000  for client and cloudanalytics modules
// mobile id, need Modulename executed with max delay (3:5)
//static Pair<String, Double> moduledeadline = new Pair <String, Double>(null,null);  // mobile id need deadline double
//static List<Pair<String, Double>> moduledeadline = new ArrayList<Pair <String, Double>>();


//if(placement.equals("Latency Differentiated Module Placement")) {		
//System.out.println(String.format("%-30s%s" ,"Per_User Differentiated Module Placement, " ," variable mips between 50 mips, "+  mymips+ " for all modules except cloud plus 1000 mips"));
//}		
//else if(placement.equals("Module Placement Edgeward")) {
//System.out.println(String.format("%-30s%20s%s%30s%10s%s" ,"Per_Module Edgeward Placement","const mips= " , mymips));
//System.out.println("Per_Module Placement,  Tuple's mips= " + mymips);
//}
///else 
//placement=="Latency Module Placement" 
//System.out.println(String.format("%-30s%20s%s%30s%10s%s" ,"Per_User Basic Module Placement","const mips= " , mymips));
//System.out.println("Per_User Basic Module Placement,  const mips= " + mymips);		

//System.out.println("Application Module mips: Client = Filtering = Monitoring = Caregiver = 300 mips , Cloud_Analytics = 600 mips");
//System.out.println("Migration Condition: Mobile Utilization >= 0.3, Proxy/Dept Utilization >= 0.9" );  //, RESOURCE_MANAGE_INTERVAL = 100 ");
//System.out.println("Enhanced Migration Conditions , RESOURCE_MANAGE_INTERVAL = 10 ");
//System.out.println("fog device scheduling interval = 10,  Application module scheduling interval = 300  ");	

//moduledeadline.put("Client", (x+ 15.0000000000000000));
//deadlineInfomodule.put(id,moduledeadline);
//moduledeadline.put("Caregiver", x);
//deadlineInfomodule.put(id,moduledeadline);				
//System.out.println("deadlineInfomodule  "+ deadlineInfomodule);
//deadlineInfomodule.put(id,moduledeadlinelist);				
//moduledeadline.clear();

/*
for(Integer id : idOfEndDevices){
	if (placement.equals("Latency Differentiated Module Placement")) {
		Integer x= getvalue(50, 500);//mymips);
		x= Math.abs(x);
		additionalMipsInfo.put(id, (double)x);  //getvalue(0,mymips)
		}
	else
		additionalMipsInfo.put(id, (double)mymips);
}
*/
/*else if(device.getName().startsWith("d")){
moduleMapping.addModuleToDevice("Filtering", device.getName());
moduleMapping.addModuleToDevice("Monitoring", device.getName());				
} */
//Controller controller = new Controller("master-controller", fogDevices, sensors, actuators);
//controller.submitApplication(application, 0, new ModulePlacementOnlyCloud(fogDevices, sensors, actuators, application));
//controller.submitApplication(application, 0, new LatencyModulePlacement(fogDevices, sensors, actuators, application, moduleMapping));
//controller.submitApplication(application, 0, new LatencyModifiedModulePlacementNew(fogDevices, sensors, actuators, application, moduleMapping));
 //LModulePlacementEdgewards  // LatencyModulePlacementNear

//TRY FogDevice cloud = createFogDevice("cloud", 448000000, 40000000, 100000, 10000000, 0, 0.01, 16*103, 16*83.25); // creates the fog device Cloud at the apex of the hierarchy with level=0
//FogDevice cloud = createFogDevice("cloud", 4480000, 4000000, 100, 10000, 0, 0.01, 16*103, 16*83.25); // creates the fog device Cloud at the apex of the hierarchy with level=0
//FogDevice proxy = createFogDevice("proxy-server", 2800, 4000, 10000, 10000, 1, 0.0, 107.339, 83.4333);

//peList.add(new Pe(0, new PeProvisionerSimple(mips))); // need to store Pe id and MIPS Rating


/*
application.addAppModule("Client", 10, 300, 1000,100,5); // adding module Client to the application model
application.addAppModule("Filtering",10, 300, 1000, 100,4); //
application.addAppModule("Monitoring",10, 300, 1000,100,3); // 
application.addAppModule("Caregiver", 10, 300,1000,100,2); // 
application.addAppModule("Cloud_Analytics",10, 600,1000,250,1); //("Cloud_Analytics",10, 500,1000,500,1); //
*/
/*application.addAppEdge("ECG", "Client", 3000, 1000, "ECG", Tuple.UP, AppEdge.SENSOR);
application.addAppEdge("Client", "Filtering", 3000, 500, "SENSOR_DATA", Tuple.UP, AppEdge.MODULE); //
application.addAppEdge("Filtering", "Monitoring", (30+ mymips), 500, "FILTERED_DATA", Tuple.UP, AppEdge.MODULE); // 
application.addAppEdge("Monitoring", "Cloud_Analytics", 1000, 500, "DATA_OFFLOAD", Tuple.UP, AppEdge.MODULE); // 
application.addAppEdge("Monitoring", "Caregiver", (60+ mymips) , 500, "ECG_REPORT", Tuple.UP, AppEdge.MODULE);  // 
application.addAppEdge("Cloud_Analytics", "Caregiver", 3500, 1000, "Advanced_Analytics", Tuple.DOWN, AppEdge.MODULE);  // 
application.addAppEdge("Caregiver", "Client", 1000 , 500, "State_Action", Tuple.DOWN, AppEdge.MODULE); // 
application.addAppEdge("Client", "DISPLAY",1000, 500, "P_State_Action", Tuple.DOWN, AppEdge.ACTUATOR);  //
 */
//application.addAppEdge("Caregiver", "Cloud_Analytics", 3000, 1000, "DECISION", Tuple.UP, AppEdge.MODULE); //
// application.addTupleMapping("Cloud_Analytics", "DECISION", "Advanced_Analytics", new FractionalSelectivity(0.001)); //
//final AppLoop HBR_Analytics = new AppLoop(new ArrayList<String>(){{add("HBR"); add("Client"); add("Monitoring"); add("Cloud_Analytics"); add("Caregiver"); add("Client"); add("DISPLAY");}});

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10061, count -3525, length 26091
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-10-15 12:36:18.321
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.StringIndexOutOfBoundsException: offset 10061, count -3525, length 26091
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:324)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10061, count -3525, length 26091
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	... 16 more
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10061, count -3525, length 26091
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2020-10-15 12:36:18.322
!MESSAGE offset 10061, count -3525, length 26091
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10061, count -3525, length 26091
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2020-10-15 12:36:18.322
!MESSAGE offset 10061, count -3525, length 26091
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10061, count -3525, length 26091
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-10-15 12:36:18.323
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.StringIndexOutOfBoundsException: offset 10061, count -3525, length 26091
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:324)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10061, count -3525, length 26091
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	... 16 more
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10061, count -3525, length 26091
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2020-10-15 12:36:18.323
!MESSAGE offset 10061, count -3525, length 26091
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10061, count -3525, length 26091
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-10-15 12:36:18.332
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10061, count -3525, length 26091
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-10-15 12:36:18.333
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10061, count -3525, length 26091
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-10-15 12:36:19.838
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
package org.fog.test.perfeval;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.stream.Collectors;
import org.apache.commons.math3.util.Pair;
import org.cloudbus.cloudsim.Host;
import org.cloudbus.cloudsim.Log;
import org.cloudbus.cloudsim.Pe;
import org.cloudbus.cloudsim.Storage;
import org.cloudbus.cloudsim.core.CloudSim;
import org.cloudbus.cloudsim.power.PowerHost;
import org.cloudbus.cloudsim.provisioners.PeProvisionerSimple;
import org.cloudbus.cloudsim.provisioners.RamProvisionerSimple;
import org.cloudbus.cloudsim.sdn.overbooking.BwProvisionerOverbooking;
import org.cloudbus.cloudsim.sdn.overbooking.PeProvisionerOverbooking;
import org.fog.application.AppEdge;
import org.fog.application.AppLoop;
import org.fog.application.Application;
import org.fog.application.selectivity.FractionalSelectivity;
import org.fog.entities.Actuator;
import org.fog.entities.FogBroker;
import org.fog.entities.FogDevice;
import org.fog.entities.FogDeviceCharacteristics;
import org.fog.entities.Sensor;
import org.fog.entities.Tuple;
import org.fog.placement.Controller;
import org.fog.placement.ControllerEdgeward;
import org.fog.placement.LModulePlacementEdgewards;
import org.fog.placement.LatencyModulePlacementNear;
import org.fog.placement.ModuleMapping;
import org.fog.placement.ModulePlacementDifferentiated;
import org.fog.placement.ModulePlacementEdgewards;
import org.fog.placement.ModulePlacementMapping;
import org.fog.placement.ModulePlacementModified;
import org.fog.placement.ModulePlacementOnlyCloud;
import org.fog.policy.AppModuleAllocationPolicy;
import org.fog.scheduler.StreamOperatorScheduler;
import org.fog.utils.Config;
import org.fog.utils.FogLinearPowerModel;
import org.fog.utils.FogUtils;
import org.fog.utils.TimeKeeper;
import org.fog.utils.distribution.DeterministicDistribution;

/**
 * Simulation setup for  ECG
 * @author Ragaa Shehab
 *
 */ //updateTimingsOnReceipt - checkCloudletCompletion --tupleEndedExecutionUser
public class ECG {
	static List<FogDevice> fogDevices = new ArrayList<FogDevice>();
	static List<Sensor> sensors = new ArrayList<Sensor>();
	static List<Actuator> actuators = new ArrayList<Actuator>();
	static Map<Integer,FogDevice> deviceById = new HashMap<Integer,FogDevice>();	
	static List<Integer> idOfEndDevices = new ArrayList<Integer>();
	static Map<Integer, Double> deadlineInfo = new	HashMap<Integer, Double>();  // mobile id has priority
	static Map<Integer, Double> additionalMipsInfo = new HashMap<Integer, Double>(); // mobile id need tuple mips
	static Map<Integer, Map<String, Double>> deadlineInfomodule = new HashMap<Integer, Map<String,Double>>();  // mobile id has modulename with module priority
	static Map<Integer,List<Map<String, Double>>> deadlineInfomodule1 = new HashMap<Integer, List<Map<String,Double>>>();  // mobile id has modulename with module priority

	static boolean CLOUD = false;
	static int numOfDepts = 1;
	static int numOfMobilesPerDept =5;
	static double ECG_TRANSMISSION_TIME = 50.0 ; // 50.0;   //100, 50, 25 ms   100 //10s= 10000
	static public int mymips= 2000;     
	//static String placement = "Latency Module Placement"; 
	static String placement = "Latency Differentiated Module Placement"; 
	//static String placement = "Module Placement Edgeward";
	//static String placement = "Module Placement Edgeward Differentiated";
	//static String placement = "Latency Modified Module Placement";
	static double MobileCPUload= 0.1;
	
	public static void main(String[] args) {
		Log.print("Starting ECG transmission");	Log.print("             ECG transmission time ms: "); Log.print(ECG_TRANSMISSION_TIME);
		Log.print("     Depts/Mobiles =  "); Log.print (numOfDepts);Log.print("/"); Log.printLine (numOfMobilesPerDept);
		System.out.println("analytics VM mips  2000, Fog device mips: mobile 1000, dept  2800, proxy 16800" ); 

		
		try {
			Log.disable(); 	
			//Config.MAX_SIMULATION_TIME= 100000;
			int num_user = 1; // number of cloud users
			Calendar calendar = Calendar.getInstance();
			boolean trace_flag = false; // mean trace events
			CloudSim.init(num_user, calendar, trace_flag);						
			String appId = "ECG"; 
			FogBroker broker = new FogBroker("broker");			
			createFogDevices(broker.getId(), appId);
			
			Map<String, Double> moduledeadline= new HashMap<String, Double>();
			Map<String, Double> moduledeadline1;
			List<Map<String, Double>> moduledeadline1List;

			for(Integer id : idOfEndDevices){
				Double x= getvalue(5.00, 40.00);
				Double t1= 10.00; Double t2= 5.00; //Double t3= 5.00;
				deadlineInfo.put(id, x);
				
				if (placement.equals("Latency Differentiated Module Placement")||placement.equals("Module Placement Edgeward Differentiated")) {
						if((5.00 < x)&& (x < 10.00)) x=5.00;
						if(10.00 < x)&& (x < 15.00) x=10.00;
						if(15.00 < x < 20.00) x=20.00;
						if(20.00 < x < 30.00) x=30.00;
						if(30.00 < x < 40.00) x=40.00;
					
							
						
					additionalMipsInfo.put(id, x*100); //1000
					moduledeadline1=  new HashMap<String,Double>();
					moduledeadline1List= new ArrayList<Map<String, Double>>();
					moduledeadline1.put("Client", x*100);
					moduledeadline1.put("Filtering", x*100);
					moduledeadline1.put("Monitoring", x*100);
					moduledeadline1.put("Caregiver", x*100);
					moduledeadline1.put("Cloud_Analytics", x*100);
					moduledeadline1List.add(moduledeadline1);
					deadlineInfomodule1.put(id, moduledeadline1List);
				}
				else {
					additionalMipsInfo.put(id, (double)mymips);
					moduledeadline1=  new HashMap<String,Double>();
					moduledeadline1List= new ArrayList<Map<String, Double>>();
					moduledeadline1.put("Client", (double)mymips);
					moduledeadline1.put("Filtering", (double)mymips);
					moduledeadline1.put("Monitoring", (double)mymips);
					moduledeadline1.put("Caregiver", (double)mymips);
					moduledeadline1.put("Cloud_Analytics", (double)mymips);
					moduledeadline1List.add(moduledeadline1);
					deadlineInfomodule1.put(id, moduledeadline1List);
				}
				moduledeadline.put("Filtering", (x+t1));
				deadlineInfomodule.put(id,moduledeadline);
				moduledeadline.put("Monitoring", (x+ t2));
				deadlineInfomodule.put(id,moduledeadline);
			}	
			
			deadlineInfo=deadlineInfo.entrySet()
		             .stream().sorted(Map.Entry.comparingByValue())
		             .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -> e1, LinkedHashMap::new));			
				
			Application application = createApplication(appId, broker.getId());
			application.setUserId(broker.getId());
			application.setdeviceById(deviceById);
			application.setidOfEndDevices(idOfEndDevices);
			application.setDeadlineInfo(deadlineInfo);
			application.setDeadlineInfomodule(deadlineInfomodule);
			application.setDeadlineInfomodule1(deadlineInfomodule1);
		    application.setAdditionalMipsInfo(additionalMipsInfo);
		    application.setplacement(placement);
		    application.setMobileCPUload(MobileCPUload);
		    
		    System.out.println(String.format("%-25s%s" ,"User Priority ASC ", application.getDeadlineInfo()));
			System.out.println(String.format("%-25s%s" ,"Module Tuble MIPS ",application.getAdditionalMipsInfo()));
		   /// System.out.println(String.format("%-25s%s" ,"Module Priority ",application.getDeadlineInfomodule()));
		    System.out.println(String.format("%-25s%s" ,"Module Priority1 ",application.getDeadlineInfomodule1()));

		    System.out.println("mobile CPU load "+ application.getMobileCPUload());
		    		
			Controller controller = null;
			ModuleMapping moduleMapping = ModuleMapping.createModuleMapping(); // initializing a module mapping			
			moduleMapping.addModuleToDevice("Cloud_Analytics", "cloud");
			for(FogDevice device : fogDevices){
				if(device.getName().startsWith("m"))
					moduleMapping.addModuleToDevice("Client", device.getName());
				}
			if(CLOUD){			 
				moduleMapping.addModuleToDevice("Caregiver", "cloud");
				moduleMapping.addModuleToDevice("Monitoring", "cloud");
				moduleMapping.addModuleToDevice("Filtering", "cloud");
				System.out.println("cloud only module placement, tuple mips= "+ mymips);
				controller = new ControllerEdgeward("master-controller", fogDevices, sensors, actuators);
				controller.submitApplication(application, 0, new ModulePlacementMapping(fogDevices, application,moduleMapping));
				}
			else {
				moduleMapping.addModuleToDevice("Caregiver", "proxy-server");
				switch (placement) { 
				case "Latency Module Placement":{			
					System.out.println("Per User Basic module placement");//", Tuple mips= "+ mymips
					controller = new Controller("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LatencyModulePlacementNear(fogDevices, sensors, actuators, application, moduleMapping));
					break;}	
				case "Latency Modified Module Placement":{
					System.out.println("Per User Modified module placement");
					controller = new Controller("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new ModulePlacementModified(fogDevices, sensors, actuators, application, moduleMapping));
					break;}
				case "Latency Differentiated Module Placement":{
					System.out.println("Per User Differentiated module placement, variable Module/Tuple mips ");
					controller = new Controller("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LatencyModulePlacementNear(fogDevices, sensors, actuators, application, moduleMapping));
					break;} //ModulePlacementDifferentiated
				case "Module Placement Edgeward":{
					System.out.println("Per module placement");
					controller = new ControllerEdgeward("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LModulePlacementEdgewards(fogDevices, sensors, actuators, application, moduleMapping));
					break;}
				case "Module Placement Edgeward Differentiated":{
					System.out.println("Per module Differentiated placement");
					controller = new ControllerEdgeward("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LModulePlacementEdgewards(fogDevices, sensors, actuators, application, moduleMapping));
					break;}
				}
				}
					
			TimeKeeper.getInstance().setSimulationStartTime(Calendar.getInstance().getTimeInMillis());
			CloudSim.startSimulation();
			CloudSim.stopSimulation();
			Log.printLine("ECG finished!");
		} catch (Exception e) {
			e.printStackTrace();
			Log.printLine("Unwanted errors happen");
		}
	}	
/****************************************************************************************
	 * Creates the fog devices in the physical topology of the simulation.
	 * @param userId
	 * @param appId
	 */
	private static void createFogDevices(int userId, String appId) {  // 44800
		FogDevice cloud = createFogDevice("cloud", 44800, 40000, 100, 10000, 0, 0.01, 16*103, 16*83.25); // creates the fog device Cloud at the apex of the hierarchy with level=0
		cloud.setParentId(-1);		 
		FogDevice proxy = createFogDevice("proxy-server", 16800 , 4000, 10000, 10000, 1, 0.0, 107.339, 83.4333); // 2800
		proxy.setParentId(cloud.getId()); // setting Cloud as parent of the Proxy Server
		proxy.setUplinkLatency(100); // latency of connection from Proxy Server to the Cloud is 100 ms		
		fogDevices.add(cloud);
		deviceById.put(cloud.getId(), cloud);
		fogDevices.add(proxy);
		deviceById.put(proxy.getId(), proxy);		
		for(int i=0;i<numOfDepts;i++){
			addGw(i+"", userId, appId, proxy.getId()); // adding a fog device for every Gateway in physical topology. The parent of each gateway is the Proxy Server
		}	
	}

	private static FogDevice addGw(String id, int userId, String appId, int parentId){
		FogDevice dept = createFogDevice("d-"+id, 2800, 4000, 10000, 10000, 2, 0.0, 107.339, 83.4333); //2800
		fogDevices.add(dept);
		deviceById.put(dept.getId(), dept);
		dept.setParentId(parentId);
		dept.setUplinkLatency(4); // latency of connection between gateways and proxy server is 4 ms
		for(int i=0;i<numOfMobilesPerDept;i++){
			String mobileId = id+"-"+i;
			FogDevice mobile = addMobile(mobileId, userId, appId, dept.getId()); // adding mobiles to the physical topology. Smartphones have been modeled as fog devices as well.
			mobile.setUplinkLatency(2); // latency of connection between the smartphone and proxy server is 4 ms
			fogDevices.add(mobile);
			deviceById.put(mobile.getId(), mobile);
		}
		return dept;
	}
	
	private static FogDevice addMobile(String id, int userId, String appId, int parentId){
		FogDevice mobile = createFogDevice("m-"+id, 1000, 1000, 10000, 270, 3, 0, 87.53, 82.44); //1000   
		mobile.setParentId(parentId);
		idOfEndDevices.add(mobile.getId());
		Sensor ecgsensor = new Sensor("s-"+id, "ECG", userId, appId, new DeterministicDistribution(ECG_TRANSMISSION_TIME)); // inter-transmission time of EEG sensor follows a deterministic distribution
		sensors.add(ecgsensor);
		Actuator display = new Actuator("a-"+id, userId, appId, "DISPLAY");
		actuators.add(display);
		ecgsensor.setGatewayDeviceId(mobile.getId());
		ecgsensor.setLatency(6.0);  // latency of connection between EEG sensors and the parent Smartphone is 6 ms
		display.setGatewayDeviceId(mobile.getId());
		display.setLatency(1.0);  // latency of connection between Display actuator and the parent Smartphone is 1 ms
		return mobile;
	}
	
/*****************************************************************************************
	 * Creates a vanilla fog device
	 * @param nodeName name of the device to be used in simulation
	 * @param mips MIPS
	 * @param ram RAM
	 * @param upBw uplink bandwidth
	 * @param downBw downlink bandwidth
	 * @param level hierarchy level of the device
	 * @param ratePerMips cost rate per MIPS used
	 * @param busyPower
	 * @param idlePower
	 * @return
	 */
	private static FogDevice createFogDevice(String nodeName, long mips,
			int ram, long upBw, long downBw, int level, double ratePerMips, double busyPower, double idlePower) {
		
		List<Pe> peList = new ArrayList<Pe>();
		// 3. Create PEs and add these into a list.
		peList.add(new Pe(0, new PeProvisionerOverbooking(mips))); // need to store Pe id and MIPS Rating
		
		int hostId = FogUtils.generateEntityId();
		long storage = 1000000; // host storage
		int bw = 10000;
		PowerHost host = new PowerHost(
				hostId,
				new RamProvisionerSimple(ram),
				new BwProvisionerOverbooking(bw),
				storage,
				peList,
				new StreamOperatorScheduler(peList),
				new FogLinearPowerModel(busyPower, idlePower)
			);

		List<Host> hostList = new ArrayList<Host>();
		hostList.add(host);

		String arch = "x86"; // system architecture
		String os = "Linux"; // operating system
		String vmm = "Xen";
		double time_zone = 10.0; // time zone this resource located
		double cost = 3.0; // the cost of using processing in this resource
		double costPerMem = 0.05; // the cost of using memory in this resource
		double costPerStorage = 0.001; // the cost of using storage in this	// resource
		double costPerBw = 0.0; // the cost of using bw in this resource
		LinkedList<Storage> storageList = new LinkedList<Storage>(); // we are not adding SAN devices by now

		FogDeviceCharacteristics characteristics = new FogDeviceCharacteristics(
				arch, os, vmm, host, time_zone, cost, costPerMem,
				costPerStorage, costPerBw);

		FogDevice fogdevice = null;
		try {
			fogdevice = new FogDevice(nodeName, characteristics, 
					new AppModuleAllocationPolicy(hostList), storageList, 10 , upBw, downBw, 0, ratePerMips); //10 : schedulingInterval  0 uplink  latency		
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		fogdevice.setLevel(level);
		return fogdevice;
	}

/******************************************************************************************
	 * Function to create the EEG Tractor Beam game application in the DDF model. 
	 * @param appId unique identifier of the application
	 * @param userId identifier of the user of the application
	 * @return
	 */
	@SuppressWarnings({"serial" })
	private static Application createApplication(String appId, int userId){
		
		Application application = Application.createApplication(appId, userId); // creates an empty application model (empty directed graph)
		
		// Adding modules (vertices) to the application model (directed graph)
		application.addAppModule("Client", 10, 2000, 1000,100,5); //250Name,int ram, int mips, long size, long bw, int modprty) size is the image size (MB)
		application.addAppModule("Filtering",10, 2000, 500, 100,4); //150
		application.addAppModule("Monitoring",10, 2000, 500,100,3); //150 
		application.addAppModule("Caregiver", 10, 2000,1000,100,2); // 150
		application.addAppModule("Cloud_Analytics",10, 3000,1000,250,1); //500("Cloud_Analytics",10, 500,1000,500,1); //
		
		// Connecting the application modules (vertices) in the application model (directed graph) with edges
		//source, destination, double tupleCpuLength, double tupleNwLength, String tupleType, int direction, int edgeType){
		application.addAppEdge("ECG", "Client", 2000, 500, "ECG", Tuple.UP, AppEdge.SENSOR);
		application.addAppEdge("Client", "Filtering", 2000, 500, "SENSOR_DATA", Tuple.UP, AppEdge.MODULE); //
		application.addAppEdge("Filtering", "Monitoring", mymips, 500, "FILTERED_DATA", Tuple.UP, AppEdge.MODULE); //
		application.addAppEdge("Monitoring", "Caregiver", mymips, 500, "ECG_REPORT", Tuple.UP, AppEdge.MODULE);  //
		application.addAppEdge("Caregiver", "Cloud_Analytics", mymips, 500, "DATA_OFFLOAD", Tuple.UP, AppEdge.MODULE); //		
		application.addAppEdge("Caregiver", "Client", mymips, 500, "State_Action", Tuple.DOWN, AppEdge.MODULE); //  
		application.addAppEdge("Client", "DISPLAY",2000, 500, "P_State_Action", Tuple.DOWN, AppEdge.ACTUATOR);  //
		application.addAppEdge("Cloud_Analytics", "Caregiver", 2000, 1000, "Advanced_Analytics", Tuple.DOWN, AppEdge.MODULE);  
		
 	    //Defining the input-output relationships (represented by selectivity) of the application modules. 
		application.addTupleMapping("Client", "ECG", "SENSOR_DATA", new FractionalSelectivity(1.0)); // 
		application.addTupleMapping("Client", "State_Action", "P_State_Action", new FractionalSelectivity(1.0)); //  
		application.addTupleMapping("Filtering", "SENSOR_DATA", "FILTERED_DATA", new FractionalSelectivity(1.0)); // 
		application.addTupleMapping("Monitoring", "FILTERED_DATA", "ECG_REPORT", new FractionalSelectivity(1.0)); //
		application.addTupleMapping("Caregiver", "ECG_REPORT", "DATA_OFFLOAD", new FractionalSelectivity(1.0)); //
		application.addTupleMapping("Caregiver", "ECG_REPORT", "State_Action", new FractionalSelectivity(1.0)); //
		application.addTupleMapping("Cloud_Analytics", "DATA_OFFLOAD", "Advanced_Analytics", new FractionalSelectivity(0.01)); //
	
		
		 // Defining application loops to monitor the latency of.
		//final AppLoop ONLY_CLOUD = new AppLoop(new ArrayList<String>(){{add("ECG");add("Client");add("Filtering");add("Monitoring");add("Caregiver");add("Client");add("DISPLAY");}}); //add("Cloud_Analytics");
        //List<AppLoop> loops = new ArrayList<AppLoop>(){{ add(ONLY_CLOUD);}};
		//final AppLoop ECG_REPORTING = new AppLoop(new ArrayList<String>(){{add("ECG");add("Client");add("Filtering");add("Monitoring");add("Caregiver");add("Client");add("DISPLAY");}});
        //List<AppLoop> loops = new ArrayList<AppLoop>(){{ add(ECG_REPORTING);}};
		final AppLoop ECG_ANALYTICS = new AppLoop(new ArrayList<String>(){{add("ECG");add("Client");add("Filtering");add("Monitoring");add("Caregiver");}});
        List<AppLoop> loops = new ArrayList<AppLoop>(){{add( ECG_ANALYTICS);}}; 
 		application.setLoops(loops);
		return application;
		}
///random number generators//////////////////////////////////////////////////////////
	private static double getvalue(double d, double e)  { 
	    Random r = new Random(); 
	    double randomValue = d + (e - d) *r.nextDouble(); 
	   // randomValue = r.nextDouble();
	    return randomValue; 
	  } 
	private static Integer getvalue(int min, int max) { 
	    Random r = new Random(); 
	    Integer randomValue = min + r.nextInt()%(max - min); 
	   // randomValue = r.nextInt(max);
	    return randomValue; 
	  }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//scheduled cloudlet processing =30,100,200,300,500 mips for filtering monitoring caregiver  
//scheduled cloudlet processing = 1000  for client and cloudanalytics modules
// mobile id, need Modulename executed with max delay (3:5)
//static Pair<String, Double> moduledeadline = new Pair <String, Double>(null,null);  // mobile id need deadline double
//static List<Pair<String, Double>> moduledeadline = new ArrayList<Pair <String, Double>>();


//if(placement.equals("Latency Differentiated Module Placement")) {		
//System.out.println(String.format("%-30s%s" ,"Per_User Differentiated Module Placement, " ," variable mips between 50 mips, "+  mymips+ " for all modules except cloud plus 1000 mips"));
//}		
//else if(placement.equals("Module Placement Edgeward")) {
//System.out.println(String.format("%-30s%20s%s%30s%10s%s" ,"Per_Module Edgeward Placement","const mips= " , mymips));
//System.out.println("Per_Module Placement,  Tuple's mips= " + mymips);
//}
///else 
//placement=="Latency Module Placement" 
//System.out.println(String.format("%-30s%20s%s%30s%10s%s" ,"Per_User Basic Module Placement","const mips= " , mymips));
//System.out.println("Per_User Basic Module Placement,  const mips= " + mymips);		

//System.out.println("Application Module mips: Client = Filtering = Monitoring = Caregiver = 300 mips , Cloud_Analytics = 600 mips");
//System.out.println("Migration Condition: Mobile Utilization >= 0.3, Proxy/Dept Utilization >= 0.9" );  //, RESOURCE_MANAGE_INTERVAL = 100 ");
//System.out.println("Enhanced Migration Conditions , RESOURCE_MANAGE_INTERVAL = 10 ");
//System.out.println("fog device scheduling interval = 10,  Application module scheduling interval = 300  ");	

//moduledeadline.put("Client", (x+ 15.0000000000000000));
//deadlineInfomodule.put(id,moduledeadline);
//moduledeadline.put("Caregiver", x);
//deadlineInfomodule.put(id,moduledeadline);				
//System.out.println("deadlineInfomodule  "+ deadlineInfomodule);
//deadlineInfomodule.put(id,moduledeadlinelist);				
//moduledeadline.clear();

/*
for(Integer id : idOfEndDevices){
	if (placement.equals("Latency Differentiated Module Placement")) {
		Integer x= getvalue(50, 500);//mymips);
		x= Math.abs(x);
		additionalMipsInfo.put(id, (double)x);  //getvalue(0,mymips)
		}
	else
		additionalMipsInfo.put(id, (double)mymips);
}
*/
/*else if(device.getName().startsWith("d")){
moduleMapping.addModuleToDevice("Filtering", device.getName());
moduleMapping.addModuleToDevice("Monitoring", device.getName());				
} */
//Controller controller = new Controller("master-controller", fogDevices, sensors, actuators);
//controller.submitApplication(application, 0, new ModulePlacementOnlyCloud(fogDevices, sensors, actuators, application));
//controller.submitApplication(application, 0, new LatencyModulePlacement(fogDevices, sensors, actuators, application, moduleMapping));
//controller.submitApplication(application, 0, new LatencyModifiedModulePlacementNew(fogDevices, sensors, actuators, application, moduleMapping));
 //LModulePlacementEdgewards  // LatencyModulePlacementNear

//TRY FogDevice cloud = createFogDevice("cloud", 448000000, 40000000, 100000, 10000000, 0, 0.01, 16*103, 16*83.25); // creates the fog device Cloud at the apex of the hierarchy with level=0
//FogDevice cloud = createFogDevice("cloud", 4480000, 4000000, 100, 10000, 0, 0.01, 16*103, 16*83.25); // creates the fog device Cloud at the apex of the hierarchy with level=0
//FogDevice proxy = createFogDevice("proxy-server", 2800, 4000, 10000, 10000, 1, 0.0, 107.339, 83.4333);

//peList.add(new Pe(0, new PeProvisionerSimple(mips))); // need to store Pe id and MIPS Rating


/*
application.addAppModule("Client", 10, 300, 1000,100,5); // adding module Client to the application model
application.addAppModule("Filtering",10, 300, 1000, 100,4); //
application.addAppModule("Monitoring",10, 300, 1000,100,3); // 
application.addAppModule("Caregiver", 10, 300,1000,100,2); // 
application.addAppModule("Cloud_Analytics",10, 600,1000,250,1); //("Cloud_Analytics",10, 500,1000,500,1); //
*/
/*application.addAppEdge("ECG", "Client", 3000, 1000, "ECG", Tuple.UP, AppEdge.SENSOR);
application.addAppEdge("Client", "Filtering", 3000, 500, "SENSOR_DATA", Tuple.UP, AppEdge.MODULE); //
application.addAppEdge("Filtering", "Monitoring", (30+ mymips), 500, "FILTERED_DATA", Tuple.UP, AppEdge.MODULE); // 
application.addAppEdge("Monitoring", "Cloud_Analytics", 1000, 500, "DATA_OFFLOAD", Tuple.UP, AppEdge.MODULE); // 
application.addAppEdge("Monitoring", "Caregiver", (60+ mymips) , 500, "ECG_REPORT", Tuple.UP, AppEdge.MODULE);  // 
application.addAppEdge("Cloud_Analytics", "Caregiver", 3500, 1000, "Advanced_Analytics", Tuple.DOWN, AppEdge.MODULE);  // 
application.addAppEdge("Caregiver", "Client", 1000 , 500, "State_Action", Tuple.DOWN, AppEdge.MODULE); // 
application.addAppEdge("Client", "DISPLAY",1000, 500, "P_State_Action", Tuple.DOWN, AppEdge.ACTUATOR);  //
 */
//application.addAppEdge("Caregiver", "Cloud_Analytics", 3000, 1000, "DECISION", Tuple.UP, AppEdge.MODULE); //
// application.addTupleMapping("Cloud_Analytics", "DECISION", "Advanced_Analytics", new FractionalSelectivity(0.001)); //
//final AppLoop HBR_Analytics = new AppLoop(new ArrayList<String>(){{add("HBR"); add("Client"); add("Monitoring"); add("Cloud_Analytics"); add("Caregiver"); add("Client"); add("DISPLAY");}});

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10062, count -3525, length 26092
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-10-15 12:36:19.841
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.StringIndexOutOfBoundsException: offset 10062, count -3525, length 26092
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:324)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10062, count -3525, length 26092
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	... 16 more
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10062, count -3525, length 26092
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2020-10-15 12:36:19.841
!MESSAGE offset 10062, count -3525, length 26092
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10062, count -3525, length 26092
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2020-10-15 12:36:19.841
!MESSAGE offset 10062, count -3525, length 26092
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10062, count -3525, length 26092
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-10-15 12:36:19.843
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.StringIndexOutOfBoundsException: offset 10062, count -3525, length 26092
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:324)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10062, count -3525, length 26092
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	... 16 more
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10062, count -3525, length 26092
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2020-10-15 12:36:19.843
!MESSAGE offset 10062, count -3525, length 26092
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10062, count -3525, length 26092
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-10-15 12:36:19.859
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10062, count -3525, length 26092
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-10-15 12:36:19.860
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10062, count -3525, length 26092
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-10-15 12:36:20.864
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10062, count -3525, length 26092
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-10-15 12:36:20.865
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10062, count -3525, length 26092
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-10-15 12:36:21.914
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10062, count -3525, length 26092
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-10-15 12:36:21.915
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10062, count -3525, length 26092
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-10-15 12:36:23.759
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10062, count -3525, length 26092
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-10-15 12:36:23.761
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10062, count -3525, length 26092
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-10-15 12:36:24.398
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10062, count -3525, length 26092
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-10-15 12:36:24.399
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10062, count -3525, length 26092
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-10-15 12:36:28.255
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10062, count -3525, length 26092
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-10-15 12:36:28.256
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10062, count -3525, length 26092
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-10-15 12:36:30.865
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
package org.fog.test.perfeval;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.stream.Collectors;
import org.apache.commons.math3.util.Pair;
import org.cloudbus.cloudsim.Host;
import org.cloudbus.cloudsim.Log;
import org.cloudbus.cloudsim.Pe;
import org.cloudbus.cloudsim.Storage;
import org.cloudbus.cloudsim.core.CloudSim;
import org.cloudbus.cloudsim.power.PowerHost;
import org.cloudbus.cloudsim.provisioners.PeProvisionerSimple;
import org.cloudbus.cloudsim.provisioners.RamProvisionerSimple;
import org.cloudbus.cloudsim.sdn.overbooking.BwProvisionerOverbooking;
import org.cloudbus.cloudsim.sdn.overbooking.PeProvisionerOverbooking;
import org.fog.application.AppEdge;
import org.fog.application.AppLoop;
import org.fog.application.Application;
import org.fog.application.selectivity.FractionalSelectivity;
import org.fog.entities.Actuator;
import org.fog.entities.FogBroker;
import org.fog.entities.FogDevice;
import org.fog.entities.FogDeviceCharacteristics;
import org.fog.entities.Sensor;
import org.fog.entities.Tuple;
import org.fog.placement.Controller;
import org.fog.placement.ControllerEdgeward;
import org.fog.placement.LModulePlacementEdgewards;
import org.fog.placement.LatencyModulePlacementNear;
import org.fog.placement.ModuleMapping;
import org.fog.placement.ModulePlacementDifferentiated;
import org.fog.placement.ModulePlacementEdgewards;
import org.fog.placement.ModulePlacementMapping;
import org.fog.placement.ModulePlacementModified;
import org.fog.placement.ModulePlacementOnlyCloud;
import org.fog.policy.AppModuleAllocationPolicy;
import org.fog.scheduler.StreamOperatorScheduler;
import org.fog.utils.Config;
import org.fog.utils.FogLinearPowerModel;
import org.fog.utils.FogUtils;
import org.fog.utils.TimeKeeper;
import org.fog.utils.distribution.DeterministicDistribution;

/**
 * Simulation setup for  ECG
 * @author Ragaa Shehab
 *
 */ //updateTimingsOnReceipt - checkCloudletCompletion --tupleEndedExecutionUser
public class ECG {
	static List<FogDevice> fogDevices = new ArrayList<FogDevice>();
	static List<Sensor> sensors = new ArrayList<Sensor>();
	static List<Actuator> actuators = new ArrayList<Actuator>();
	static Map<Integer,FogDevice> deviceById = new HashMap<Integer,FogDevice>();	
	static List<Integer> idOfEndDevices = new ArrayList<Integer>();
	static Map<Integer, Double> deadlineInfo = new	HashMap<Integer, Double>();  // mobile id has priority
	static Map<Integer, Double> additionalMipsInfo = new HashMap<Integer, Double>(); // mobile id need tuple mips
	static Map<Integer, Map<String, Double>> deadlineInfomodule = new HashMap<Integer, Map<String,Double>>();  // mobile id has modulename with module priority
	static Map<Integer,List<Map<String, Double>>> deadlineInfomodule1 = new HashMap<Integer, List<Map<String,Double>>>();  // mobile id has modulename with module priority

	static boolean CLOUD = false;
	static int numOfDepts = 1;
	static int numOfMobilesPerDept =5;
	static double ECG_TRANSMISSION_TIME = 50.0 ; // 50.0;   //100, 50, 25 ms   100 //10s= 10000
	static public int mymips= 2000;     
	//static String placement = "Latency Module Placement"; 
	static String placement = "Latency Differentiated Module Placement"; 
	//static String placement = "Module Placement Edgeward";
	//static String placement = "Module Placement Edgeward Differentiated";
	//static String placement = "Latency Modified Module Placement";
	static double MobileCPUload= 0.1;
	
	public static void main(String[] args) {
		Log.print("Starting ECG transmission");	Log.print("             ECG transmission time ms: "); Log.print(ECG_TRANSMISSION_TIME);
		Log.print("     Depts/Mobiles =  "); Log.print (numOfDepts);Log.print("/"); Log.printLine (numOfMobilesPerDept);
		System.out.println("analytics VM mips  2000, Fog device mips: mobile 1000, dept  2800, proxy 16800" ); 

		
		try {
			Log.disable(); 	
			//Config.MAX_SIMULATION_TIME= 100000;
			int num_user = 1; // number of cloud users
			Calendar calendar = Calendar.getInstance();
			boolean trace_flag = false; // mean trace events
			CloudSim.init(num_user, calendar, trace_flag);						
			String appId = "ECG"; 
			FogBroker broker = new FogBroker("broker");			
			createFogDevices(broker.getId(), appId);
			
			Map<String, Double> moduledeadline= new HashMap<String, Double>();
			Map<String, Double> moduledeadline1;
			List<Map<String, Double>> moduledeadline1List;

			for(Integer id : idOfEndDevices){
				Double x= getvalue(5.00, 40.00);
				Double t1= 10.00; Double t2= 5.00; //Double t3= 5.00;
				deadlineInfo.put(id, x);
				
				if (placement.equals("Latency Differentiated Module Placement")||placement.equals("Module Placement Edgeward Differentiated")) {
						if((5.00 < x)&& (x < 10.00)) x=5.00;
						if(10.00 < x)&& (x < 15.00) x=10.00;
						if(15.00 <  x)&& (x < 20.00) x=20.00;
						if(20.00 < x < 30.00) x=30.00;
						if(30.00 < x < 40.00) x=40.00;
					
							
						
					additionalMipsInfo.put(id, x*100); //1000
					moduledeadline1=  new HashMap<String,Double>();
					moduledeadline1List= new ArrayList<Map<String, Double>>();
					moduledeadline1.put("Client", x*100);
					moduledeadline1.put("Filtering", x*100);
					moduledeadline1.put("Monitoring", x*100);
					moduledeadline1.put("Caregiver", x*100);
					moduledeadline1.put("Cloud_Analytics", x*100);
					moduledeadline1List.add(moduledeadline1);
					deadlineInfomodule1.put(id, moduledeadline1List);
				}
				else {
					additionalMipsInfo.put(id, (double)mymips);
					moduledeadline1=  new HashMap<String,Double>();
					moduledeadline1List= new ArrayList<Map<String, Double>>();
					moduledeadline1.put("Client", (double)mymips);
					moduledeadline1.put("Filtering", (double)mymips);
					moduledeadline1.put("Monitoring", (double)mymips);
					moduledeadline1.put("Caregiver", (double)mymips);
					moduledeadline1.put("Cloud_Analytics", (double)mymips);
					moduledeadline1List.add(moduledeadline1);
					deadlineInfomodule1.put(id, moduledeadline1List);
				}
				moduledeadline.put("Filtering", (x+t1));
				deadlineInfomodule.put(id,moduledeadline);
				moduledeadline.put("Monitoring", (x+ t2));
				deadlineInfomodule.put(id,moduledeadline);
			}	
			
			deadlineInfo=deadlineInfo.entrySet()
		             .stream().sorted(Map.Entry.comparingByValue())
		             .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -> e1, LinkedHashMap::new));			
				
			Application application = createApplication(appId, broker.getId());
			application.setUserId(broker.getId());
			application.setdeviceById(deviceById);
			application.setidOfEndDevices(idOfEndDevices);
			application.setDeadlineInfo(deadlineInfo);
			application.setDeadlineInfomodule(deadlineInfomodule);
			application.setDeadlineInfomodule1(deadlineInfomodule1);
		    application.setAdditionalMipsInfo(additionalMipsInfo);
		    application.setplacement(placement);
		    application.setMobileCPUload(MobileCPUload);
		    
		    System.out.println(String.format("%-25s%s" ,"User Priority ASC ", application.getDeadlineInfo()));
			System.out.println(String.format("%-25s%s" ,"Module Tuble MIPS ",application.getAdditionalMipsInfo()));
		   /// System.out.println(String.format("%-25s%s" ,"Module Priority ",application.getDeadlineInfomodule()));
		    System.out.println(String.format("%-25s%s" ,"Module Priority1 ",application.getDeadlineInfomodule1()));

		    System.out.println("mobile CPU load "+ application.getMobileCPUload());
		    		
			Controller controller = null;
			ModuleMapping moduleMapping = ModuleMapping.createModuleMapping(); // initializing a module mapping			
			moduleMapping.addModuleToDevice("Cloud_Analytics", "cloud");
			for(FogDevice device : fogDevices){
				if(device.getName().startsWith("m"))
					moduleMapping.addModuleToDevice("Client", device.getName());
				}
			if(CLOUD){			 
				moduleMapping.addModuleToDevice("Caregiver", "cloud");
				moduleMapping.addModuleToDevice("Monitoring", "cloud");
				moduleMapping.addModuleToDevice("Filtering", "cloud");
				System.out.println("cloud only module placement, tuple mips= "+ mymips);
				controller = new ControllerEdgeward("master-controller", fogDevices, sensors, actuators);
				controller.submitApplication(application, 0, new ModulePlacementMapping(fogDevices, application,moduleMapping));
				}
			else {
				moduleMapping.addModuleToDevice("Caregiver", "proxy-server");
				switch (placement) { 
				case "Latency Module Placement":{			
					System.out.println("Per User Basic module placement");//", Tuple mips= "+ mymips
					controller = new Controller("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LatencyModulePlacementNear(fogDevices, sensors, actuators, application, moduleMapping));
					break;}	
				case "Latency Modified Module Placement":{
					System.out.println("Per User Modified module placement");
					controller = new Controller("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new ModulePlacementModified(fogDevices, sensors, actuators, application, moduleMapping));
					break;}
				case "Latency Differentiated Module Placement":{
					System.out.println("Per User Differentiated module placement, variable Module/Tuple mips ");
					controller = new Controller("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LatencyModulePlacementNear(fogDevices, sensors, actuators, application, moduleMapping));
					break;} //ModulePlacementDifferentiated
				case "Module Placement Edgeward":{
					System.out.println("Per module placement");
					controller = new ControllerEdgeward("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LModulePlacementEdgewards(fogDevices, sensors, actuators, application, moduleMapping));
					break;}
				case "Module Placement Edgeward Differentiated":{
					System.out.println("Per module Differentiated placement");
					controller = new ControllerEdgeward("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LModulePlacementEdgewards(fogDevices, sensors, actuators, application, moduleMapping));
					break;}
				}
				}
					
			TimeKeeper.getInstance().setSimulationStartTime(Calendar.getInstance().getTimeInMillis());
			CloudSim.startSimulation();
			CloudSim.stopSimulation();
			Log.printLine("ECG finished!");
		} catch (Exception e) {
			e.printStackTrace();
			Log.printLine("Unwanted errors happen");
		}
	}	
/****************************************************************************************
	 * Creates the fog devices in the physical topology of the simulation.
	 * @param userId
	 * @param appId
	 */
	private static void createFogDevices(int userId, String appId) {  // 44800
		FogDevice cloud = createFogDevice("cloud", 44800, 40000, 100, 10000, 0, 0.01, 16*103, 16*83.25); // creates the fog device Cloud at the apex of the hierarchy with level=0
		cloud.setParentId(-1);		 
		FogDevice proxy = createFogDevice("proxy-server", 16800 , 4000, 10000, 10000, 1, 0.0, 107.339, 83.4333); // 2800
		proxy.setParentId(cloud.getId()); // setting Cloud as parent of the Proxy Server
		proxy.setUplinkLatency(100); // latency of connection from Proxy Server to the Cloud is 100 ms		
		fogDevices.add(cloud);
		deviceById.put(cloud.getId(), cloud);
		fogDevices.add(proxy);
		deviceById.put(proxy.getId(), proxy);		
		for(int i=0;i<numOfDepts;i++){
			addGw(i+"", userId, appId, proxy.getId()); // adding a fog device for every Gateway in physical topology. The parent of each gateway is the Proxy Server
		}	
	}

	private static FogDevice addGw(String id, int userId, String appId, int parentId){
		FogDevice dept = createFogDevice("d-"+id, 2800, 4000, 10000, 10000, 2, 0.0, 107.339, 83.4333); //2800
		fogDevices.add(dept);
		deviceById.put(dept.getId(), dept);
		dept.setParentId(parentId);
		dept.setUplinkLatency(4); // latency of connection between gateways and proxy server is 4 ms
		for(int i=0;i<numOfMobilesPerDept;i++){
			String mobileId = id+"-"+i;
			FogDevice mobile = addMobile(mobileId, userId, appId, dept.getId()); // adding mobiles to the physical topology. Smartphones have been modeled as fog devices as well.
			mobile.setUplinkLatency(2); // latency of connection between the smartphone and proxy server is 4 ms
			fogDevices.add(mobile);
			deviceById.put(mobile.getId(), mobile);
		}
		return dept;
	}
	
	private static FogDevice addMobile(String id, int userId, String appId, int parentId){
		FogDevice mobile = createFogDevice("m-"+id, 1000, 1000, 10000, 270, 3, 0, 87.53, 82.44); //1000   
		mobile.setParentId(parentId);
		idOfEndDevices.add(mobile.getId());
		Sensor ecgsensor = new Sensor("s-"+id, "ECG", userId, appId, new DeterministicDistribution(ECG_TRANSMISSION_TIME)); // inter-transmission time of EEG sensor follows a deterministic distribution
		sensors.add(ecgsensor);
		Actuator display = new Actuator("a-"+id, userId, appId, "DISPLAY");
		actuators.add(display);
		ecgsensor.setGatewayDeviceId(mobile.getId());
		ecgsensor.setLatency(6.0);  // latency of connection between EEG sensors and the parent Smartphone is 6 ms
		display.setGatewayDeviceId(mobile.getId());
		display.setLatency(1.0);  // latency of connection between Display actuator and the parent Smartphone is 1 ms
		return mobile;
	}
	
/*****************************************************************************************
	 * Creates a vanilla fog device
	 * @param nodeName name of the device to be used in simulation
	 * @param mips MIPS
	 * @param ram RAM
	 * @param upBw uplink bandwidth
	 * @param downBw downlink bandwidth
	 * @param level hierarchy level of the device
	 * @param ratePerMips cost rate per MIPS used
	 * @param busyPower
	 * @param idlePower
	 * @return
	 */
	private static FogDevice createFogDevice(String nodeName, long mips,
			int ram, long upBw, long downBw, int level, double ratePerMips, double busyPower, double idlePower) {
		
		List<Pe> peList = new ArrayList<Pe>();
		// 3. Create PEs and add these into a list.
		peList.add(new Pe(0, new PeProvisionerOverbooking(mips))); // need to store Pe id and MIPS Rating
		
		int hostId = FogUtils.generateEntityId();
		long storage = 1000000; // host storage
		int bw = 10000;
		PowerHost host = new PowerHost(
				hostId,
				new RamProvisionerSimple(ram),
				new BwProvisionerOverbooking(bw),
				storage,
				peList,
				new StreamOperatorScheduler(peList),
				new FogLinearPowerModel(busyPower, idlePower)
			);

		List<Host> hostList = new ArrayList<Host>();
		hostList.add(host);

		String arch = "x86"; // system architecture
		String os = "Linux"; // operating system
		String vmm = "Xen";
		double time_zone = 10.0; // time zone this resource located
		double cost = 3.0; // the cost of using processing in this resource
		double costPerMem = 0.05; // the cost of using memory in this resource
		double costPerStorage = 0.001; // the cost of using storage in this	// resource
		double costPerBw = 0.0; // the cost of using bw in this resource
		LinkedList<Storage> storageList = new LinkedList<Storage>(); // we are not adding SAN devices by now

		FogDeviceCharacteristics characteristics = new FogDeviceCharacteristics(
				arch, os, vmm, host, time_zone, cost, costPerMem,
				costPerStorage, costPerBw);

		FogDevice fogdevice = null;
		try {
			fogdevice = new FogDevice(nodeName, characteristics, 
					new AppModuleAllocationPolicy(hostList), storageList, 10 , upBw, downBw, 0, ratePerMips); //10 : schedulingInterval  0 uplink  latency		
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		fogdevice.setLevel(level);
		return fogdevice;
	}

/******************************************************************************************
	 * Function to create the EEG Tractor Beam game application in the DDF model. 
	 * @param appId unique identifier of the application
	 * @param userId identifier of the user of the application
	 * @return
	 */
	@SuppressWarnings({"serial" })
	private static Application createApplication(String appId, int userId){
		
		Application application = Application.createApplication(appId, userId); // creates an empty application model (empty directed graph)
		
		// Adding modules (vertices) to the application model (directed graph)
		application.addAppModule("Client", 10, 2000, 1000,100,5); //250Name,int ram, int mips, long size, long bw, int modprty) size is the image size (MB)
		application.addAppModule("Filtering",10, 2000, 500, 100,4); //150
		application.addAppModule("Monitoring",10, 2000, 500,100,3); //150 
		application.addAppModule("Caregiver", 10, 2000,1000,100,2); // 150
		application.addAppModule("Cloud_Analytics",10, 3000,1000,250,1); //500("Cloud_Analytics",10, 500,1000,500,1); //
		
		// Connecting the application modules (vertices) in the application model (directed graph) with edges
		//source, destination, double tupleCpuLength, double tupleNwLength, String tupleType, int direction, int edgeType){
		application.addAppEdge("ECG", "Client", 2000, 500, "ECG", Tuple.UP, AppEdge.SENSOR);
		application.addAppEdge("Client", "Filtering", 2000, 500, "SENSOR_DATA", Tuple.UP, AppEdge.MODULE); //
		application.addAppEdge("Filtering", "Monitoring", mymips, 500, "FILTERED_DATA", Tuple.UP, AppEdge.MODULE); //
		application.addAppEdge("Monitoring", "Caregiver", mymips, 500, "ECG_REPORT", Tuple.UP, AppEdge.MODULE);  //
		application.addAppEdge("Caregiver", "Cloud_Analytics", mymips, 500, "DATA_OFFLOAD", Tuple.UP, AppEdge.MODULE); //		
		application.addAppEdge("Caregiver", "Client", mymips, 500, "State_Action", Tuple.DOWN, AppEdge.MODULE); //  
		application.addAppEdge("Client", "DISPLAY",2000, 500, "P_State_Action", Tuple.DOWN, AppEdge.ACTUATOR);  //
		application.addAppEdge("Cloud_Analytics", "Caregiver", 2000, 1000, "Advanced_Analytics", Tuple.DOWN, AppEdge.MODULE);  
		
 	    //Defining the input-output relationships (represented by selectivity) of the application modules. 
		application.addTupleMapping("Client", "ECG", "SENSOR_DATA", new FractionalSelectivity(1.0)); // 
		application.addTupleMapping("Client", "State_Action", "P_State_Action", new FractionalSelectivity(1.0)); //  
		application.addTupleMapping("Filtering", "SENSOR_DATA", "FILTERED_DATA", new FractionalSelectivity(1.0)); // 
		application.addTupleMapping("Monitoring", "FILTERED_DATA", "ECG_REPORT", new FractionalSelectivity(1.0)); //
		application.addTupleMapping("Caregiver", "ECG_REPORT", "DATA_OFFLOAD", new FractionalSelectivity(1.0)); //
		application.addTupleMapping("Caregiver", "ECG_REPORT", "State_Action", new FractionalSelectivity(1.0)); //
		application.addTupleMapping("Cloud_Analytics", "DATA_OFFLOAD", "Advanced_Analytics", new FractionalSelectivity(0.01)); //
	
		
		 // Defining application loops to monitor the latency of.
		//final AppLoop ONLY_CLOUD = new AppLoop(new ArrayList<String>(){{add("ECG");add("Client");add("Filtering");add("Monitoring");add("Caregiver");add("Client");add("DISPLAY");}}); //add("Cloud_Analytics");
        //List<AppLoop> loops = new ArrayList<AppLoop>(){{ add(ONLY_CLOUD);}};
		//final AppLoop ECG_REPORTING = new AppLoop(new ArrayList<String>(){{add("ECG");add("Client");add("Filtering");add("Monitoring");add("Caregiver");add("Client");add("DISPLAY");}});
        //List<AppLoop> loops = new ArrayList<AppLoop>(){{ add(ECG_REPORTING);}};
		final AppLoop ECG_ANALYTICS = new AppLoop(new ArrayList<String>(){{add("ECG");add("Client");add("Filtering");add("Monitoring");add("Caregiver");}});
        List<AppLoop> loops = new ArrayList<AppLoop>(){{add( ECG_ANALYTICS);}}; 
 		application.setLoops(loops);
		return application;
		}
///random number generators//////////////////////////////////////////////////////////
	private static double getvalue(double d, double e)  { 
	    Random r = new Random(); 
	    double randomValue = d + (e - d) *r.nextDouble(); 
	   // randomValue = r.nextDouble();
	    return randomValue; 
	  } 
	private static Integer getvalue(int min, int max) { 
	    Random r = new Random(); 
	    Integer randomValue = min + r.nextInt()%(max - min); 
	   // randomValue = r.nextInt(max);
	    return randomValue; 
	  }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//scheduled cloudlet processing =30,100,200,300,500 mips for filtering monitoring caregiver  
//scheduled cloudlet processing = 1000  for client and cloudanalytics modules
// mobile id, need Modulename executed with max delay (3:5)
//static Pair<String, Double> moduledeadline = new Pair <String, Double>(null,null);  // mobile id need deadline double
//static List<Pair<String, Double>> moduledeadline = new ArrayList<Pair <String, Double>>();


//if(placement.equals("Latency Differentiated Module Placement")) {		
//System.out.println(String.format("%-30s%s" ,"Per_User Differentiated Module Placement, " ," variable mips between 50 mips, "+  mymips+ " for all modules except cloud plus 1000 mips"));
//}		
//else if(placement.equals("Module Placement Edgeward")) {
//System.out.println(String.format("%-30s%20s%s%30s%10s%s" ,"Per_Module Edgeward Placement","const mips= " , mymips));
//System.out.println("Per_Module Placement,  Tuple's mips= " + mymips);
//}
///else 
//placement=="Latency Module Placement" 
//System.out.println(String.format("%-30s%20s%s%30s%10s%s" ,"Per_User Basic Module Placement","const mips= " , mymips));
//System.out.println("Per_User Basic Module Placement,  const mips= " + mymips);		

//System.out.println("Application Module mips: Client = Filtering = Monitoring = Caregiver = 300 mips , Cloud_Analytics = 600 mips");
//System.out.println("Migration Condition: Mobile Utilization >= 0.3, Proxy/Dept Utilization >= 0.9" );  //, RESOURCE_MANAGE_INTERVAL = 100 ");
//System.out.println("Enhanced Migration Conditions , RESOURCE_MANAGE_INTERVAL = 10 ");
//System.out.println("fog device scheduling interval = 10,  Application module scheduling interval = 300  ");	

//moduledeadline.put("Client", (x+ 15.0000000000000000));
//deadlineInfomodule.put(id,moduledeadline);
//moduledeadline.put("Caregiver", x);
//deadlineInfomodule.put(id,moduledeadline);				
//System.out.println("deadlineInfomodule  "+ deadlineInfomodule);
//deadlineInfomodule.put(id,moduledeadlinelist);				
//moduledeadline.clear();

/*
for(Integer id : idOfEndDevices){
	if (placement.equals("Latency Differentiated Module Placement")) {
		Integer x= getvalue(50, 500);//mymips);
		x= Math.abs(x);
		additionalMipsInfo.put(id, (double)x);  //getvalue(0,mymips)
		}
	else
		additionalMipsInfo.put(id, (double)mymips);
}
*/
/*else if(device.getName().startsWith("d")){
moduleMapping.addModuleToDevice("Filtering", device.getName());
moduleMapping.addModuleToDevice("Monitoring", device.getName());				
} */
//Controller controller = new Controller("master-controller", fogDevices, sensors, actuators);
//controller.submitApplication(application, 0, new ModulePlacementOnlyCloud(fogDevices, sensors, actuators, application));
//controller.submitApplication(application, 0, new LatencyModulePlacement(fogDevices, sensors, actuators, application, moduleMapping));
//controller.submitApplication(application, 0, new LatencyModifiedModulePlacementNew(fogDevices, sensors, actuators, application, moduleMapping));
 //LModulePlacementEdgewards  // LatencyModulePlacementNear

//TRY FogDevice cloud = createFogDevice("cloud", 448000000, 40000000, 100000, 10000000, 0, 0.01, 16*103, 16*83.25); // creates the fog device Cloud at the apex of the hierarchy with level=0
//FogDevice cloud = createFogDevice("cloud", 4480000, 4000000, 100, 10000, 0, 0.01, 16*103, 16*83.25); // creates the fog device Cloud at the apex of the hierarchy with level=0
//FogDevice proxy = createFogDevice("proxy-server", 2800, 4000, 10000, 10000, 1, 0.0, 107.339, 83.4333);

//peList.add(new Pe(0, new PeProvisionerSimple(mips))); // need to store Pe id and MIPS Rating


/*
application.addAppModule("Client", 10, 300, 1000,100,5); // adding module Client to the application model
application.addAppModule("Filtering",10, 300, 1000, 100,4); //
application.addAppModule("Monitoring",10, 300, 1000,100,3); // 
application.addAppModule("Caregiver", 10, 300,1000,100,2); // 
application.addAppModule("Cloud_Analytics",10, 600,1000,250,1); //("Cloud_Analytics",10, 500,1000,500,1); //
*/
/*application.addAppEdge("ECG", "Client", 3000, 1000, "ECG", Tuple.UP, AppEdge.SENSOR);
application.addAppEdge("Client", "Filtering", 3000, 500, "SENSOR_DATA", Tuple.UP, AppEdge.MODULE); //
application.addAppEdge("Filtering", "Monitoring", (30+ mymips), 500, "FILTERED_DATA", Tuple.UP, AppEdge.MODULE); // 
application.addAppEdge("Monitoring", "Cloud_Analytics", 1000, 500, "DATA_OFFLOAD", Tuple.UP, AppEdge.MODULE); // 
application.addAppEdge("Monitoring", "Caregiver", (60+ mymips) , 500, "ECG_REPORT", Tuple.UP, AppEdge.MODULE);  // 
application.addAppEdge("Cloud_Analytics", "Caregiver", 3500, 1000, "Advanced_Analytics", Tuple.DOWN, AppEdge.MODULE);  // 
application.addAppEdge("Caregiver", "Client", 1000 , 500, "State_Action", Tuple.DOWN, AppEdge.MODULE); // 
application.addAppEdge("Client", "DISPLAY",1000, 500, "P_State_Action", Tuple.DOWN, AppEdge.ACTUATOR);  //
 */
//application.addAppEdge("Caregiver", "Cloud_Analytics", 3000, 1000, "DECISION", Tuple.UP, AppEdge.MODULE); //
// application.addTupleMapping("Cloud_Analytics", "DECISION", "Advanced_Analytics", new FractionalSelectivity(0.001)); //
//final AppLoop HBR_Analytics = new AppLoop(new ArrayList<String>(){{add("HBR"); add("Client"); add("Monitoring"); add("Cloud_Analytics"); add("Caregiver"); add("Client"); add("DISPLAY");}});

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10069, count -3525, length 26099
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-10-15 12:36:30.866
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.StringIndexOutOfBoundsException: offset 10069, count -3525, length 26099
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:324)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10069, count -3525, length 26099
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	... 16 more
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10069, count -3525, length 26099
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2020-10-15 12:36:30.866
!MESSAGE offset 10069, count -3525, length 26099
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10069, count -3525, length 26099
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2020-10-15 12:36:30.866
!MESSAGE offset 10069, count -3525, length 26099
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10069, count -3525, length 26099
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-10-15 12:36:30.867
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.StringIndexOutOfBoundsException: offset 10069, count -3525, length 26099
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:324)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10069, count -3525, length 26099
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	... 16 more
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10069, count -3525, length 26099
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2020-10-15 12:36:30.867
!MESSAGE offset 10069, count -3525, length 26099
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10069, count -3525, length 26099
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-10-15 12:36:30.876
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10069, count -3525, length 26099
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-10-15 12:36:30.877
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10069, count -3525, length 26099
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-10-15 12:36:32.925
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10069, count -3525, length 26099
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-10-15 12:36:32.926
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10069, count -3525, length 26099
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-10-15 12:36:34.380
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
package org.fog.test.perfeval;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.stream.Collectors;
import org.apache.commons.math3.util.Pair;
import org.cloudbus.cloudsim.Host;
import org.cloudbus.cloudsim.Log;
import org.cloudbus.cloudsim.Pe;
import org.cloudbus.cloudsim.Storage;
import org.cloudbus.cloudsim.core.CloudSim;
import org.cloudbus.cloudsim.power.PowerHost;
import org.cloudbus.cloudsim.provisioners.PeProvisionerSimple;
import org.cloudbus.cloudsim.provisioners.RamProvisionerSimple;
import org.cloudbus.cloudsim.sdn.overbooking.BwProvisionerOverbooking;
import org.cloudbus.cloudsim.sdn.overbooking.PeProvisionerOverbooking;
import org.fog.application.AppEdge;
import org.fog.application.AppLoop;
import org.fog.application.Application;
import org.fog.application.selectivity.FractionalSelectivity;
import org.fog.entities.Actuator;
import org.fog.entities.FogBroker;
import org.fog.entities.FogDevice;
import org.fog.entities.FogDeviceCharacteristics;
import org.fog.entities.Sensor;
import org.fog.entities.Tuple;
import org.fog.placement.Controller;
import org.fog.placement.ControllerEdgeward;
import org.fog.placement.LModulePlacementEdgewards;
import org.fog.placement.LatencyModulePlacementNear;
import org.fog.placement.ModuleMapping;
import org.fog.placement.ModulePlacementDifferentiated;
import org.fog.placement.ModulePlacementEdgewards;
import org.fog.placement.ModulePlacementMapping;
import org.fog.placement.ModulePlacementModified;
import org.fog.placement.ModulePlacementOnlyCloud;
import org.fog.policy.AppModuleAllocationPolicy;
import org.fog.scheduler.StreamOperatorScheduler;
import org.fog.utils.Config;
import org.fog.utils.FogLinearPowerModel;
import org.fog.utils.FogUtils;
import org.fog.utils.TimeKeeper;
import org.fog.utils.distribution.DeterministicDistribution;

/**
 * Simulation setup for  ECG
 * @author Ragaa Shehab
 *
 */ //updateTimingsOnReceipt - checkCloudletCompletion --tupleEndedExecutionUser
public class ECG {
	static List<FogDevice> fogDevices = new ArrayList<FogDevice>();
	static List<Sensor> sensors = new ArrayList<Sensor>();
	static List<Actuator> actuators = new ArrayList<Actuator>();
	static Map<Integer,FogDevice> deviceById = new HashMap<Integer,FogDevice>();	
	static List<Integer> idOfEndDevices = new ArrayList<Integer>();
	static Map<Integer, Double> deadlineInfo = new	HashMap<Integer, Double>();  // mobile id has priority
	static Map<Integer, Double> additionalMipsInfo = new HashMap<Integer, Double>(); // mobile id need tuple mips
	static Map<Integer, Map<String, Double>> deadlineInfomodule = new HashMap<Integer, Map<String,Double>>();  // mobile id has modulename with module priority
	static Map<Integer,List<Map<String, Double>>> deadlineInfomodule1 = new HashMap<Integer, List<Map<String,Double>>>();  // mobile id has modulename with module priority

	static boolean CLOUD = false;
	static int numOfDepts = 1;
	static int numOfMobilesPerDept =5;
	static double ECG_TRANSMISSION_TIME = 50.0 ; // 50.0;   //100, 50, 25 ms   100 //10s= 10000
	static public int mymips= 2000;     
	//static String placement = "Latency Module Placement"; 
	static String placement = "Latency Differentiated Module Placement"; 
	//static String placement = "Module Placement Edgeward";
	//static String placement = "Module Placement Edgeward Differentiated";
	//static String placement = "Latency Modified Module Placement";
	static double MobileCPUload= 0.1;
	
	public static void main(String[] args) {
		Log.print("Starting ECG transmission");	Log.print("             ECG transmission time ms: "); Log.print(ECG_TRANSMISSION_TIME);
		Log.print("     Depts/Mobiles =  "); Log.print (numOfDepts);Log.print("/"); Log.printLine (numOfMobilesPerDept);
		System.out.println("analytics VM mips  2000, Fog device mips: mobile 1000, dept  2800, proxy 16800" ); 

		
		try {
			Log.disable(); 	
			//Config.MAX_SIMULATION_TIME= 100000;
			int num_user = 1; // number of cloud users
			Calendar calendar = Calendar.getInstance();
			boolean trace_flag = false; // mean trace events
			CloudSim.init(num_user, calendar, trace_flag);						
			String appId = "ECG"; 
			FogBroker broker = new FogBroker("broker");			
			createFogDevices(broker.getId(), appId);
			
			Map<String, Double> moduledeadline= new HashMap<String, Double>();
			Map<String, Double> moduledeadline1;
			List<Map<String, Double>> moduledeadline1List;

			for(Integer id : idOfEndDevices){
				Double x= getvalue(5.00, 40.00);
				Double t1= 10.00; Double t2= 5.00; //Double t3= 5.00;
				deadlineInfo.put(id, x);
				
				if (placement.equals("Latency Differentiated Module Placement")||placement.equals("Module Placement Edgeward Differentiated")) {
						if((5.00 < x)&& (x < 10.00)) x=5.00;
						if(10.00 < x)&& (x < 15.00) x=10.00;
						if(15.00 <  x)&& (x < 20.00) x=20.00;
						if(20.00 < x)&& ( x < 30.00) x=30.00;
						if(30.00 < x < 40.00) x=40.00;
					
							
						
					additionalMipsInfo.put(id, x*100); //1000
					moduledeadline1=  new HashMap<String,Double>();
					moduledeadline1List= new ArrayList<Map<String, Double>>();
					moduledeadline1.put("Client", x*100);
					moduledeadline1.put("Filtering", x*100);
					moduledeadline1.put("Monitoring", x*100);
					moduledeadline1.put("Caregiver", x*100);
					moduledeadline1.put("Cloud_Analytics", x*100);
					moduledeadline1List.add(moduledeadline1);
					deadlineInfomodule1.put(id, moduledeadline1List);
				}
				else {
					additionalMipsInfo.put(id, (double)mymips);
					moduledeadline1=  new HashMap<String,Double>();
					moduledeadline1List= new ArrayList<Map<String, Double>>();
					moduledeadline1.put("Client", (double)mymips);
					moduledeadline1.put("Filtering", (double)mymips);
					moduledeadline1.put("Monitoring", (double)mymips);
					moduledeadline1.put("Caregiver", (double)mymips);
					moduledeadline1.put("Cloud_Analytics", (double)mymips);
					moduledeadline1List.add(moduledeadline1);
					deadlineInfomodule1.put(id, moduledeadline1List);
				}
				moduledeadline.put("Filtering", (x+t1));
				deadlineInfomodule.put(id,moduledeadline);
				moduledeadline.put("Monitoring", (x+ t2));
				deadlineInfomodule.put(id,moduledeadline);
			}	
			
			deadlineInfo=deadlineInfo.entrySet()
		             .stream().sorted(Map.Entry.comparingByValue())
		             .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -> e1, LinkedHashMap::new));			
				
			Application application = createApplication(appId, broker.getId());
			application.setUserId(broker.getId());
			application.setdeviceById(deviceById);
			application.setidOfEndDevices(idOfEndDevices);
			application.setDeadlineInfo(deadlineInfo);
			application.setDeadlineInfomodule(deadlineInfomodule);
			application.setDeadlineInfomodule1(deadlineInfomodule1);
		    application.setAdditionalMipsInfo(additionalMipsInfo);
		    application.setplacement(placement);
		    application.setMobileCPUload(MobileCPUload);
		    
		    System.out.println(String.format("%-25s%s" ,"User Priority ASC ", application.getDeadlineInfo()));
			System.out.println(String.format("%-25s%s" ,"Module Tuble MIPS ",application.getAdditionalMipsInfo()));
		   /// System.out.println(String.format("%-25s%s" ,"Module Priority ",application.getDeadlineInfomodule()));
		    System.out.println(String.format("%-25s%s" ,"Module Priority1 ",application.getDeadlineInfomodule1()));

		    System.out.println("mobile CPU load "+ application.getMobileCPUload());
		    		
			Controller controller = null;
			ModuleMapping moduleMapping = ModuleMapping.createModuleMapping(); // initializing a module mapping			
			moduleMapping.addModuleToDevice("Cloud_Analytics", "cloud");
			for(FogDevice device : fogDevices){
				if(device.getName().startsWith("m"))
					moduleMapping.addModuleToDevice("Client", device.getName());
				}
			if(CLOUD){			 
				moduleMapping.addModuleToDevice("Caregiver", "cloud");
				moduleMapping.addModuleToDevice("Monitoring", "cloud");
				moduleMapping.addModuleToDevice("Filtering", "cloud");
				System.out.println("cloud only module placement, tuple mips= "+ mymips);
				controller = new ControllerEdgeward("master-controller", fogDevices, sensors, actuators);
				controller.submitApplication(application, 0, new ModulePlacementMapping(fogDevices, application,moduleMapping));
				}
			else {
				moduleMapping.addModuleToDevice("Caregiver", "proxy-server");
				switch (placement) { 
				case "Latency Module Placement":{			
					System.out.println("Per User Basic module placement");//", Tuple mips= "+ mymips
					controller = new Controller("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LatencyModulePlacementNear(fogDevices, sensors, actuators, application, moduleMapping));
					break;}	
				case "Latency Modified Module Placement":{
					System.out.println("Per User Modified module placement");
					controller = new Controller("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new ModulePlacementModified(fogDevices, sensors, actuators, application, moduleMapping));
					break;}
				case "Latency Differentiated Module Placement":{
					System.out.println("Per User Differentiated module placement, variable Module/Tuple mips ");
					controller = new Controller("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LatencyModulePlacementNear(fogDevices, sensors, actuators, application, moduleMapping));
					break;} //ModulePlacementDifferentiated
				case "Module Placement Edgeward":{
					System.out.println("Per module placement");
					controller = new ControllerEdgeward("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LModulePlacementEdgewards(fogDevices, sensors, actuators, application, moduleMapping));
					break;}
				case "Module Placement Edgeward Differentiated":{
					System.out.println("Per module Differentiated placement");
					controller = new ControllerEdgeward("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LModulePlacementEdgewards(fogDevices, sensors, actuators, application, moduleMapping));
					break;}
				}
				}
					
			TimeKeeper.getInstance().setSimulationStartTime(Calendar.getInstance().getTimeInMillis());
			CloudSim.startSimulation();
			CloudSim.stopSimulation();
			Log.printLine("ECG finished!");
		} catch (Exception e) {
			e.printStackTrace();
			Log.printLine("Unwanted errors happen");
		}
	}	
/****************************************************************************************
	 * Creates the fog devices in the physical topology of the simulation.
	 * @param userId
	 * @param appId
	 */
	private static void createFogDevices(int userId, String appId) {  // 44800
		FogDevice cloud = createFogDevice("cloud", 44800, 40000, 100, 10000, 0, 0.01, 16*103, 16*83.25); // creates the fog device Cloud at the apex of the hierarchy with level=0
		cloud.setParentId(-1);		 
		FogDevice proxy = createFogDevice("proxy-server", 16800 , 4000, 10000, 10000, 1, 0.0, 107.339, 83.4333); // 2800
		proxy.setParentId(cloud.getId()); // setting Cloud as parent of the Proxy Server
		proxy.setUplinkLatency(100); // latency of connection from Proxy Server to the Cloud is 100 ms		
		fogDevices.add(cloud);
		deviceById.put(cloud.getId(), cloud);
		fogDevices.add(proxy);
		deviceById.put(proxy.getId(), proxy);		
		for(int i=0;i<numOfDepts;i++){
			addGw(i+"", userId, appId, proxy.getId()); // adding a fog device for every Gateway in physical topology. The parent of each gateway is the Proxy Server
		}	
	}

	private static FogDevice addGw(String id, int userId, String appId, int parentId){
		FogDevice dept = createFogDevice("d-"+id, 2800, 4000, 10000, 10000, 2, 0.0, 107.339, 83.4333); //2800
		fogDevices.add(dept);
		deviceById.put(dept.getId(), dept);
		dept.setParentId(parentId);
		dept.setUplinkLatency(4); // latency of connection between gateways and proxy server is 4 ms
		for(int i=0;i<numOfMobilesPerDept;i++){
			String mobileId = id+"-"+i;
			FogDevice mobile = addMobile(mobileId, userId, appId, dept.getId()); // adding mobiles to the physical topology. Smartphones have been modeled as fog devices as well.
			mobile.setUplinkLatency(2); // latency of connection between the smartphone and proxy server is 4 ms
			fogDevices.add(mobile);
			deviceById.put(mobile.getId(), mobile);
		}
		return dept;
	}
	
	private static FogDevice addMobile(String id, int userId, String appId, int parentId){
		FogDevice mobile = createFogDevice("m-"+id, 1000, 1000, 10000, 270, 3, 0, 87.53, 82.44); //1000   
		mobile.setParentId(parentId);
		idOfEndDevices.add(mobile.getId());
		Sensor ecgsensor = new Sensor("s-"+id, "ECG", userId, appId, new DeterministicDistribution(ECG_TRANSMISSION_TIME)); // inter-transmission time of EEG sensor follows a deterministic distribution
		sensors.add(ecgsensor);
		Actuator display = new Actuator("a-"+id, userId, appId, "DISPLAY");
		actuators.add(display);
		ecgsensor.setGatewayDeviceId(mobile.getId());
		ecgsensor.setLatency(6.0);  // latency of connection between EEG sensors and the parent Smartphone is 6 ms
		display.setGatewayDeviceId(mobile.getId());
		display.setLatency(1.0);  // latency of connection between Display actuator and the parent Smartphone is 1 ms
		return mobile;
	}
	
/*****************************************************************************************
	 * Creates a vanilla fog device
	 * @param nodeName name of the device to be used in simulation
	 * @param mips MIPS
	 * @param ram RAM
	 * @param upBw uplink bandwidth
	 * @param downBw downlink bandwidth
	 * @param level hierarchy level of the device
	 * @param ratePerMips cost rate per MIPS used
	 * @param busyPower
	 * @param idlePower
	 * @return
	 */
	private static FogDevice createFogDevice(String nodeName, long mips,
			int ram, long upBw, long downBw, int level, double ratePerMips, double busyPower, double idlePower) {
		
		List<Pe> peList = new ArrayList<Pe>();
		// 3. Create PEs and add these into a list.
		peList.add(new Pe(0, new PeProvisionerOverbooking(mips))); // need to store Pe id and MIPS Rating
		
		int hostId = FogUtils.generateEntityId();
		long storage = 1000000; // host storage
		int bw = 10000;
		PowerHost host = new PowerHost(
				hostId,
				new RamProvisionerSimple(ram),
				new BwProvisionerOverbooking(bw),
				storage,
				peList,
				new StreamOperatorScheduler(peList),
				new FogLinearPowerModel(busyPower, idlePower)
			);

		List<Host> hostList = new ArrayList<Host>();
		hostList.add(host);

		String arch = "x86"; // system architecture
		String os = "Linux"; // operating system
		String vmm = "Xen";
		double time_zone = 10.0; // time zone this resource located
		double cost = 3.0; // the cost of using processing in this resource
		double costPerMem = 0.05; // the cost of using memory in this resource
		double costPerStorage = 0.001; // the cost of using storage in this	// resource
		double costPerBw = 0.0; // the cost of using bw in this resource
		LinkedList<Storage> storageList = new LinkedList<Storage>(); // we are not adding SAN devices by now

		FogDeviceCharacteristics characteristics = new FogDeviceCharacteristics(
				arch, os, vmm, host, time_zone, cost, costPerMem,
				costPerStorage, costPerBw);

		FogDevice fogdevice = null;
		try {
			fogdevice = new FogDevice(nodeName, characteristics, 
					new AppModuleAllocationPolicy(hostList), storageList, 10 , upBw, downBw, 0, ratePerMips); //10 : schedulingInterval  0 uplink  latency		
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		fogdevice.setLevel(level);
		return fogdevice;
	}

/******************************************************************************************
	 * Function to create the EEG Tractor Beam game application in the DDF model. 
	 * @param appId unique identifier of the application
	 * @param userId identifier of the user of the application
	 * @return
	 */
	@SuppressWarnings({"serial" })
	private static Application createApplication(String appId, int userId){
		
		Application application = Application.createApplication(appId, userId); // creates an empty application model (empty directed graph)
		
		// Adding modules (vertices) to the application model (directed graph)
		application.addAppModule("Client", 10, 2000, 1000,100,5); //250Name,int ram, int mips, long size, long bw, int modprty) size is the image size (MB)
		application.addAppModule("Filtering",10, 2000, 500, 100,4); //150
		application.addAppModule("Monitoring",10, 2000, 500,100,3); //150 
		application.addAppModule("Caregiver", 10, 2000,1000,100,2); // 150
		application.addAppModule("Cloud_Analytics",10, 3000,1000,250,1); //500("Cloud_Analytics",10, 500,1000,500,1); //
		
		// Connecting the application modules (vertices) in the application model (directed graph) with edges
		//source, destination, double tupleCpuLength, double tupleNwLength, String tupleType, int direction, int edgeType){
		application.addAppEdge("ECG", "Client", 2000, 500, "ECG", Tuple.UP, AppEdge.SENSOR);
		application.addAppEdge("Client", "Filtering", 2000, 500, "SENSOR_DATA", Tuple.UP, AppEdge.MODULE); //
		application.addAppEdge("Filtering", "Monitoring", mymips, 500, "FILTERED_DATA", Tuple.UP, AppEdge.MODULE); //
		application.addAppEdge("Monitoring", "Caregiver", mymips, 500, "ECG_REPORT", Tuple.UP, AppEdge.MODULE);  //
		application.addAppEdge("Caregiver", "Cloud_Analytics", mymips, 500, "DATA_OFFLOAD", Tuple.UP, AppEdge.MODULE); //		
		application.addAppEdge("Caregiver", "Client", mymips, 500, "State_Action", Tuple.DOWN, AppEdge.MODULE); //  
		application.addAppEdge("Client", "DISPLAY",2000, 500, "P_State_Action", Tuple.DOWN, AppEdge.ACTUATOR);  //
		application.addAppEdge("Cloud_Analytics", "Caregiver", 2000, 1000, "Advanced_Analytics", Tuple.DOWN, AppEdge.MODULE);  
		
 	    //Defining the input-output relationships (represented by selectivity) of the application modules. 
		application.addTupleMapping("Client", "ECG", "SENSOR_DATA", new FractionalSelectivity(1.0)); // 
		application.addTupleMapping("Client", "State_Action", "P_State_Action", new FractionalSelectivity(1.0)); //  
		application.addTupleMapping("Filtering", "SENSOR_DATA", "FILTERED_DATA", new FractionalSelectivity(1.0)); // 
		application.addTupleMapping("Monitoring", "FILTERED_DATA", "ECG_REPORT", new FractionalSelectivity(1.0)); //
		application.addTupleMapping("Caregiver", "ECG_REPORT", "DATA_OFFLOAD", new FractionalSelectivity(1.0)); //
		application.addTupleMapping("Caregiver", "ECG_REPORT", "State_Action", new FractionalSelectivity(1.0)); //
		application.addTupleMapping("Cloud_Analytics", "DATA_OFFLOAD", "Advanced_Analytics", new FractionalSelectivity(0.01)); //
	
		
		 // Defining application loops to monitor the latency of.
		//final AppLoop ONLY_CLOUD = new AppLoop(new ArrayList<String>(){{add("ECG");add("Client");add("Filtering");add("Monitoring");add("Caregiver");add("Client");add("DISPLAY");}}); //add("Cloud_Analytics");
        //List<AppLoop> loops = new ArrayList<AppLoop>(){{ add(ONLY_CLOUD);}};
		//final AppLoop ECG_REPORTING = new AppLoop(new ArrayList<String>(){{add("ECG");add("Client");add("Filtering");add("Monitoring");add("Caregiver");add("Client");add("DISPLAY");}});
        //List<AppLoop> loops = new ArrayList<AppLoop>(){{ add(ECG_REPORTING);}};
		final AppLoop ECG_ANALYTICS = new AppLoop(new ArrayList<String>(){{add("ECG");add("Client");add("Filtering");add("Monitoring");add("Caregiver");}});
        List<AppLoop> loops = new ArrayList<AppLoop>(){{add( ECG_ANALYTICS);}}; 
 		application.setLoops(loops);
		return application;
		}
///random number generators//////////////////////////////////////////////////////////
	private static double getvalue(double d, double e)  { 
	    Random r = new Random(); 
	    double randomValue = d + (e - d) *r.nextDouble(); 
	   // randomValue = r.nextDouble();
	    return randomValue; 
	  } 
	private static Integer getvalue(int min, int max) { 
	    Random r = new Random(); 
	    Integer randomValue = min + r.nextInt()%(max - min); 
	   // randomValue = r.nextInt(max);
	    return randomValue; 
	  }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//scheduled cloudlet processing =30,100,200,300,500 mips for filtering monitoring caregiver  
//scheduled cloudlet processing = 1000  for client and cloudanalytics modules
// mobile id, need Modulename executed with max delay (3:5)
//static Pair<String, Double> moduledeadline = new Pair <String, Double>(null,null);  // mobile id need deadline double
//static List<Pair<String, Double>> moduledeadline = new ArrayList<Pair <String, Double>>();


//if(placement.equals("Latency Differentiated Module Placement")) {		
//System.out.println(String.format("%-30s%s" ,"Per_User Differentiated Module Placement, " ," variable mips between 50 mips, "+  mymips+ " for all modules except cloud plus 1000 mips"));
//}		
//else if(placement.equals("Module Placement Edgeward")) {
//System.out.println(String.format("%-30s%20s%s%30s%10s%s" ,"Per_Module Edgeward Placement","const mips= " , mymips));
//System.out.println("Per_Module Placement,  Tuple's mips= " + mymips);
//}
///else 
//placement=="Latency Module Placement" 
//System.out.println(String.format("%-30s%20s%s%30s%10s%s" ,"Per_User Basic Module Placement","const mips= " , mymips));
//System.out.println("Per_User Basic Module Placement,  const mips= " + mymips);		

//System.out.println("Application Module mips: Client = Filtering = Monitoring = Caregiver = 300 mips , Cloud_Analytics = 600 mips");
//System.out.println("Migration Condition: Mobile Utilization >= 0.3, Proxy/Dept Utilization >= 0.9" );  //, RESOURCE_MANAGE_INTERVAL = 100 ");
//System.out.println("Enhanced Migration Conditions , RESOURCE_MANAGE_INTERVAL = 10 ");
//System.out.println("fog device scheduling interval = 10,  Application module scheduling interval = 300  ");	

//moduledeadline.put("Client", (x+ 15.0000000000000000));
//deadlineInfomodule.put(id,moduledeadline);
//moduledeadline.put("Caregiver", x);
//deadlineInfomodule.put(id,moduledeadline);				
//System.out.println("deadlineInfomodule  "+ deadlineInfomodule);
//deadlineInfomodule.put(id,moduledeadlinelist);				
//moduledeadline.clear();

/*
for(Integer id : idOfEndDevices){
	if (placement.equals("Latency Differentiated Module Placement")) {
		Integer x= getvalue(50, 500);//mymips);
		x= Math.abs(x);
		additionalMipsInfo.put(id, (double)x);  //getvalue(0,mymips)
		}
	else
		additionalMipsInfo.put(id, (double)mymips);
}
*/
/*else if(device.getName().startsWith("d")){
moduleMapping.addModuleToDevice("Filtering", device.getName());
moduleMapping.addModuleToDevice("Monitoring", device.getName());				
} */
//Controller controller = new Controller("master-controller", fogDevices, sensors, actuators);
//controller.submitApplication(application, 0, new ModulePlacementOnlyCloud(fogDevices, sensors, actuators, application));
//controller.submitApplication(application, 0, new LatencyModulePlacement(fogDevices, sensors, actuators, application, moduleMapping));
//controller.submitApplication(application, 0, new LatencyModifiedModulePlacementNew(fogDevices, sensors, actuators, application, moduleMapping));
 //LModulePlacementEdgewards  // LatencyModulePlacementNear

//TRY FogDevice cloud = createFogDevice("cloud", 448000000, 40000000, 100000, 10000000, 0, 0.01, 16*103, 16*83.25); // creates the fog device Cloud at the apex of the hierarchy with level=0
//FogDevice cloud = createFogDevice("cloud", 4480000, 4000000, 100, 10000, 0, 0.01, 16*103, 16*83.25); // creates the fog device Cloud at the apex of the hierarchy with level=0
//FogDevice proxy = createFogDevice("proxy-server", 2800, 4000, 10000, 10000, 1, 0.0, 107.339, 83.4333);

//peList.add(new Pe(0, new PeProvisionerSimple(mips))); // need to store Pe id and MIPS Rating


/*
application.addAppModule("Client", 10, 300, 1000,100,5); // adding module Client to the application model
application.addAppModule("Filtering",10, 300, 1000, 100,4); //
application.addAppModule("Monitoring",10, 300, 1000,100,3); // 
application.addAppModule("Caregiver", 10, 300,1000,100,2); // 
application.addAppModule("Cloud_Analytics",10, 600,1000,250,1); //("Cloud_Analytics",10, 500,1000,500,1); //
*/
/*application.addAppEdge("ECG", "Client", 3000, 1000, "ECG", Tuple.UP, AppEdge.SENSOR);
application.addAppEdge("Client", "Filtering", 3000, 500, "SENSOR_DATA", Tuple.UP, AppEdge.MODULE); //
application.addAppEdge("Filtering", "Monitoring", (30+ mymips), 500, "FILTERED_DATA", Tuple.UP, AppEdge.MODULE); // 
application.addAppEdge("Monitoring", "Cloud_Analytics", 1000, 500, "DATA_OFFLOAD", Tuple.UP, AppEdge.MODULE); // 
application.addAppEdge("Monitoring", "Caregiver", (60+ mymips) , 500, "ECG_REPORT", Tuple.UP, AppEdge.MODULE);  // 
application.addAppEdge("Cloud_Analytics", "Caregiver", 3500, 1000, "Advanced_Analytics", Tuple.DOWN, AppEdge.MODULE);  // 
application.addAppEdge("Caregiver", "Client", 1000 , 500, "State_Action", Tuple.DOWN, AppEdge.MODULE); // 
application.addAppEdge("Client", "DISPLAY",1000, 500, "P_State_Action", Tuple.DOWN, AppEdge.ACTUATOR);  //
 */
//application.addAppEdge("Caregiver", "Cloud_Analytics", 3000, 1000, "DECISION", Tuple.UP, AppEdge.MODULE); //
// application.addTupleMapping("Cloud_Analytics", "DECISION", "Advanced_Analytics", new FractionalSelectivity(0.001)); //
//final AppLoop HBR_Analytics = new AppLoop(new ArrayList<String>(){{add("HBR"); add("Client"); add("Monitoring"); add("Cloud_Analytics"); add("Caregiver"); add("Client"); add("DISPLAY");}});

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10076, count -3525, length 26106
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-10-15 12:36:34.381
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.StringIndexOutOfBoundsException: offset 10076, count -3525, length 26106
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:324)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10076, count -3525, length 26106
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	... 16 more
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10076, count -3525, length 26106
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2020-10-15 12:36:34.381
!MESSAGE offset 10076, count -3525, length 26106
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10076, count -3525, length 26106
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2020-10-15 12:36:34.381
!MESSAGE offset 10076, count -3525, length 26106
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10076, count -3525, length 26106
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-10-15 12:36:34.382
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.StringIndexOutOfBoundsException: offset 10076, count -3525, length 26106
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:324)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10076, count -3525, length 26106
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	... 16 more
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10076, count -3525, length 26106
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2020-10-15 12:36:34.382
!MESSAGE offset 10076, count -3525, length 26106
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10076, count -3525, length 26106
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-10-15 12:36:34.391
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10076, count -3525, length 26106
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-10-15 12:36:34.392
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10076, count -3525, length 26106
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-10-15 12:36:37.898
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
package org.fog.test.perfeval;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.stream.Collectors;
import org.apache.commons.math3.util.Pair;
import org.cloudbus.cloudsim.Host;
import org.cloudbus.cloudsim.Log;
import org.cloudbus.cloudsim.Pe;
import org.cloudbus.cloudsim.Storage;
import org.cloudbus.cloudsim.core.CloudSim;
import org.cloudbus.cloudsim.power.PowerHost;
import org.cloudbus.cloudsim.provisioners.PeProvisionerSimple;
import org.cloudbus.cloudsim.provisioners.RamProvisionerSimple;
import org.cloudbus.cloudsim.sdn.overbooking.BwProvisionerOverbooking;
import org.cloudbus.cloudsim.sdn.overbooking.PeProvisionerOverbooking;
import org.fog.application.AppEdge;
import org.fog.application.AppLoop;
import org.fog.application.Application;
import org.fog.application.selectivity.FractionalSelectivity;
import org.fog.entities.Actuator;
import org.fog.entities.FogBroker;
import org.fog.entities.FogDevice;
import org.fog.entities.FogDeviceCharacteristics;
import org.fog.entities.Sensor;
import org.fog.entities.Tuple;
import org.fog.placement.Controller;
import org.fog.placement.ControllerEdgeward;
import org.fog.placement.LModulePlacementEdgewards;
import org.fog.placement.LatencyModulePlacementNear;
import org.fog.placement.ModuleMapping;
import org.fog.placement.ModulePlacementDifferentiated;
import org.fog.placement.ModulePlacementEdgewards;
import org.fog.placement.ModulePlacementMapping;
import org.fog.placement.ModulePlacementModified;
import org.fog.placement.ModulePlacementOnlyCloud;
import org.fog.policy.AppModuleAllocationPolicy;
import org.fog.scheduler.StreamOperatorScheduler;
import org.fog.utils.Config;
import org.fog.utils.FogLinearPowerModel;
import org.fog.utils.FogUtils;
import org.fog.utils.TimeKeeper;
import org.fog.utils.distribution.DeterministicDistribution;

/**
 * Simulation setup for  ECG
 * @author Ragaa Shehab
 *
 */ //updateTimingsOnReceipt - checkCloudletCompletion --tupleEndedExecutionUser
public class ECG {
	static List<FogDevice> fogDevices = new ArrayList<FogDevice>();
	static List<Sensor> sensors = new ArrayList<Sensor>();
	static List<Actuator> actuators = new ArrayList<Actuator>();
	static Map<Integer,FogDevice> deviceById = new HashMap<Integer,FogDevice>();	
	static List<Integer> idOfEndDevices = new ArrayList<Integer>();
	static Map<Integer, Double> deadlineInfo = new	HashMap<Integer, Double>();  // mobile id has priority
	static Map<Integer, Double> additionalMipsInfo = new HashMap<Integer, Double>(); // mobile id need tuple mips
	static Map<Integer, Map<String, Double>> deadlineInfomodule = new HashMap<Integer, Map<String,Double>>();  // mobile id has modulename with module priority
	static Map<Integer,List<Map<String, Double>>> deadlineInfomodule1 = new HashMap<Integer, List<Map<String,Double>>>();  // mobile id has modulename with module priority

	static boolean CLOUD = false;
	static int numOfDepts = 1;
	static int numOfMobilesPerDept =5;
	static double ECG_TRANSMISSION_TIME = 50.0 ; // 50.0;   //100, 50, 25 ms   100 //10s= 10000
	static public int mymips= 2000;     
	//static String placement = "Latency Module Placement"; 
	static String placement = "Latency Differentiated Module Placement"; 
	//static String placement = "Module Placement Edgeward";
	//static String placement = "Module Placement Edgeward Differentiated";
	//static String placement = "Latency Modified Module Placement";
	static double MobileCPUload= 0.1;
	
	public static void main(String[] args) {
		Log.print("Starting ECG transmission");	Log.print("             ECG transmission time ms: "); Log.print(ECG_TRANSMISSION_TIME);
		Log.print("     Depts/Mobiles =  "); Log.print (numOfDepts);Log.print("/"); Log.printLine (numOfMobilesPerDept);
		System.out.println("analytics VM mips  2000, Fog device mips: mobile 1000, dept  2800, proxy 16800" ); 

		
		try {
			Log.disable(); 	
			//Config.MAX_SIMULATION_TIME= 100000;
			int num_user = 1; // number of cloud users
			Calendar calendar = Calendar.getInstance();
			boolean trace_flag = false; // mean trace events
			CloudSim.init(num_user, calendar, trace_flag);						
			String appId = "ECG"; 
			FogBroker broker = new FogBroker("broker");			
			createFogDevices(broker.getId(), appId);
			
			Map<String, Double> moduledeadline= new HashMap<String, Double>();
			Map<String, Double> moduledeadline1;
			List<Map<String, Double>> moduledeadline1List;

			for(Integer id : idOfEndDevices){
				Double x= getvalue(5.00, 40.00);
				Double t1= 10.00; Double t2= 5.00; //Double t3= 5.00;
				deadlineInfo.put(id, x);
				
				if (placement.equals("Latency Differentiated Module Placement")||placement.equals("Module Placement Edgeward Differentiated")) {
						if((5.00 < x)&& (x < 10.00)) x=5.00;
						if(10.00 < x)&& (x < 15.00) x=10.00;
						if(15.00 <  x)&& (x < 20.00) x=20.00;
						if(20.00 < x)&& (x < 30.00) x=30.00;
						if(30.00 < x < 40.00) x=40.00;
					
							
						
					additionalMipsInfo.put(id, x*100); //1000
					moduledeadline1=  new HashMap<String,Double>();
					moduledeadline1List= new ArrayList<Map<String, Double>>();
					moduledeadline1.put("Client", x*100);
					moduledeadline1.put("Filtering", x*100);
					moduledeadline1.put("Monitoring", x*100);
					moduledeadline1.put("Caregiver", x*100);
					moduledeadline1.put("Cloud_Analytics", x*100);
					moduledeadline1List.add(moduledeadline1);
					deadlineInfomodule1.put(id, moduledeadline1List);
				}
				else {
					additionalMipsInfo.put(id, (double)mymips);
					moduledeadline1=  new HashMap<String,Double>();
					moduledeadline1List= new ArrayList<Map<String, Double>>();
					moduledeadline1.put("Client", (double)mymips);
					moduledeadline1.put("Filtering", (double)mymips);
					moduledeadline1.put("Monitoring", (double)mymips);
					moduledeadline1.put("Caregiver", (double)mymips);
					moduledeadline1.put("Cloud_Analytics", (double)mymips);
					moduledeadline1List.add(moduledeadline1);
					deadlineInfomodule1.put(id, moduledeadline1List);
				}
				moduledeadline.put("Filtering", (x+t1));
				deadlineInfomodule.put(id,moduledeadline);
				moduledeadline.put("Monitoring", (x+ t2));
				deadlineInfomodule.put(id,moduledeadline);
			}	
			
			deadlineInfo=deadlineInfo.entrySet()
		             .stream().sorted(Map.Entry.comparingByValue())
		             .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -> e1, LinkedHashMap::new));			
				
			Application application = createApplication(appId, broker.getId());
			application.setUserId(broker.getId());
			application.setdeviceById(deviceById);
			application.setidOfEndDevices(idOfEndDevices);
			application.setDeadlineInfo(deadlineInfo);
			application.setDeadlineInfomodule(deadlineInfomodule);
			application.setDeadlineInfomodule1(deadlineInfomodule1);
		    application.setAdditionalMipsInfo(additionalMipsInfo);
		    application.setplacement(placement);
		    application.setMobileCPUload(MobileCPUload);
		    
		    System.out.println(String.format("%-25s%s" ,"User Priority ASC ", application.getDeadlineInfo()));
			System.out.println(String.format("%-25s%s" ,"Module Tuble MIPS ",application.getAdditionalMipsInfo()));
		   /// System.out.println(String.format("%-25s%s" ,"Module Priority ",application.getDeadlineInfomodule()));
		    System.out.println(String.format("%-25s%s" ,"Module Priority1 ",application.getDeadlineInfomodule1()));

		    System.out.println("mobile CPU load "+ application.getMobileCPUload());
		    		
			Controller controller = null;
			ModuleMapping moduleMapping = ModuleMapping.createModuleMapping(); // initializing a module mapping			
			moduleMapping.addModuleToDevice("Cloud_Analytics", "cloud");
			for(FogDevice device : fogDevices){
				if(device.getName().startsWith("m"))
					moduleMapping.addModuleToDevice("Client", device.getName());
				}
			if(CLOUD){			 
				moduleMapping.addModuleToDevice("Caregiver", "cloud");
				moduleMapping.addModuleToDevice("Monitoring", "cloud");
				moduleMapping.addModuleToDevice("Filtering", "cloud");
				System.out.println("cloud only module placement, tuple mips= "+ mymips);
				controller = new ControllerEdgeward("master-controller", fogDevices, sensors, actuators);
				controller.submitApplication(application, 0, new ModulePlacementMapping(fogDevices, application,moduleMapping));
				}
			else {
				moduleMapping.addModuleToDevice("Caregiver", "proxy-server");
				switch (placement) { 
				case "Latency Module Placement":{			
					System.out.println("Per User Basic module placement");//", Tuple mips= "+ mymips
					controller = new Controller("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LatencyModulePlacementNear(fogDevices, sensors, actuators, application, moduleMapping));
					break;}	
				case "Latency Modified Module Placement":{
					System.out.println("Per User Modified module placement");
					controller = new Controller("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new ModulePlacementModified(fogDevices, sensors, actuators, application, moduleMapping));
					break;}
				case "Latency Differentiated Module Placement":{
					System.out.println("Per User Differentiated module placement, variable Module/Tuple mips ");
					controller = new Controller("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LatencyModulePlacementNear(fogDevices, sensors, actuators, application, moduleMapping));
					break;} //ModulePlacementDifferentiated
				case "Module Placement Edgeward":{
					System.out.println("Per module placement");
					controller = new ControllerEdgeward("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LModulePlacementEdgewards(fogDevices, sensors, actuators, application, moduleMapping));
					break;}
				case "Module Placement Edgeward Differentiated":{
					System.out.println("Per module Differentiated placement");
					controller = new ControllerEdgeward("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LModulePlacementEdgewards(fogDevices, sensors, actuators, application, moduleMapping));
					break;}
				}
				}
					
			TimeKeeper.getInstance().setSimulationStartTime(Calendar.getInstance().getTimeInMillis());
			CloudSim.startSimulation();
			CloudSim.stopSimulation();
			Log.printLine("ECG finished!");
		} catch (Exception e) {
			e.printStackTrace();
			Log.printLine("Unwanted errors happen");
		}
	}	
/****************************************************************************************
	 * Creates the fog devices in the physical topology of the simulation.
	 * @param userId
	 * @param appId
	 */
	private static void createFogDevices(int userId, String appId) {  // 44800
		FogDevice cloud = createFogDevice("cloud", 44800, 40000, 100, 10000, 0, 0.01, 16*103, 16*83.25); // creates the fog device Cloud at the apex of the hierarchy with level=0
		cloud.setParentId(-1);		 
		FogDevice proxy = createFogDevice("proxy-server", 16800 , 4000, 10000, 10000, 1, 0.0, 107.339, 83.4333); // 2800
		proxy.setParentId(cloud.getId()); // setting Cloud as parent of the Proxy Server
		proxy.setUplinkLatency(100); // latency of connection from Proxy Server to the Cloud is 100 ms		
		fogDevices.add(cloud);
		deviceById.put(cloud.getId(), cloud);
		fogDevices.add(proxy);
		deviceById.put(proxy.getId(), proxy);		
		for(int i=0;i<numOfDepts;i++){
			addGw(i+"", userId, appId, proxy.getId()); // adding a fog device for every Gateway in physical topology. The parent of each gateway is the Proxy Server
		}	
	}

	private static FogDevice addGw(String id, int userId, String appId, int parentId){
		FogDevice dept = createFogDevice("d-"+id, 2800, 4000, 10000, 10000, 2, 0.0, 107.339, 83.4333); //2800
		fogDevices.add(dept);
		deviceById.put(dept.getId(), dept);
		dept.setParentId(parentId);
		dept.setUplinkLatency(4); // latency of connection between gateways and proxy server is 4 ms
		for(int i=0;i<numOfMobilesPerDept;i++){
			String mobileId = id+"-"+i;
			FogDevice mobile = addMobile(mobileId, userId, appId, dept.getId()); // adding mobiles to the physical topology. Smartphones have been modeled as fog devices as well.
			mobile.setUplinkLatency(2); // latency of connection between the smartphone and proxy server is 4 ms
			fogDevices.add(mobile);
			deviceById.put(mobile.getId(), mobile);
		}
		return dept;
	}
	
	private static FogDevice addMobile(String id, int userId, String appId, int parentId){
		FogDevice mobile = createFogDevice("m-"+id, 1000, 1000, 10000, 270, 3, 0, 87.53, 82.44); //1000   
		mobile.setParentId(parentId);
		idOfEndDevices.add(mobile.getId());
		Sensor ecgsensor = new Sensor("s-"+id, "ECG", userId, appId, new DeterministicDistribution(ECG_TRANSMISSION_TIME)); // inter-transmission time of EEG sensor follows a deterministic distribution
		sensors.add(ecgsensor);
		Actuator display = new Actuator("a-"+id, userId, appId, "DISPLAY");
		actuators.add(display);
		ecgsensor.setGatewayDeviceId(mobile.getId());
		ecgsensor.setLatency(6.0);  // latency of connection between EEG sensors and the parent Smartphone is 6 ms
		display.setGatewayDeviceId(mobile.getId());
		display.setLatency(1.0);  // latency of connection between Display actuator and the parent Smartphone is 1 ms
		return mobile;
	}
	
/*****************************************************************************************
	 * Creates a vanilla fog device
	 * @param nodeName name of the device to be used in simulation
	 * @param mips MIPS
	 * @param ram RAM
	 * @param upBw uplink bandwidth
	 * @param downBw downlink bandwidth
	 * @param level hierarchy level of the device
	 * @param ratePerMips cost rate per MIPS used
	 * @param busyPower
	 * @param idlePower
	 * @return
	 */
	private static FogDevice createFogDevice(String nodeName, long mips,
			int ram, long upBw, long downBw, int level, double ratePerMips, double busyPower, double idlePower) {
		
		List<Pe> peList = new ArrayList<Pe>();
		// 3. Create PEs and add these into a list.
		peList.add(new Pe(0, new PeProvisionerOverbooking(mips))); // need to store Pe id and MIPS Rating
		
		int hostId = FogUtils.generateEntityId();
		long storage = 1000000; // host storage
		int bw = 10000;
		PowerHost host = new PowerHost(
				hostId,
				new RamProvisionerSimple(ram),
				new BwProvisionerOverbooking(bw),
				storage,
				peList,
				new StreamOperatorScheduler(peList),
				new FogLinearPowerModel(busyPower, idlePower)
			);

		List<Host> hostList = new ArrayList<Host>();
		hostList.add(host);

		String arch = "x86"; // system architecture
		String os = "Linux"; // operating system
		String vmm = "Xen";
		double time_zone = 10.0; // time zone this resource located
		double cost = 3.0; // the cost of using processing in this resource
		double costPerMem = 0.05; // the cost of using memory in this resource
		double costPerStorage = 0.001; // the cost of using storage in this	// resource
		double costPerBw = 0.0; // the cost of using bw in this resource
		LinkedList<Storage> storageList = new LinkedList<Storage>(); // we are not adding SAN devices by now

		FogDeviceCharacteristics characteristics = new FogDeviceCharacteristics(
				arch, os, vmm, host, time_zone, cost, costPerMem,
				costPerStorage, costPerBw);

		FogDevice fogdevice = null;
		try {
			fogdevice = new FogDevice(nodeName, characteristics, 
					new AppModuleAllocationPolicy(hostList), storageList, 10 , upBw, downBw, 0, ratePerMips); //10 : schedulingInterval  0 uplink  latency		
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		fogdevice.setLevel(level);
		return fogdevice;
	}

/******************************************************************************************
	 * Function to create the EEG Tractor Beam game application in the DDF model. 
	 * @param appId unique identifier of the application
	 * @param userId identifier of the user of the application
	 * @return
	 */
	@SuppressWarnings({"serial" })
	private static Application createApplication(String appId, int userId){
		
		Application application = Application.createApplication(appId, userId); // creates an empty application model (empty directed graph)
		
		// Adding modules (vertices) to the application model (directed graph)
		application.addAppModule("Client", 10, 2000, 1000,100,5); //250Name,int ram, int mips, long size, long bw, int modprty) size is the image size (MB)
		application.addAppModule("Filtering",10, 2000, 500, 100,4); //150
		application.addAppModule("Monitoring",10, 2000, 500,100,3); //150 
		application.addAppModule("Caregiver", 10, 2000,1000,100,2); // 150
		application.addAppModule("Cloud_Analytics",10, 3000,1000,250,1); //500("Cloud_Analytics",10, 500,1000,500,1); //
		
		// Connecting the application modules (vertices) in the application model (directed graph) with edges
		//source, destination, double tupleCpuLength, double tupleNwLength, String tupleType, int direction, int edgeType){
		application.addAppEdge("ECG", "Client", 2000, 500, "ECG", Tuple.UP, AppEdge.SENSOR);
		application.addAppEdge("Client", "Filtering", 2000, 500, "SENSOR_DATA", Tuple.UP, AppEdge.MODULE); //
		application.addAppEdge("Filtering", "Monitoring", mymips, 500, "FILTERED_DATA", Tuple.UP, AppEdge.MODULE); //
		application.addAppEdge("Monitoring", "Caregiver", mymips, 500, "ECG_REPORT", Tuple.UP, AppEdge.MODULE);  //
		application.addAppEdge("Caregiver", "Cloud_Analytics", mymips, 500, "DATA_OFFLOAD", Tuple.UP, AppEdge.MODULE); //		
		application.addAppEdge("Caregiver", "Client", mymips, 500, "State_Action", Tuple.DOWN, AppEdge.MODULE); //  
		application.addAppEdge("Client", "DISPLAY",2000, 500, "P_State_Action", Tuple.DOWN, AppEdge.ACTUATOR);  //
		application.addAppEdge("Cloud_Analytics", "Caregiver", 2000, 1000, "Advanced_Analytics", Tuple.DOWN, AppEdge.MODULE);  
		
 	    //Defining the input-output relationships (represented by selectivity) of the application modules. 
		application.addTupleMapping("Client", "ECG", "SENSOR_DATA", new FractionalSelectivity(1.0)); // 
		application.addTupleMapping("Client", "State_Action", "P_State_Action", new FractionalSelectivity(1.0)); //  
		application.addTupleMapping("Filtering", "SENSOR_DATA", "FILTERED_DATA", new FractionalSelectivity(1.0)); // 
		application.addTupleMapping("Monitoring", "FILTERED_DATA", "ECG_REPORT", new FractionalSelectivity(1.0)); //
		application.addTupleMapping("Caregiver", "ECG_REPORT", "DATA_OFFLOAD", new FractionalSelectivity(1.0)); //
		application.addTupleMapping("Caregiver", "ECG_REPORT", "State_Action", new FractionalSelectivity(1.0)); //
		application.addTupleMapping("Cloud_Analytics", "DATA_OFFLOAD", "Advanced_Analytics", new FractionalSelectivity(0.01)); //
	
		
		 // Defining application loops to monitor the latency of.
		//final AppLoop ONLY_CLOUD = new AppLoop(new ArrayList<String>(){{add("ECG");add("Client");add("Filtering");add("Monitoring");add("Caregiver");add("Client");add("DISPLAY");}}); //add("Cloud_Analytics");
        //List<AppLoop> loops = new ArrayList<AppLoop>(){{ add(ONLY_CLOUD);}};
		//final AppLoop ECG_REPORTING = new AppLoop(new ArrayList<String>(){{add("ECG");add("Client");add("Filtering");add("Monitoring");add("Caregiver");add("Client");add("DISPLAY");}});
        //List<AppLoop> loops = new ArrayList<AppLoop>(){{ add(ECG_REPORTING);}};
		final AppLoop ECG_ANALYTICS = new AppLoop(new ArrayList<String>(){{add("ECG");add("Client");add("Filtering");add("Monitoring");add("Caregiver");}});
        List<AppLoop> loops = new ArrayList<AppLoop>(){{add( ECG_ANALYTICS);}}; 
 		application.setLoops(loops);
		return application;
		}
///random number generators//////////////////////////////////////////////////////////
	private static double getvalue(double d, double e)  { 
	    Random r = new Random(); 
	    double randomValue = d + (e - d) *r.nextDouble(); 
	   // randomValue = r.nextDouble();
	    return randomValue; 
	  } 
	private static Integer getvalue(int min, int max) { 
	    Random r = new Random(); 
	    Integer randomValue = min + r.nextInt()%(max - min); 
	   // randomValue = r.nextInt(max);
	    return randomValue; 
	  }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//scheduled cloudlet processing =30,100,200,300,500 mips for filtering monitoring caregiver  
//scheduled cloudlet processing = 1000  for client and cloudanalytics modules
// mobile id, need Modulename executed with max delay (3:5)
//static Pair<String, Double> moduledeadline = new Pair <String, Double>(null,null);  // mobile id need deadline double
//static List<Pair<String, Double>> moduledeadline = new ArrayList<Pair <String, Double>>();


//if(placement.equals("Latency Differentiated Module Placement")) {		
//System.out.println(String.format("%-30s%s" ,"Per_User Differentiated Module Placement, " ," variable mips between 50 mips, "+  mymips+ " for all modules except cloud plus 1000 mips"));
//}		
//else if(placement.equals("Module Placement Edgeward")) {
//System.out.println(String.format("%-30s%20s%s%30s%10s%s" ,"Per_Module Edgeward Placement","const mips= " , mymips));
//System.out.println("Per_Module Placement,  Tuple's mips= " + mymips);
//}
///else 
//placement=="Latency Module Placement" 
//System.out.println(String.format("%-30s%20s%s%30s%10s%s" ,"Per_User Basic Module Placement","const mips= " , mymips));
//System.out.println("Per_User Basic Module Placement,  const mips= " + mymips);		

//System.out.println("Application Module mips: Client = Filtering = Monitoring = Caregiver = 300 mips , Cloud_Analytics = 600 mips");
//System.out.println("Migration Condition: Mobile Utilization >= 0.3, Proxy/Dept Utilization >= 0.9" );  //, RESOURCE_MANAGE_INTERVAL = 100 ");
//System.out.println("Enhanced Migration Conditions , RESOURCE_MANAGE_INTERVAL = 10 ");
//System.out.println("fog device scheduling interval = 10,  Application module scheduling interval = 300  ");	

//moduledeadline.put("Client", (x+ 15.0000000000000000));
//deadlineInfomodule.put(id,moduledeadline);
//moduledeadline.put("Caregiver", x);
//deadlineInfomodule.put(id,moduledeadline);				
//System.out.println("deadlineInfomodule  "+ deadlineInfomodule);
//deadlineInfomodule.put(id,moduledeadlinelist);				
//moduledeadline.clear();

/*
for(Integer id : idOfEndDevices){
	if (placement.equals("Latency Differentiated Module Placement")) {
		Integer x= getvalue(50, 500);//mymips);
		x= Math.abs(x);
		additionalMipsInfo.put(id, (double)x);  //getvalue(0,mymips)
		}
	else
		additionalMipsInfo.put(id, (double)mymips);
}
*/
/*else if(device.getName().startsWith("d")){
moduleMapping.addModuleToDevice("Filtering", device.getName());
moduleMapping.addModuleToDevice("Monitoring", device.getName());				
} */
//Controller controller = new Controller("master-controller", fogDevices, sensors, actuators);
//controller.submitApplication(application, 0, new ModulePlacementOnlyCloud(fogDevices, sensors, actuators, application));
//controller.submitApplication(application, 0, new LatencyModulePlacement(fogDevices, sensors, actuators, application, moduleMapping));
//controller.submitApplication(application, 0, new LatencyModifiedModulePlacementNew(fogDevices, sensors, actuators, application, moduleMapping));
 //LModulePlacementEdgewards  // LatencyModulePlacementNear

//TRY FogDevice cloud = createFogDevice("cloud", 448000000, 40000000, 100000, 10000000, 0, 0.01, 16*103, 16*83.25); // creates the fog device Cloud at the apex of the hierarchy with level=0
//FogDevice cloud = createFogDevice("cloud", 4480000, 4000000, 100, 10000, 0, 0.01, 16*103, 16*83.25); // creates the fog device Cloud at the apex of the hierarchy with level=0
//FogDevice proxy = createFogDevice("proxy-server", 2800, 4000, 10000, 10000, 1, 0.0, 107.339, 83.4333);

//peList.add(new Pe(0, new PeProvisionerSimple(mips))); // need to store Pe id and MIPS Rating


/*
application.addAppModule("Client", 10, 300, 1000,100,5); // adding module Client to the application model
application.addAppModule("Filtering",10, 300, 1000, 100,4); //
application.addAppModule("Monitoring",10, 300, 1000,100,3); // 
application.addAppModule("Caregiver", 10, 300,1000,100,2); // 
application.addAppModule("Cloud_Analytics",10, 600,1000,250,1); //("Cloud_Analytics",10, 500,1000,500,1); //
*/
/*application.addAppEdge("ECG", "Client", 3000, 1000, "ECG", Tuple.UP, AppEdge.SENSOR);
application.addAppEdge("Client", "Filtering", 3000, 500, "SENSOR_DATA", Tuple.UP, AppEdge.MODULE); //
application.addAppEdge("Filtering", "Monitoring", (30+ mymips), 500, "FILTERED_DATA", Tuple.UP, AppEdge.MODULE); // 
application.addAppEdge("Monitoring", "Cloud_Analytics", 1000, 500, "DATA_OFFLOAD", Tuple.UP, AppEdge.MODULE); // 
application.addAppEdge("Monitoring", "Caregiver", (60+ mymips) , 500, "ECG_REPORT", Tuple.UP, AppEdge.MODULE);  // 
application.addAppEdge("Cloud_Analytics", "Caregiver", 3500, 1000, "Advanced_Analytics", Tuple.DOWN, AppEdge.MODULE);  // 
application.addAppEdge("Caregiver", "Client", 1000 , 500, "State_Action", Tuple.DOWN, AppEdge.MODULE); // 
application.addAppEdge("Client", "DISPLAY",1000, 500, "P_State_Action", Tuple.DOWN, AppEdge.ACTUATOR);  //
 */
//application.addAppEdge("Caregiver", "Cloud_Analytics", 3000, 1000, "DECISION", Tuple.UP, AppEdge.MODULE); //
// application.addTupleMapping("Cloud_Analytics", "DECISION", "Advanced_Analytics", new FractionalSelectivity(0.001)); //
//final AppLoop HBR_Analytics = new AppLoop(new ArrayList<String>(){{add("HBR"); add("Client"); add("Monitoring"); add("Cloud_Analytics"); add("Caregiver"); add("Client"); add("DISPLAY");}});

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10075, count -3525, length 26105
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-10-15 12:36:37.899
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.StringIndexOutOfBoundsException: offset 10075, count -3525, length 26105
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:324)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10075, count -3525, length 26105
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	... 16 more
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10075, count -3525, length 26105
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2020-10-15 12:36:37.899
!MESSAGE offset 10075, count -3525, length 26105
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10075, count -3525, length 26105
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2020-10-15 12:36:37.899
!MESSAGE offset 10075, count -3525, length 26105
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10075, count -3525, length 26105
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-10-15 12:36:37.900
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.StringIndexOutOfBoundsException: offset 10075, count -3525, length 26105
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:324)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10075, count -3525, length 26105
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	... 16 more
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10075, count -3525, length 26105
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2020-10-15 12:36:37.900
!MESSAGE offset 10075, count -3525, length 26105
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10075, count -3525, length 26105
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-10-15 12:36:37.910
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10075, count -3525, length 26105
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-10-15 12:36:37.911
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10075, count -3525, length 26105
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-10-15 12:36:40.071
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10075, count -3525, length 26105
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-10-15 12:36:40.072
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10075, count -3525, length 26105
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-10-15 12:36:40.149
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10075, count -3525, length 26105
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-10-15 12:36:40.151
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10075, count -3525, length 26105
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-10-15 12:36:40.834
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10075, count -3525, length 26105
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-10-15 12:36:40.835
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10075, count -3525, length 26105
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-10-15 12:36:42.415
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
package org.fog.test.perfeval;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.stream.Collectors;
import org.apache.commons.math3.util.Pair;
import org.cloudbus.cloudsim.Host;
import org.cloudbus.cloudsim.Log;
import org.cloudbus.cloudsim.Pe;
import org.cloudbus.cloudsim.Storage;
import org.cloudbus.cloudsim.core.CloudSim;
import org.cloudbus.cloudsim.power.PowerHost;
import org.cloudbus.cloudsim.provisioners.PeProvisionerSimple;
import org.cloudbus.cloudsim.provisioners.RamProvisionerSimple;
import org.cloudbus.cloudsim.sdn.overbooking.BwProvisionerOverbooking;
import org.cloudbus.cloudsim.sdn.overbooking.PeProvisionerOverbooking;
import org.fog.application.AppEdge;
import org.fog.application.AppLoop;
import org.fog.application.Application;
import org.fog.application.selectivity.FractionalSelectivity;
import org.fog.entities.Actuator;
import org.fog.entities.FogBroker;
import org.fog.entities.FogDevice;
import org.fog.entities.FogDeviceCharacteristics;
import org.fog.entities.Sensor;
import org.fog.entities.Tuple;
import org.fog.placement.Controller;
import org.fog.placement.ControllerEdgeward;
import org.fog.placement.LModulePlacementEdgewards;
import org.fog.placement.LatencyModulePlacementNear;
import org.fog.placement.ModuleMapping;
import org.fog.placement.ModulePlacementDifferentiated;
import org.fog.placement.ModulePlacementEdgewards;
import org.fog.placement.ModulePlacementMapping;
import org.fog.placement.ModulePlacementModified;
import org.fog.placement.ModulePlacementOnlyCloud;
import org.fog.policy.AppModuleAllocationPolicy;
import org.fog.scheduler.StreamOperatorScheduler;
import org.fog.utils.Config;
import org.fog.utils.FogLinearPowerModel;
import org.fog.utils.FogUtils;
import org.fog.utils.TimeKeeper;
import org.fog.utils.distribution.DeterministicDistribution;

/**
 * Simulation setup for  ECG
 * @author Ragaa Shehab
 *
 */ //updateTimingsOnReceipt - checkCloudletCompletion --tupleEndedExecutionUser
public class ECG {
	static List<FogDevice> fogDevices = new ArrayList<FogDevice>();
	static List<Sensor> sensors = new ArrayList<Sensor>();
	static List<Actuator> actuators = new ArrayList<Actuator>();
	static Map<Integer,FogDevice> deviceById = new HashMap<Integer,FogDevice>();	
	static List<Integer> idOfEndDevices = new ArrayList<Integer>();
	static Map<Integer, Double> deadlineInfo = new	HashMap<Integer, Double>();  // mobile id has priority
	static Map<Integer, Double> additionalMipsInfo = new HashMap<Integer, Double>(); // mobile id need tuple mips
	static Map<Integer, Map<String, Double>> deadlineInfomodule = new HashMap<Integer, Map<String,Double>>();  // mobile id has modulename with module priority
	static Map<Integer,List<Map<String, Double>>> deadlineInfomodule1 = new HashMap<Integer, List<Map<String,Double>>>();  // mobile id has modulename with module priority

	static boolean CLOUD = false;
	static int numOfDepts = 1;
	static int numOfMobilesPerDept =5;
	static double ECG_TRANSMISSION_TIME = 50.0 ; // 50.0;   //100, 50, 25 ms   100 //10s= 10000
	static public int mymips= 2000;     
	//static String placement = "Latency Module Placement"; 
	static String placement = "Latency Differentiated Module Placement"; 
	//static String placement = "Module Placement Edgeward";
	//static String placement = "Module Placement Edgeward Differentiated";
	//static String placement = "Latency Modified Module Placement";
	static double MobileCPUload= 0.1;
	
	public static void main(String[] args) {
		Log.print("Starting ECG transmission");	Log.print("             ECG transmission time ms: "); Log.print(ECG_TRANSMISSION_TIME);
		Log.print("     Depts/Mobiles =  "); Log.print (numOfDepts);Log.print("/"); Log.printLine (numOfMobilesPerDept);
		System.out.println("analytics VM mips  2000, Fog device mips: mobile 1000, dept  2800, proxy 16800" ); 

		
		try {
			Log.disable(); 	
			//Config.MAX_SIMULATION_TIME= 100000;
			int num_user = 1; // number of cloud users
			Calendar calendar = Calendar.getInstance();
			boolean trace_flag = false; // mean trace events
			CloudSim.init(num_user, calendar, trace_flag);						
			String appId = "ECG"; 
			FogBroker broker = new FogBroker("broker");			
			createFogDevices(broker.getId(), appId);
			
			Map<String, Double> moduledeadline= new HashMap<String, Double>();
			Map<String, Double> moduledeadline1;
			List<Map<String, Double>> moduledeadline1List;

			for(Integer id : idOfEndDevices){
				Double x= getvalue(5.00, 40.00);
				Double t1= 10.00; Double t2= 5.00; //Double t3= 5.00;
				deadlineInfo.put(id, x);
				
				if (placement.equals("Latency Differentiated Module Placement")||placement.equals("Module Placement Edgeward Differentiated")) {
						if((5.00 < x)&& (x < 10.00)) x=5.00;
						if(10.00 < x)&& (x < 15.00)) x=10.00;
						if(15.00 <  x)&& (x < 20.00) x=20.00;
						if(20.00 < x)&& (x < 30.00) x=30.00;
						if(30.00 < x < 40.00) x=40.00;
					
							
						
					additionalMipsInfo.put(id, x*100); //1000
					moduledeadline1=  new HashMap<String,Double>();
					moduledeadline1List= new ArrayList<Map<String, Double>>();
					moduledeadline1.put("Client", x*100);
					moduledeadline1.put("Filtering", x*100);
					moduledeadline1.put("Monitoring", x*100);
					moduledeadline1.put("Caregiver", x*100);
					moduledeadline1.put("Cloud_Analytics", x*100);
					moduledeadline1List.add(moduledeadline1);
					deadlineInfomodule1.put(id, moduledeadline1List);
				}
				else {
					additionalMipsInfo.put(id, (double)mymips);
					moduledeadline1=  new HashMap<String,Double>();
					moduledeadline1List= new ArrayList<Map<String, Double>>();
					moduledeadline1.put("Client", (double)mymips);
					moduledeadline1.put("Filtering", (double)mymips);
					moduledeadline1.put("Monitoring", (double)mymips);
					moduledeadline1.put("Caregiver", (double)mymips);
					moduledeadline1.put("Cloud_Analytics", (double)mymips);
					moduledeadline1List.add(moduledeadline1);
					deadlineInfomodule1.put(id, moduledeadline1List);
				}
				moduledeadline.put("Filtering", (x+t1));
				deadlineInfomodule.put(id,moduledeadline);
				moduledeadline.put("Monitoring", (x+ t2));
				deadlineInfomodule.put(id,moduledeadline);
			}	
			
			deadlineInfo=deadlineInfo.entrySet()
		             .stream().sorted(Map.Entry.comparingByValue())
		             .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -> e1, LinkedHashMap::new));			
				
			Application application = createApplication(appId, broker.getId());
			application.setUserId(broker.getId());
			application.setdeviceById(deviceById);
			application.setidOfEndDevices(idOfEndDevices);
			application.setDeadlineInfo(deadlineInfo);
			application.setDeadlineInfomodule(deadlineInfomodule);
			application.setDeadlineInfomodule1(deadlineInfomodule1);
		    application.setAdditionalMipsInfo(additionalMipsInfo);
		    application.setplacement(placement);
		    application.setMobileCPUload(MobileCPUload);
		    
		    System.out.println(String.format("%-25s%s" ,"User Priority ASC ", application.getDeadlineInfo()));
			System.out.println(String.format("%-25s%s" ,"Module Tuble MIPS ",application.getAdditionalMipsInfo()));
		   /// System.out.println(String.format("%-25s%s" ,"Module Priority ",application.getDeadlineInfomodule()));
		    System.out.println(String.format("%-25s%s" ,"Module Priority1 ",application.getDeadlineInfomodule1()));

		    System.out.println("mobile CPU load "+ application.getMobileCPUload());
		    		
			Controller controller = null;
			ModuleMapping moduleMapping = ModuleMapping.createModuleMapping(); // initializing a module mapping			
			moduleMapping.addModuleToDevice("Cloud_Analytics", "cloud");
			for(FogDevice device : fogDevices){
				if(device.getName().startsWith("m"))
					moduleMapping.addModuleToDevice("Client", device.getName());
				}
			if(CLOUD){			 
				moduleMapping.addModuleToDevice("Caregiver", "cloud");
				moduleMapping.addModuleToDevice("Monitoring", "cloud");
				moduleMapping.addModuleToDevice("Filtering", "cloud");
				System.out.println("cloud only module placement, tuple mips= "+ mymips);
				controller = new ControllerEdgeward("master-controller", fogDevices, sensors, actuators);
				controller.submitApplication(application, 0, new ModulePlacementMapping(fogDevices, application,moduleMapping));
				}
			else {
				moduleMapping.addModuleToDevice("Caregiver", "proxy-server");
				switch (placement) { 
				case "Latency Module Placement":{			
					System.out.println("Per User Basic module placement");//", Tuple mips= "+ mymips
					controller = new Controller("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LatencyModulePlacementNear(fogDevices, sensors, actuators, application, moduleMapping));
					break;}	
				case "Latency Modified Module Placement":{
					System.out.println("Per User Modified module placement");
					controller = new Controller("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new ModulePlacementModified(fogDevices, sensors, actuators, application, moduleMapping));
					break;}
				case "Latency Differentiated Module Placement":{
					System.out.println("Per User Differentiated module placement, variable Module/Tuple mips ");
					controller = new Controller("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LatencyModulePlacementNear(fogDevices, sensors, actuators, application, moduleMapping));
					break;} //ModulePlacementDifferentiated
				case "Module Placement Edgeward":{
					System.out.println("Per module placement");
					controller = new ControllerEdgeward("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LModulePlacementEdgewards(fogDevices, sensors, actuators, application, moduleMapping));
					break;}
				case "Module Placement Edgeward Differentiated":{
					System.out.println("Per module Differentiated placement");
					controller = new ControllerEdgeward("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LModulePlacementEdgewards(fogDevices, sensors, actuators, application, moduleMapping));
					break;}
				}
				}
					
			TimeKeeper.getInstance().setSimulationStartTime(Calendar.getInstance().getTimeInMillis());
			CloudSim.startSimulation();
			CloudSim.stopSimulation();
			Log.printLine("ECG finished!");
		} catch (Exception e) {
			e.printStackTrace();
			Log.printLine("Unwanted errors happen");
		}
	}	
/****************************************************************************************
	 * Creates the fog devices in the physical topology of the simulation.
	 * @param userId
	 * @param appId
	 */
	private static void createFogDevices(int userId, String appId) {  // 44800
		FogDevice cloud = createFogDevice("cloud", 44800, 40000, 100, 10000, 0, 0.01, 16*103, 16*83.25); // creates the fog device Cloud at the apex of the hierarchy with level=0
		cloud.setParentId(-1);		 
		FogDevice proxy = createFogDevice("proxy-server", 16800 , 4000, 10000, 10000, 1, 0.0, 107.339, 83.4333); // 2800
		proxy.setParentId(cloud.getId()); // setting Cloud as parent of the Proxy Server
		proxy.setUplinkLatency(100); // latency of connection from Proxy Server to the Cloud is 100 ms		
		fogDevices.add(cloud);
		deviceById.put(cloud.getId(), cloud);
		fogDevices.add(proxy);
		deviceById.put(proxy.getId(), proxy);		
		for(int i=0;i<numOfDepts;i++){
			addGw(i+"", userId, appId, proxy.getId()); // adding a fog device for every Gateway in physical topology. The parent of each gateway is the Proxy Server
		}	
	}

	private static FogDevice addGw(String id, int userId, String appId, int parentId){
		FogDevice dept = createFogDevice("d-"+id, 2800, 4000, 10000, 10000, 2, 0.0, 107.339, 83.4333); //2800
		fogDevices.add(dept);
		deviceById.put(dept.getId(), dept);
		dept.setParentId(parentId);
		dept.setUplinkLatency(4); // latency of connection between gateways and proxy server is 4 ms
		for(int i=0;i<numOfMobilesPerDept;i++){
			String mobileId = id+"-"+i;
			FogDevice mobile = addMobile(mobileId, userId, appId, dept.getId()); // adding mobiles to the physical topology. Smartphones have been modeled as fog devices as well.
			mobile.setUplinkLatency(2); // latency of connection between the smartphone and proxy server is 4 ms
			fogDevices.add(mobile);
			deviceById.put(mobile.getId(), mobile);
		}
		return dept;
	}
	
	private static FogDevice addMobile(String id, int userId, String appId, int parentId){
		FogDevice mobile = createFogDevice("m-"+id, 1000, 1000, 10000, 270, 3, 0, 87.53, 82.44); //1000   
		mobile.setParentId(parentId);
		idOfEndDevices.add(mobile.getId());
		Sensor ecgsensor = new Sensor("s-"+id, "ECG", userId, appId, new DeterministicDistribution(ECG_TRANSMISSION_TIME)); // inter-transmission time of EEG sensor follows a deterministic distribution
		sensors.add(ecgsensor);
		Actuator display = new Actuator("a-"+id, userId, appId, "DISPLAY");
		actuators.add(display);
		ecgsensor.setGatewayDeviceId(mobile.getId());
		ecgsensor.setLatency(6.0);  // latency of connection between EEG sensors and the parent Smartphone is 6 ms
		display.setGatewayDeviceId(mobile.getId());
		display.setLatency(1.0);  // latency of connection between Display actuator and the parent Smartphone is 1 ms
		return mobile;
	}
	
/*****************************************************************************************
	 * Creates a vanilla fog device
	 * @param nodeName name of the device to be used in simulation
	 * @param mips MIPS
	 * @param ram RAM
	 * @param upBw uplink bandwidth
	 * @param downBw downlink bandwidth
	 * @param level hierarchy level of the device
	 * @param ratePerMips cost rate per MIPS used
	 * @param busyPower
	 * @param idlePower
	 * @return
	 */
	private static FogDevice createFogDevice(String nodeName, long mips,
			int ram, long upBw, long downBw, int level, double ratePerMips, double busyPower, double idlePower) {
		
		List<Pe> peList = new ArrayList<Pe>();
		// 3. Create PEs and add these into a list.
		peList.add(new Pe(0, new PeProvisionerOverbooking(mips))); // need to store Pe id and MIPS Rating
		
		int hostId = FogUtils.generateEntityId();
		long storage = 1000000; // host storage
		int bw = 10000;
		PowerHost host = new PowerHost(
				hostId,
				new RamProvisionerSimple(ram),
				new BwProvisionerOverbooking(bw),
				storage,
				peList,
				new StreamOperatorScheduler(peList),
				new FogLinearPowerModel(busyPower, idlePower)
			);

		List<Host> hostList = new ArrayList<Host>();
		hostList.add(host);

		String arch = "x86"; // system architecture
		String os = "Linux"; // operating system
		String vmm = "Xen";
		double time_zone = 10.0; // time zone this resource located
		double cost = 3.0; // the cost of using processing in this resource
		double costPerMem = 0.05; // the cost of using memory in this resource
		double costPerStorage = 0.001; // the cost of using storage in this	// resource
		double costPerBw = 0.0; // the cost of using bw in this resource
		LinkedList<Storage> storageList = new LinkedList<Storage>(); // we are not adding SAN devices by now

		FogDeviceCharacteristics characteristics = new FogDeviceCharacteristics(
				arch, os, vmm, host, time_zone, cost, costPerMem,
				costPerStorage, costPerBw);

		FogDevice fogdevice = null;
		try {
			fogdevice = new FogDevice(nodeName, characteristics, 
					new AppModuleAllocationPolicy(hostList), storageList, 10 , upBw, downBw, 0, ratePerMips); //10 : schedulingInterval  0 uplink  latency		
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		fogdevice.setLevel(level);
		return fogdevice;
	}

/******************************************************************************************
	 * Function to create the EEG Tractor Beam game application in the DDF model. 
	 * @param appId unique identifier of the application
	 * @param userId identifier of the user of the application
	 * @return
	 */
	@SuppressWarnings({"serial" })
	private static Application createApplication(String appId, int userId){
		
		Application application = Application.createApplication(appId, userId); // creates an empty application model (empty directed graph)
		
		// Adding modules (vertices) to the application model (directed graph)
		application.addAppModule("Client", 10, 2000, 1000,100,5); //250Name,int ram, int mips, long size, long bw, int modprty) size is the image size (MB)
		application.addAppModule("Filtering",10, 2000, 500, 100,4); //150
		application.addAppModule("Monitoring",10, 2000, 500,100,3); //150 
		application.addAppModule("Caregiver", 10, 2000,1000,100,2); // 150
		application.addAppModule("Cloud_Analytics",10, 3000,1000,250,1); //500("Cloud_Analytics",10, 500,1000,500,1); //
		
		// Connecting the application modules (vertices) in the application model (directed graph) with edges
		//source, destination, double tupleCpuLength, double tupleNwLength, String tupleType, int direction, int edgeType){
		application.addAppEdge("ECG", "Client", 2000, 500, "ECG", Tuple.UP, AppEdge.SENSOR);
		application.addAppEdge("Client", "Filtering", 2000, 500, "SENSOR_DATA", Tuple.UP, AppEdge.MODULE); //
		application.addAppEdge("Filtering", "Monitoring", mymips, 500, "FILTERED_DATA", Tuple.UP, AppEdge.MODULE); //
		application.addAppEdge("Monitoring", "Caregiver", mymips, 500, "ECG_REPORT", Tuple.UP, AppEdge.MODULE);  //
		application.addAppEdge("Caregiver", "Cloud_Analytics", mymips, 500, "DATA_OFFLOAD", Tuple.UP, AppEdge.MODULE); //		
		application.addAppEdge("Caregiver", "Client", mymips, 500, "State_Action", Tuple.DOWN, AppEdge.MODULE); //  
		application.addAppEdge("Client", "DISPLAY",2000, 500, "P_State_Action", Tuple.DOWN, AppEdge.ACTUATOR);  //
		application.addAppEdge("Cloud_Analytics", "Caregiver", 2000, 1000, "Advanced_Analytics", Tuple.DOWN, AppEdge.MODULE);  
		
 	    //Defining the input-output relationships (represented by selectivity) of the application modules. 
		application.addTupleMapping("Client", "ECG", "SENSOR_DATA", new FractionalSelectivity(1.0)); // 
		application.addTupleMapping("Client", "State_Action", "P_State_Action", new FractionalSelectivity(1.0)); //  
		application.addTupleMapping("Filtering", "SENSOR_DATA", "FILTERED_DATA", new FractionalSelectivity(1.0)); // 
		application.addTupleMapping("Monitoring", "FILTERED_DATA", "ECG_REPORT", new FractionalSelectivity(1.0)); //
		application.addTupleMapping("Caregiver", "ECG_REPORT", "DATA_OFFLOAD", new FractionalSelectivity(1.0)); //
		application.addTupleMapping("Caregiver", "ECG_REPORT", "State_Action", new FractionalSelectivity(1.0)); //
		application.addTupleMapping("Cloud_Analytics", "DATA_OFFLOAD", "Advanced_Analytics", new FractionalSelectivity(0.01)); //
	
		
		 // Defining application loops to monitor the latency of.
		//final AppLoop ONLY_CLOUD = new AppLoop(new ArrayList<String>(){{add("ECG");add("Client");add("Filtering");add("Monitoring");add("Caregiver");add("Client");add("DISPLAY");}}); //add("Cloud_Analytics");
        //List<AppLoop> loops = new ArrayList<AppLoop>(){{ add(ONLY_CLOUD);}};
		//final AppLoop ECG_REPORTING = new AppLoop(new ArrayList<String>(){{add("ECG");add("Client");add("Filtering");add("Monitoring");add("Caregiver");add("Client");add("DISPLAY");}});
        //List<AppLoop> loops = new ArrayList<AppLoop>(){{ add(ECG_REPORTING);}};
		final AppLoop ECG_ANALYTICS = new AppLoop(new ArrayList<String>(){{add("ECG");add("Client");add("Filtering");add("Monitoring");add("Caregiver");}});
        List<AppLoop> loops = new ArrayList<AppLoop>(){{add( ECG_ANALYTICS);}}; 
 		application.setLoops(loops);
		return application;
		}
///random number generators//////////////////////////////////////////////////////////
	private static double getvalue(double d, double e)  { 
	    Random r = new Random(); 
	    double randomValue = d + (e - d) *r.nextDouble(); 
	   // randomValue = r.nextDouble();
	    return randomValue; 
	  } 
	private static Integer getvalue(int min, int max) { 
	    Random r = new Random(); 
	    Integer randomValue = min + r.nextInt()%(max - min); 
	   // randomValue = r.nextInt(max);
	    return randomValue; 
	  }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//scheduled cloudlet processing =30,100,200,300,500 mips for filtering monitoring caregiver  
//scheduled cloudlet processing = 1000  for client and cloudanalytics modules
// mobile id, need Modulename executed with max delay (3:5)
//static Pair<String, Double> moduledeadline = new Pair <String, Double>(null,null);  // mobile id need deadline double
//static List<Pair<String, Double>> moduledeadline = new ArrayList<Pair <String, Double>>();


//if(placement.equals("Latency Differentiated Module Placement")) {		
//System.out.println(String.format("%-30s%s" ,"Per_User Differentiated Module Placement, " ," variable mips between 50 mips, "+  mymips+ " for all modules except cloud plus 1000 mips"));
//}		
//else if(placement.equals("Module Placement Edgeward")) {
//System.out.println(String.format("%-30s%20s%s%30s%10s%s" ,"Per_Module Edgeward Placement","const mips= " , mymips));
//System.out.println("Per_Module Placement,  Tuple's mips= " + mymips);
//}
///else 
//placement=="Latency Module Placement" 
//System.out.println(String.format("%-30s%20s%s%30s%10s%s" ,"Per_User Basic Module Placement","const mips= " , mymips));
//System.out.println("Per_User Basic Module Placement,  const mips= " + mymips);		

//System.out.println("Application Module mips: Client = Filtering = Monitoring = Caregiver = 300 mips , Cloud_Analytics = 600 mips");
//System.out.println("Migration Condition: Mobile Utilization >= 0.3, Proxy/Dept Utilization >= 0.9" );  //, RESOURCE_MANAGE_INTERVAL = 100 ");
//System.out.println("Enhanced Migration Conditions , RESOURCE_MANAGE_INTERVAL = 10 ");
//System.out.println("fog device scheduling interval = 10,  Application module scheduling interval = 300  ");	

//moduledeadline.put("Client", (x+ 15.0000000000000000));
//deadlineInfomodule.put(id,moduledeadline);
//moduledeadline.put("Caregiver", x);
//deadlineInfomodule.put(id,moduledeadline);				
//System.out.println("deadlineInfomodule  "+ deadlineInfomodule);
//deadlineInfomodule.put(id,moduledeadlinelist);				
//moduledeadline.clear();

/*
for(Integer id : idOfEndDevices){
	if (placement.equals("Latency Differentiated Module Placement")) {
		Integer x= getvalue(50, 500);//mymips);
		x= Math.abs(x);
		additionalMipsInfo.put(id, (double)x);  //getvalue(0,mymips)
		}
	else
		additionalMipsInfo.put(id, (double)mymips);
}
*/
/*else if(device.getName().startsWith("d")){
moduleMapping.addModuleToDevice("Filtering", device.getName());
moduleMapping.addModuleToDevice("Monitoring", device.getName());				
} */
//Controller controller = new Controller("master-controller", fogDevices, sensors, actuators);
//controller.submitApplication(application, 0, new ModulePlacementOnlyCloud(fogDevices, sensors, actuators, application));
//controller.submitApplication(application, 0, new LatencyModulePlacement(fogDevices, sensors, actuators, application, moduleMapping));
//controller.submitApplication(application, 0, new LatencyModifiedModulePlacementNew(fogDevices, sensors, actuators, application, moduleMapping));
 //LModulePlacementEdgewards  // LatencyModulePlacementNear

//TRY FogDevice cloud = createFogDevice("cloud", 448000000, 40000000, 100000, 10000000, 0, 0.01, 16*103, 16*83.25); // creates the fog device Cloud at the apex of the hierarchy with level=0
//FogDevice cloud = createFogDevice("cloud", 4480000, 4000000, 100, 10000, 0, 0.01, 16*103, 16*83.25); // creates the fog device Cloud at the apex of the hierarchy with level=0
//FogDevice proxy = createFogDevice("proxy-server", 2800, 4000, 10000, 10000, 1, 0.0, 107.339, 83.4333);

//peList.add(new Pe(0, new PeProvisionerSimple(mips))); // need to store Pe id and MIPS Rating


/*
application.addAppModule("Client", 10, 300, 1000,100,5); // adding module Client to the application model
application.addAppModule("Filtering",10, 300, 1000, 100,4); //
application.addAppModule("Monitoring",10, 300, 1000,100,3); // 
application.addAppModule("Caregiver", 10, 300,1000,100,2); // 
application.addAppModule("Cloud_Analytics",10, 600,1000,250,1); //("Cloud_Analytics",10, 500,1000,500,1); //
*/
/*application.addAppEdge("ECG", "Client", 3000, 1000, "ECG", Tuple.UP, AppEdge.SENSOR);
application.addAppEdge("Client", "Filtering", 3000, 500, "SENSOR_DATA", Tuple.UP, AppEdge.MODULE); //
application.addAppEdge("Filtering", "Monitoring", (30+ mymips), 500, "FILTERED_DATA", Tuple.UP, AppEdge.MODULE); // 
application.addAppEdge("Monitoring", "Cloud_Analytics", 1000, 500, "DATA_OFFLOAD", Tuple.UP, AppEdge.MODULE); // 
application.addAppEdge("Monitoring", "Caregiver", (60+ mymips) , 500, "ECG_REPORT", Tuple.UP, AppEdge.MODULE);  // 
application.addAppEdge("Cloud_Analytics", "Caregiver", 3500, 1000, "Advanced_Analytics", Tuple.DOWN, AppEdge.MODULE);  // 
application.addAppEdge("Caregiver", "Client", 1000 , 500, "State_Action", Tuple.DOWN, AppEdge.MODULE); // 
application.addAppEdge("Client", "DISPLAY",1000, 500, "P_State_Action", Tuple.DOWN, AppEdge.ACTUATOR);  //
 */
//application.addAppEdge("Caregiver", "Cloud_Analytics", 3000, 1000, "DECISION", Tuple.UP, AppEdge.MODULE); //
// application.addTupleMapping("Cloud_Analytics", "DECISION", "Advanced_Analytics", new FractionalSelectivity(0.001)); //
//final AppLoop HBR_Analytics = new AppLoop(new ArrayList<String>(){{add("HBR"); add("Client"); add("Monitoring"); add("Cloud_Analytics"); add("Caregiver"); add("Client"); add("DISPLAY");}});

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10076, count -3525, length 26106
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-10-15 12:36:42.416
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.StringIndexOutOfBoundsException: offset 10076, count -3525, length 26106
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:324)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10076, count -3525, length 26106
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	... 16 more
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10076, count -3525, length 26106
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2020-10-15 12:36:42.416
!MESSAGE offset 10076, count -3525, length 26106
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10076, count -3525, length 26106
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2020-10-15 12:36:42.416
!MESSAGE offset 10076, count -3525, length 26106
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10076, count -3525, length 26106
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-10-15 12:36:42.417
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.StringIndexOutOfBoundsException: offset 10076, count -3525, length 26106
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:324)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10076, count -3525, length 26106
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	... 16 more
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10076, count -3525, length 26106
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2020-10-15 12:36:42.417
!MESSAGE offset 10076, count -3525, length 26106
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10076, count -3525, length 26106
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-10-15 12:36:42.425
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10076, count -3525, length 26106
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-10-15 12:36:42.426
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10076, count -3525, length 26106
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-10-15 12:36:42.850
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10076, count -3525, length 26106
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-10-15 12:36:42.851
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10076, count -3525, length 26106
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-10-15 12:36:47.430
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
package org.fog.test.perfeval;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.stream.Collectors;
import org.apache.commons.math3.util.Pair;
import org.cloudbus.cloudsim.Host;
import org.cloudbus.cloudsim.Log;
import org.cloudbus.cloudsim.Pe;
import org.cloudbus.cloudsim.Storage;
import org.cloudbus.cloudsim.core.CloudSim;
import org.cloudbus.cloudsim.power.PowerHost;
import org.cloudbus.cloudsim.provisioners.PeProvisionerSimple;
import org.cloudbus.cloudsim.provisioners.RamProvisionerSimple;
import org.cloudbus.cloudsim.sdn.overbooking.BwProvisionerOverbooking;
import org.cloudbus.cloudsim.sdn.overbooking.PeProvisionerOverbooking;
import org.fog.application.AppEdge;
import org.fog.application.AppLoop;
import org.fog.application.Application;
import org.fog.application.selectivity.FractionalSelectivity;
import org.fog.entities.Actuator;
import org.fog.entities.FogBroker;
import org.fog.entities.FogDevice;
import org.fog.entities.FogDeviceCharacteristics;
import org.fog.entities.Sensor;
import org.fog.entities.Tuple;
import org.fog.placement.Controller;
import org.fog.placement.ControllerEdgeward;
import org.fog.placement.LModulePlacementEdgewards;
import org.fog.placement.LatencyModulePlacementNear;
import org.fog.placement.ModuleMapping;
import org.fog.placement.ModulePlacementDifferentiated;
import org.fog.placement.ModulePlacementEdgewards;
import org.fog.placement.ModulePlacementMapping;
import org.fog.placement.ModulePlacementModified;
import org.fog.placement.ModulePlacementOnlyCloud;
import org.fog.policy.AppModuleAllocationPolicy;
import org.fog.scheduler.StreamOperatorScheduler;
import org.fog.utils.Config;
import org.fog.utils.FogLinearPowerModel;
import org.fog.utils.FogUtils;
import org.fog.utils.TimeKeeper;
import org.fog.utils.distribution.DeterministicDistribution;

/**
 * Simulation setup for  ECG
 * @author Ragaa Shehab
 *
 */ //updateTimingsOnReceipt - checkCloudletCompletion --tupleEndedExecutionUser
public class ECG {
	static List<FogDevice> fogDevices = new ArrayList<FogDevice>();
	static List<Sensor> sensors = new ArrayList<Sensor>();
	static List<Actuator> actuators = new ArrayList<Actuator>();
	static Map<Integer,FogDevice> deviceById = new HashMap<Integer,FogDevice>();	
	static List<Integer> idOfEndDevices = new ArrayList<Integer>();
	static Map<Integer, Double> deadlineInfo = new	HashMap<Integer, Double>();  // mobile id has priority
	static Map<Integer, Double> additionalMipsInfo = new HashMap<Integer, Double>(); // mobile id need tuple mips
	static Map<Integer, Map<String, Double>> deadlineInfomodule = new HashMap<Integer, Map<String,Double>>();  // mobile id has modulename with module priority
	static Map<Integer,List<Map<String, Double>>> deadlineInfomodule1 = new HashMap<Integer, List<Map<String,Double>>>();  // mobile id has modulename with module priority

	static boolean CLOUD = false;
	static int numOfDepts = 1;
	static int numOfMobilesPerDept =5;
	static double ECG_TRANSMISSION_TIME = 50.0 ; // 50.0;   //100, 50, 25 ms   100 //10s= 10000
	static public int mymips= 2000;     
	//static String placement = "Latency Module Placement"; 
	static String placement = "Latency Differentiated Module Placement"; 
	//static String placement = "Module Placement Edgeward";
	//static String placement = "Module Placement Edgeward Differentiated";
	//static String placement = "Latency Modified Module Placement";
	static double MobileCPUload= 0.1;
	
	public static void main(String[] args) {
		Log.print("Starting ECG transmission");	Log.print("             ECG transmission time ms: "); Log.print(ECG_TRANSMISSION_TIME);
		Log.print("     Depts/Mobiles =  "); Log.print (numOfDepts);Log.print("/"); Log.printLine (numOfMobilesPerDept);
		System.out.println("analytics VM mips  2000, Fog device mips: mobile 1000, dept  2800, proxy 16800" ); 

		
		try {
			Log.disable(); 	
			//Config.MAX_SIMULATION_TIME= 100000;
			int num_user = 1; // number of cloud users
			Calendar calendar = Calendar.getInstance();
			boolean trace_flag = false; // mean trace events
			CloudSim.init(num_user, calendar, trace_flag);						
			String appId = "ECG"; 
			FogBroker broker = new FogBroker("broker");			
			createFogDevices(broker.getId(), appId);
			
			Map<String, Double> moduledeadline= new HashMap<String, Double>();
			Map<String, Double> moduledeadline1;
			List<Map<String, Double>> moduledeadline1List;

			for(Integer id : idOfEndDevices){
				Double x= getvalue(5.00, 40.00);
				Double t1= 10.00; Double t2= 5.00; //Double t3= 5.00;
				deadlineInfo.put(id, x);
				
				if (placement.equals("Latency Differentiated Module Placement")||placement.equals("Module Placement Edgeward Differentiated")) {
						if((5.00 < x)&& (x < 10.00)) x=5.00;
						if(10.00 < x)&& (x < 15.00)) x=10.00;
						if(15.00 <  x)&& (x < 20.00)) x=20.00;
						if(20.00 < x)&& (x < 30.00) x=30.00;
						if(30.00 < x < 40.00) x=40.00;
					
							
						
					additionalMipsInfo.put(id, x*100); //1000
					moduledeadline1=  new HashMap<String,Double>();
					moduledeadline1List= new ArrayList<Map<String, Double>>();
					moduledeadline1.put("Client", x*100);
					moduledeadline1.put("Filtering", x*100);
					moduledeadline1.put("Monitoring", x*100);
					moduledeadline1.put("Caregiver", x*100);
					moduledeadline1.put("Cloud_Analytics", x*100);
					moduledeadline1List.add(moduledeadline1);
					deadlineInfomodule1.put(id, moduledeadline1List);
				}
				else {
					additionalMipsInfo.put(id, (double)mymips);
					moduledeadline1=  new HashMap<String,Double>();
					moduledeadline1List= new ArrayList<Map<String, Double>>();
					moduledeadline1.put("Client", (double)mymips);
					moduledeadline1.put("Filtering", (double)mymips);
					moduledeadline1.put("Monitoring", (double)mymips);
					moduledeadline1.put("Caregiver", (double)mymips);
					moduledeadline1.put("Cloud_Analytics", (double)mymips);
					moduledeadline1List.add(moduledeadline1);
					deadlineInfomodule1.put(id, moduledeadline1List);
				}
				moduledeadline.put("Filtering", (x+t1));
				deadlineInfomodule.put(id,moduledeadline);
				moduledeadline.put("Monitoring", (x+ t2));
				deadlineInfomodule.put(id,moduledeadline);
			}	
			
			deadlineInfo=deadlineInfo.entrySet()
		             .stream().sorted(Map.Entry.comparingByValue())
		             .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -> e1, LinkedHashMap::new));			
				
			Application application = createApplication(appId, broker.getId());
			application.setUserId(broker.getId());
			application.setdeviceById(deviceById);
			application.setidOfEndDevices(idOfEndDevices);
			application.setDeadlineInfo(deadlineInfo);
			application.setDeadlineInfomodule(deadlineInfomodule);
			application.setDeadlineInfomodule1(deadlineInfomodule1);
		    application.setAdditionalMipsInfo(additionalMipsInfo);
		    application.setplacement(placement);
		    application.setMobileCPUload(MobileCPUload);
		    
		    System.out.println(String.format("%-25s%s" ,"User Priority ASC ", application.getDeadlineInfo()));
			System.out.println(String.format("%-25s%s" ,"Module Tuble MIPS ",application.getAdditionalMipsInfo()));
		   /// System.out.println(String.format("%-25s%s" ,"Module Priority ",application.getDeadlineInfomodule()));
		    System.out.println(String.format("%-25s%s" ,"Module Priority1 ",application.getDeadlineInfomodule1()));

		    System.out.println("mobile CPU load "+ application.getMobileCPUload());
		    		
			Controller controller = null;
			ModuleMapping moduleMapping = ModuleMapping.createModuleMapping(); // initializing a module mapping			
			moduleMapping.addModuleToDevice("Cloud_Analytics", "cloud");
			for(FogDevice device : fogDevices){
				if(device.getName().startsWith("m"))
					moduleMapping.addModuleToDevice("Client", device.getName());
				}
			if(CLOUD){			 
				moduleMapping.addModuleToDevice("Caregiver", "cloud");
				moduleMapping.addModuleToDevice("Monitoring", "cloud");
				moduleMapping.addModuleToDevice("Filtering", "cloud");
				System.out.println("cloud only module placement, tuple mips= "+ mymips);
				controller = new ControllerEdgeward("master-controller", fogDevices, sensors, actuators);
				controller.submitApplication(application, 0, new ModulePlacementMapping(fogDevices, application,moduleMapping));
				}
			else {
				moduleMapping.addModuleToDevice("Caregiver", "proxy-server");
				switch (placement) { 
				case "Latency Module Placement":{			
					System.out.println("Per User Basic module placement");//", Tuple mips= "+ mymips
					controller = new Controller("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LatencyModulePlacementNear(fogDevices, sensors, actuators, application, moduleMapping));
					break;}	
				case "Latency Modified Module Placement":{
					System.out.println("Per User Modified module placement");
					controller = new Controller("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new ModulePlacementModified(fogDevices, sensors, actuators, application, moduleMapping));
					break;}
				case "Latency Differentiated Module Placement":{
					System.out.println("Per User Differentiated module placement, variable Module/Tuple mips ");
					controller = new Controller("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LatencyModulePlacementNear(fogDevices, sensors, actuators, application, moduleMapping));
					break;} //ModulePlacementDifferentiated
				case "Module Placement Edgeward":{
					System.out.println("Per module placement");
					controller = new ControllerEdgeward("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LModulePlacementEdgewards(fogDevices, sensors, actuators, application, moduleMapping));
					break;}
				case "Module Placement Edgeward Differentiated":{
					System.out.println("Per module Differentiated placement");
					controller = new ControllerEdgeward("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LModulePlacementEdgewards(fogDevices, sensors, actuators, application, moduleMapping));
					break;}
				}
				}
					
			TimeKeeper.getInstance().setSimulationStartTime(Calendar.getInstance().getTimeInMillis());
			CloudSim.startSimulation();
			CloudSim.stopSimulation();
			Log.printLine("ECG finished!");
		} catch (Exception e) {
			e.printStackTrace();
			Log.printLine("Unwanted errors happen");
		}
	}	
/****************************************************************************************
	 * Creates the fog devices in the physical topology of the simulation.
	 * @param userId
	 * @param appId
	 */
	private static void createFogDevices(int userId, String appId) {  // 44800
		FogDevice cloud = createFogDevice("cloud", 44800, 40000, 100, 10000, 0, 0.01, 16*103, 16*83.25); // creates the fog device Cloud at the apex of the hierarchy with level=0
		cloud.setParentId(-1);		 
		FogDevice proxy = createFogDevice("proxy-server", 16800 , 4000, 10000, 10000, 1, 0.0, 107.339, 83.4333); // 2800
		proxy.setParentId(cloud.getId()); // setting Cloud as parent of the Proxy Server
		proxy.setUplinkLatency(100); // latency of connection from Proxy Server to the Cloud is 100 ms		
		fogDevices.add(cloud);
		deviceById.put(cloud.getId(), cloud);
		fogDevices.add(proxy);
		deviceById.put(proxy.getId(), proxy);		
		for(int i=0;i<numOfDepts;i++){
			addGw(i+"", userId, appId, proxy.getId()); // adding a fog device for every Gateway in physical topology. The parent of each gateway is the Proxy Server
		}	
	}

	private static FogDevice addGw(String id, int userId, String appId, int parentId){
		FogDevice dept = createFogDevice("d-"+id, 2800, 4000, 10000, 10000, 2, 0.0, 107.339, 83.4333); //2800
		fogDevices.add(dept);
		deviceById.put(dept.getId(), dept);
		dept.setParentId(parentId);
		dept.setUplinkLatency(4); // latency of connection between gateways and proxy server is 4 ms
		for(int i=0;i<numOfMobilesPerDept;i++){
			String mobileId = id+"-"+i;
			FogDevice mobile = addMobile(mobileId, userId, appId, dept.getId()); // adding mobiles to the physical topology. Smartphones have been modeled as fog devices as well.
			mobile.setUplinkLatency(2); // latency of connection between the smartphone and proxy server is 4 ms
			fogDevices.add(mobile);
			deviceById.put(mobile.getId(), mobile);
		}
		return dept;
	}
	
	private static FogDevice addMobile(String id, int userId, String appId, int parentId){
		FogDevice mobile = createFogDevice("m-"+id, 1000, 1000, 10000, 270, 3, 0, 87.53, 82.44); //1000   
		mobile.setParentId(parentId);
		idOfEndDevices.add(mobile.getId());
		Sensor ecgsensor = new Sensor("s-"+id, "ECG", userId, appId, new DeterministicDistribution(ECG_TRANSMISSION_TIME)); // inter-transmission time of EEG sensor follows a deterministic distribution
		sensors.add(ecgsensor);
		Actuator display = new Actuator("a-"+id, userId, appId, "DISPLAY");
		actuators.add(display);
		ecgsensor.setGatewayDeviceId(mobile.getId());
		ecgsensor.setLatency(6.0);  // latency of connection between EEG sensors and the parent Smartphone is 6 ms
		display.setGatewayDeviceId(mobile.getId());
		display.setLatency(1.0);  // latency of connection between Display actuator and the parent Smartphone is 1 ms
		return mobile;
	}
	
/*****************************************************************************************
	 * Creates a vanilla fog device
	 * @param nodeName name of the device to be used in simulation
	 * @param mips MIPS
	 * @param ram RAM
	 * @param upBw uplink bandwidth
	 * @param downBw downlink bandwidth
	 * @param level hierarchy level of the device
	 * @param ratePerMips cost rate per MIPS used
	 * @param busyPower
	 * @param idlePower
	 * @return
	 */
	private static FogDevice createFogDevice(String nodeName, long mips,
			int ram, long upBw, long downBw, int level, double ratePerMips, double busyPower, double idlePower) {
		
		List<Pe> peList = new ArrayList<Pe>();
		// 3. Create PEs and add these into a list.
		peList.add(new Pe(0, new PeProvisionerOverbooking(mips))); // need to store Pe id and MIPS Rating
		
		int hostId = FogUtils.generateEntityId();
		long storage = 1000000; // host storage
		int bw = 10000;
		PowerHost host = new PowerHost(
				hostId,
				new RamProvisionerSimple(ram),
				new BwProvisionerOverbooking(bw),
				storage,
				peList,
				new StreamOperatorScheduler(peList),
				new FogLinearPowerModel(busyPower, idlePower)
			);

		List<Host> hostList = new ArrayList<Host>();
		hostList.add(host);

		String arch = "x86"; // system architecture
		String os = "Linux"; // operating system
		String vmm = "Xen";
		double time_zone = 10.0; // time zone this resource located
		double cost = 3.0; // the cost of using processing in this resource
		double costPerMem = 0.05; // the cost of using memory in this resource
		double costPerStorage = 0.001; // the cost of using storage in this	// resource
		double costPerBw = 0.0; // the cost of using bw in this resource
		LinkedList<Storage> storageList = new LinkedList<Storage>(); // we are not adding SAN devices by now

		FogDeviceCharacteristics characteristics = new FogDeviceCharacteristics(
				arch, os, vmm, host, time_zone, cost, costPerMem,
				costPerStorage, costPerBw);

		FogDevice fogdevice = null;
		try {
			fogdevice = new FogDevice(nodeName, characteristics, 
					new AppModuleAllocationPolicy(hostList), storageList, 10 , upBw, downBw, 0, ratePerMips); //10 : schedulingInterval  0 uplink  latency		
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		fogdevice.setLevel(level);
		return fogdevice;
	}

/******************************************************************************************
	 * Function to create the EEG Tractor Beam game application in the DDF model. 
	 * @param appId unique identifier of the application
	 * @param userId identifier of the user of the application
	 * @return
	 */
	@SuppressWarnings({"serial" })
	private static Application createApplication(String appId, int userId){
		
		Application application = Application.createApplication(appId, userId); // creates an empty application model (empty directed graph)
		
		// Adding modules (vertices) to the application model (directed graph)
		application.addAppModule("Client", 10, 2000, 1000,100,5); //250Name,int ram, int mips, long size, long bw, int modprty) size is the image size (MB)
		application.addAppModule("Filtering",10, 2000, 500, 100,4); //150
		application.addAppModule("Monitoring",10, 2000, 500,100,3); //150 
		application.addAppModule("Caregiver", 10, 2000,1000,100,2); // 150
		application.addAppModule("Cloud_Analytics",10, 3000,1000,250,1); //500("Cloud_Analytics",10, 500,1000,500,1); //
		
		// Connecting the application modules (vertices) in the application model (directed graph) with edges
		//source, destination, double tupleCpuLength, double tupleNwLength, String tupleType, int direction, int edgeType){
		application.addAppEdge("ECG", "Client", 2000, 500, "ECG", Tuple.UP, AppEdge.SENSOR);
		application.addAppEdge("Client", "Filtering", 2000, 500, "SENSOR_DATA", Tuple.UP, AppEdge.MODULE); //
		application.addAppEdge("Filtering", "Monitoring", mymips, 500, "FILTERED_DATA", Tuple.UP, AppEdge.MODULE); //
		application.addAppEdge("Monitoring", "Caregiver", mymips, 500, "ECG_REPORT", Tuple.UP, AppEdge.MODULE);  //
		application.addAppEdge("Caregiver", "Cloud_Analytics", mymips, 500, "DATA_OFFLOAD", Tuple.UP, AppEdge.MODULE); //		
		application.addAppEdge("Caregiver", "Client", mymips, 500, "State_Action", Tuple.DOWN, AppEdge.MODULE); //  
		application.addAppEdge("Client", "DISPLAY",2000, 500, "P_State_Action", Tuple.DOWN, AppEdge.ACTUATOR);  //
		application.addAppEdge("Cloud_Analytics", "Caregiver", 2000, 1000, "Advanced_Analytics", Tuple.DOWN, AppEdge.MODULE);  
		
 	    //Defining the input-output relationships (represented by selectivity) of the application modules. 
		application.addTupleMapping("Client", "ECG", "SENSOR_DATA", new FractionalSelectivity(1.0)); // 
		application.addTupleMapping("Client", "State_Action", "P_State_Action", new FractionalSelectivity(1.0)); //  
		application.addTupleMapping("Filtering", "SENSOR_DATA", "FILTERED_DATA", new FractionalSelectivity(1.0)); // 
		application.addTupleMapping("Monitoring", "FILTERED_DATA", "ECG_REPORT", new FractionalSelectivity(1.0)); //
		application.addTupleMapping("Caregiver", "ECG_REPORT", "DATA_OFFLOAD", new FractionalSelectivity(1.0)); //
		application.addTupleMapping("Caregiver", "ECG_REPORT", "State_Action", new FractionalSelectivity(1.0)); //
		application.addTupleMapping("Cloud_Analytics", "DATA_OFFLOAD", "Advanced_Analytics", new FractionalSelectivity(0.01)); //
	
		
		 // Defining application loops to monitor the latency of.
		//final AppLoop ONLY_CLOUD = new AppLoop(new ArrayList<String>(){{add("ECG");add("Client");add("Filtering");add("Monitoring");add("Caregiver");add("Client");add("DISPLAY");}}); //add("Cloud_Analytics");
        //List<AppLoop> loops = new ArrayList<AppLoop>(){{ add(ONLY_CLOUD);}};
		//final AppLoop ECG_REPORTING = new AppLoop(new ArrayList<String>(){{add("ECG");add("Client");add("Filtering");add("Monitoring");add("Caregiver");add("Client");add("DISPLAY");}});
        //List<AppLoop> loops = new ArrayList<AppLoop>(){{ add(ECG_REPORTING);}};
		final AppLoop ECG_ANALYTICS = new AppLoop(new ArrayList<String>(){{add("ECG");add("Client");add("Filtering");add("Monitoring");add("Caregiver");}});
        List<AppLoop> loops = new ArrayList<AppLoop>(){{add( ECG_ANALYTICS);}}; 
 		application.setLoops(loops);
		return application;
		}
///random number generators//////////////////////////////////////////////////////////
	private static double getvalue(double d, double e)  { 
	    Random r = new Random(); 
	    double randomValue = d + (e - d) *r.nextDouble(); 
	   // randomValue = r.nextDouble();
	    return randomValue; 
	  } 
	private static Integer getvalue(int min, int max) { 
	    Random r = new Random(); 
	    Integer randomValue = min + r.nextInt()%(max - min); 
	   // randomValue = r.nextInt(max);
	    return randomValue; 
	  }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//scheduled cloudlet processing =30,100,200,300,500 mips for filtering monitoring caregiver  
//scheduled cloudlet processing = 1000  for client and cloudanalytics modules
// mobile id, need Modulename executed with max delay (3:5)
//static Pair<String, Double> moduledeadline = new Pair <String, Double>(null,null);  // mobile id need deadline double
//static List<Pair<String, Double>> moduledeadline = new ArrayList<Pair <String, Double>>();


//if(placement.equals("Latency Differentiated Module Placement")) {		
//System.out.println(String.format("%-30s%s" ,"Per_User Differentiated Module Placement, " ," variable mips between 50 mips, "+  mymips+ " for all modules except cloud plus 1000 mips"));
//}		
//else if(placement.equals("Module Placement Edgeward")) {
//System.out.println(String.format("%-30s%20s%s%30s%10s%s" ,"Per_Module Edgeward Placement","const mips= " , mymips));
//System.out.println("Per_Module Placement,  Tuple's mips= " + mymips);
//}
///else 
//placement=="Latency Module Placement" 
//System.out.println(String.format("%-30s%20s%s%30s%10s%s" ,"Per_User Basic Module Placement","const mips= " , mymips));
//System.out.println("Per_User Basic Module Placement,  const mips= " + mymips);		

//System.out.println("Application Module mips: Client = Filtering = Monitoring = Caregiver = 300 mips , Cloud_Analytics = 600 mips");
//System.out.println("Migration Condition: Mobile Utilization >= 0.3, Proxy/Dept Utilization >= 0.9" );  //, RESOURCE_MANAGE_INTERVAL = 100 ");
//System.out.println("Enhanced Migration Conditions , RESOURCE_MANAGE_INTERVAL = 10 ");
//System.out.println("fog device scheduling interval = 10,  Application module scheduling interval = 300  ");	

//moduledeadline.put("Client", (x+ 15.0000000000000000));
//deadlineInfomodule.put(id,moduledeadline);
//moduledeadline.put("Caregiver", x);
//deadlineInfomodule.put(id,moduledeadline);				
//System.out.println("deadlineInfomodule  "+ deadlineInfomodule);
//deadlineInfomodule.put(id,moduledeadlinelist);				
//moduledeadline.clear();

/*
for(Integer id : idOfEndDevices){
	if (placement.equals("Latency Differentiated Module Placement")) {
		Integer x= getvalue(50, 500);//mymips);
		x= Math.abs(x);
		additionalMipsInfo.put(id, (double)x);  //getvalue(0,mymips)
		}
	else
		additionalMipsInfo.put(id, (double)mymips);
}
*/
/*else if(device.getName().startsWith("d")){
moduleMapping.addModuleToDevice("Filtering", device.getName());
moduleMapping.addModuleToDevice("Monitoring", device.getName());				
} */
//Controller controller = new Controller("master-controller", fogDevices, sensors, actuators);
//controller.submitApplication(application, 0, new ModulePlacementOnlyCloud(fogDevices, sensors, actuators, application));
//controller.submitApplication(application, 0, new LatencyModulePlacement(fogDevices, sensors, actuators, application, moduleMapping));
//controller.submitApplication(application, 0, new LatencyModifiedModulePlacementNew(fogDevices, sensors, actuators, application, moduleMapping));
 //LModulePlacementEdgewards  // LatencyModulePlacementNear

//TRY FogDevice cloud = createFogDevice("cloud", 448000000, 40000000, 100000, 10000000, 0, 0.01, 16*103, 16*83.25); // creates the fog device Cloud at the apex of the hierarchy with level=0
//FogDevice cloud = createFogDevice("cloud", 4480000, 4000000, 100, 10000, 0, 0.01, 16*103, 16*83.25); // creates the fog device Cloud at the apex of the hierarchy with level=0
//FogDevice proxy = createFogDevice("proxy-server", 2800, 4000, 10000, 10000, 1, 0.0, 107.339, 83.4333);

//peList.add(new Pe(0, new PeProvisionerSimple(mips))); // need to store Pe id and MIPS Rating


/*
application.addAppModule("Client", 10, 300, 1000,100,5); // adding module Client to the application model
application.addAppModule("Filtering",10, 300, 1000, 100,4); //
application.addAppModule("Monitoring",10, 300, 1000,100,3); // 
application.addAppModule("Caregiver", 10, 300,1000,100,2); // 
application.addAppModule("Cloud_Analytics",10, 600,1000,250,1); //("Cloud_Analytics",10, 500,1000,500,1); //
*/
/*application.addAppEdge("ECG", "Client", 3000, 1000, "ECG", Tuple.UP, AppEdge.SENSOR);
application.addAppEdge("Client", "Filtering", 3000, 500, "SENSOR_DATA", Tuple.UP, AppEdge.MODULE); //
application.addAppEdge("Filtering", "Monitoring", (30+ mymips), 500, "FILTERED_DATA", Tuple.UP, AppEdge.MODULE); // 
application.addAppEdge("Monitoring", "Cloud_Analytics", 1000, 500, "DATA_OFFLOAD", Tuple.UP, AppEdge.MODULE); // 
application.addAppEdge("Monitoring", "Caregiver", (60+ mymips) , 500, "ECG_REPORT", Tuple.UP, AppEdge.MODULE);  // 
application.addAppEdge("Cloud_Analytics", "Caregiver", 3500, 1000, "Advanced_Analytics", Tuple.DOWN, AppEdge.MODULE);  // 
application.addAppEdge("Caregiver", "Client", 1000 , 500, "State_Action", Tuple.DOWN, AppEdge.MODULE); // 
application.addAppEdge("Client", "DISPLAY",1000, 500, "P_State_Action", Tuple.DOWN, AppEdge.ACTUATOR);  //
 */
//application.addAppEdge("Caregiver", "Cloud_Analytics", 3000, 1000, "DECISION", Tuple.UP, AppEdge.MODULE); //
// application.addTupleMapping("Cloud_Analytics", "DECISION", "Advanced_Analytics", new FractionalSelectivity(0.001)); //
//final AppLoop HBR_Analytics = new AppLoop(new ArrayList<String>(){{add("HBR"); add("Client"); add("Monitoring"); add("Cloud_Analytics"); add("Caregiver"); add("Client"); add("DISPLAY");}});

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10077, count -3525, length 26107
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-10-15 12:36:47.431
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.StringIndexOutOfBoundsException: offset 10077, count -3525, length 26107
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:324)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10077, count -3525, length 26107
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	... 16 more
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10077, count -3525, length 26107
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2020-10-15 12:36:47.432
!MESSAGE offset 10077, count -3525, length 26107
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10077, count -3525, length 26107
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2020-10-15 12:36:47.432
!MESSAGE offset 10077, count -3525, length 26107
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10077, count -3525, length 26107
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-10-15 12:36:47.433
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.StringIndexOutOfBoundsException: offset 10077, count -3525, length 26107
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:324)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10077, count -3525, length 26107
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	... 16 more
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10077, count -3525, length 26107
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2020-10-15 12:36:47.433
!MESSAGE offset 10077, count -3525, length 26107
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10077, count -3525, length 26107
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-10-15 12:36:47.443
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10077, count -3525, length 26107
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-10-15 12:36:47.443
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10077, count -3525, length 26107
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-10-15 12:36:48.007
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10077, count -3525, length 26107
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-10-15 12:36:48.008
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10077, count -3525, length 26107
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-10-15 12:36:48.709
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10077, count -3525, length 26107
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-10-15 12:36:48.710
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10077, count -3525, length 26107
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-10-15 12:36:50.445
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
package org.fog.test.perfeval;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.stream.Collectors;
import org.apache.commons.math3.util.Pair;
import org.cloudbus.cloudsim.Host;
import org.cloudbus.cloudsim.Log;
import org.cloudbus.cloudsim.Pe;
import org.cloudbus.cloudsim.Storage;
import org.cloudbus.cloudsim.core.CloudSim;
import org.cloudbus.cloudsim.power.PowerHost;
import org.cloudbus.cloudsim.provisioners.PeProvisionerSimple;
import org.cloudbus.cloudsim.provisioners.RamProvisionerSimple;
import org.cloudbus.cloudsim.sdn.overbooking.BwProvisionerOverbooking;
import org.cloudbus.cloudsim.sdn.overbooking.PeProvisionerOverbooking;
import org.fog.application.AppEdge;
import org.fog.application.AppLoop;
import org.fog.application.Application;
import org.fog.application.selectivity.FractionalSelectivity;
import org.fog.entities.Actuator;
import org.fog.entities.FogBroker;
import org.fog.entities.FogDevice;
import org.fog.entities.FogDeviceCharacteristics;
import org.fog.entities.Sensor;
import org.fog.entities.Tuple;
import org.fog.placement.Controller;
import org.fog.placement.ControllerEdgeward;
import org.fog.placement.LModulePlacementEdgewards;
import org.fog.placement.LatencyModulePlacementNear;
import org.fog.placement.ModuleMapping;
import org.fog.placement.ModulePlacementDifferentiated;
import org.fog.placement.ModulePlacementEdgewards;
import org.fog.placement.ModulePlacementMapping;
import org.fog.placement.ModulePlacementModified;
import org.fog.placement.ModulePlacementOnlyCloud;
import org.fog.policy.AppModuleAllocationPolicy;
import org.fog.scheduler.StreamOperatorScheduler;
import org.fog.utils.Config;
import org.fog.utils.FogLinearPowerModel;
import org.fog.utils.FogUtils;
import org.fog.utils.TimeKeeper;
import org.fog.utils.distribution.DeterministicDistribution;

/**
 * Simulation setup for  ECG
 * @author Ragaa Shehab
 *
 */ //updateTimingsOnReceipt - checkCloudletCompletion --tupleEndedExecutionUser
public class ECG {
	static List<FogDevice> fogDevices = new ArrayList<FogDevice>();
	static List<Sensor> sensors = new ArrayList<Sensor>();
	static List<Actuator> actuators = new ArrayList<Actuator>();
	static Map<Integer,FogDevice> deviceById = new HashMap<Integer,FogDevice>();	
	static List<Integer> idOfEndDevices = new ArrayList<Integer>();
	static Map<Integer, Double> deadlineInfo = new	HashMap<Integer, Double>();  // mobile id has priority
	static Map<Integer, Double> additionalMipsInfo = new HashMap<Integer, Double>(); // mobile id need tuple mips
	static Map<Integer, Map<String, Double>> deadlineInfomodule = new HashMap<Integer, Map<String,Double>>();  // mobile id has modulename with module priority
	static Map<Integer,List<Map<String, Double>>> deadlineInfomodule1 = new HashMap<Integer, List<Map<String,Double>>>();  // mobile id has modulename with module priority

	static boolean CLOUD = false;
	static int numOfDepts = 1;
	static int numOfMobilesPerDept =5;
	static double ECG_TRANSMISSION_TIME = 50.0 ; // 50.0;   //100, 50, 25 ms   100 //10s= 10000
	static public int mymips= 2000;     
	//static String placement = "Latency Module Placement"; 
	static String placement = "Latency Differentiated Module Placement"; 
	//static String placement = "Module Placement Edgeward";
	//static String placement = "Module Placement Edgeward Differentiated";
	//static String placement = "Latency Modified Module Placement";
	static double MobileCPUload= 0.1;
	
	public static void main(String[] args) {
		Log.print("Starting ECG transmission");	Log.print("             ECG transmission time ms: "); Log.print(ECG_TRANSMISSION_TIME);
		Log.print("     Depts/Mobiles =  "); Log.print (numOfDepts);Log.print("/"); Log.printLine (numOfMobilesPerDept);
		System.out.println("analytics VM mips  2000, Fog device mips: mobile 1000, dept  2800, proxy 16800" ); 

		
		try {
			Log.disable(); 	
			//Config.MAX_SIMULATION_TIME= 100000;
			int num_user = 1; // number of cloud users
			Calendar calendar = Calendar.getInstance();
			boolean trace_flag = false; // mean trace events
			CloudSim.init(num_user, calendar, trace_flag);						
			String appId = "ECG"; 
			FogBroker broker = new FogBroker("broker");			
			createFogDevices(broker.getId(), appId);
			
			Map<String, Double> moduledeadline= new HashMap<String, Double>();
			Map<String, Double> moduledeadline1;
			List<Map<String, Double>> moduledeadline1List;

			for(Integer id : idOfEndDevices){
				Double x= getvalue(5.00, 40.00);
				Double t1= 10.00; Double t2= 5.00; //Double t3= 5.00;
				deadlineInfo.put(id, x);
				
				if (placement.equals("Latency Differentiated Module Placement")||placement.equals("Module Placement Edgeward Differentiated")) {
						if((5.00 < x)&& (x < 10.00)) x=5.00;
						if(10.00 < x)&& (x < 15.00)) x=10.00;
						if(15.00 <  x)&& (x < 20.00)) x=20.00;
						if(20.00 < x)&& (x < 30.00)) x=30.00;
						if(30.00 < x < 40.00) x=40.00;
					
							
						
					additionalMipsInfo.put(id, x*100); //1000
					moduledeadline1=  new HashMap<String,Double>();
					moduledeadline1List= new ArrayList<Map<String, Double>>();
					moduledeadline1.put("Client", x*100);
					moduledeadline1.put("Filtering", x*100);
					moduledeadline1.put("Monitoring", x*100);
					moduledeadline1.put("Caregiver", x*100);
					moduledeadline1.put("Cloud_Analytics", x*100);
					moduledeadline1List.add(moduledeadline1);
					deadlineInfomodule1.put(id, moduledeadline1List);
				}
				else {
					additionalMipsInfo.put(id, (double)mymips);
					moduledeadline1=  new HashMap<String,Double>();
					moduledeadline1List= new ArrayList<Map<String, Double>>();
					moduledeadline1.put("Client", (double)mymips);
					moduledeadline1.put("Filtering", (double)mymips);
					moduledeadline1.put("Monitoring", (double)mymips);
					moduledeadline1.put("Caregiver", (double)mymips);
					moduledeadline1.put("Cloud_Analytics", (double)mymips);
					moduledeadline1List.add(moduledeadline1);
					deadlineInfomodule1.put(id, moduledeadline1List);
				}
				moduledeadline.put("Filtering", (x+t1));
				deadlineInfomodule.put(id,moduledeadline);
				moduledeadline.put("Monitoring", (x+ t2));
				deadlineInfomodule.put(id,moduledeadline);
			}	
			
			deadlineInfo=deadlineInfo.entrySet()
		             .stream().sorted(Map.Entry.comparingByValue())
		             .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -> e1, LinkedHashMap::new));			
				
			Application application = createApplication(appId, broker.getId());
			application.setUserId(broker.getId());
			application.setdeviceById(deviceById);
			application.setidOfEndDevices(idOfEndDevices);
			application.setDeadlineInfo(deadlineInfo);
			application.setDeadlineInfomodule(deadlineInfomodule);
			application.setDeadlineInfomodule1(deadlineInfomodule1);
		    application.setAdditionalMipsInfo(additionalMipsInfo);
		    application.setplacement(placement);
		    application.setMobileCPUload(MobileCPUload);
		    
		    System.out.println(String.format("%-25s%s" ,"User Priority ASC ", application.getDeadlineInfo()));
			System.out.println(String.format("%-25s%s" ,"Module Tuble MIPS ",application.getAdditionalMipsInfo()));
		   /// System.out.println(String.format("%-25s%s" ,"Module Priority ",application.getDeadlineInfomodule()));
		    System.out.println(String.format("%-25s%s" ,"Module Priority1 ",application.getDeadlineInfomodule1()));

		    System.out.println("mobile CPU load "+ application.getMobileCPUload());
		    		
			Controller controller = null;
			ModuleMapping moduleMapping = ModuleMapping.createModuleMapping(); // initializing a module mapping			
			moduleMapping.addModuleToDevice("Cloud_Analytics", "cloud");
			for(FogDevice device : fogDevices){
				if(device.getName().startsWith("m"))
					moduleMapping.addModuleToDevice("Client", device.getName());
				}
			if(CLOUD){			 
				moduleMapping.addModuleToDevice("Caregiver", "cloud");
				moduleMapping.addModuleToDevice("Monitoring", "cloud");
				moduleMapping.addModuleToDevice("Filtering", "cloud");
				System.out.println("cloud only module placement, tuple mips= "+ mymips);
				controller = new ControllerEdgeward("master-controller", fogDevices, sensors, actuators);
				controller.submitApplication(application, 0, new ModulePlacementMapping(fogDevices, application,moduleMapping));
				}
			else {
				moduleMapping.addModuleToDevice("Caregiver", "proxy-server");
				switch (placement) { 
				case "Latency Module Placement":{			
					System.out.println("Per User Basic module placement");//", Tuple mips= "+ mymips
					controller = new Controller("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LatencyModulePlacementNear(fogDevices, sensors, actuators, application, moduleMapping));
					break;}	
				case "Latency Modified Module Placement":{
					System.out.println("Per User Modified module placement");
					controller = new Controller("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new ModulePlacementModified(fogDevices, sensors, actuators, application, moduleMapping));
					break;}
				case "Latency Differentiated Module Placement":{
					System.out.println("Per User Differentiated module placement, variable Module/Tuple mips ");
					controller = new Controller("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LatencyModulePlacementNear(fogDevices, sensors, actuators, application, moduleMapping));
					break;} //ModulePlacementDifferentiated
				case "Module Placement Edgeward":{
					System.out.println("Per module placement");
					controller = new ControllerEdgeward("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LModulePlacementEdgewards(fogDevices, sensors, actuators, application, moduleMapping));
					break;}
				case "Module Placement Edgeward Differentiated":{
					System.out.println("Per module Differentiated placement");
					controller = new ControllerEdgeward("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LModulePlacementEdgewards(fogDevices, sensors, actuators, application, moduleMapping));
					break;}
				}
				}
					
			TimeKeeper.getInstance().setSimulationStartTime(Calendar.getInstance().getTimeInMillis());
			CloudSim.startSimulation();
			CloudSim.stopSimulation();
			Log.printLine("ECG finished!");
		} catch (Exception e) {
			e.printStackTrace();
			Log.printLine("Unwanted errors happen");
		}
	}	
/****************************************************************************************
	 * Creates the fog devices in the physical topology of the simulation.
	 * @param userId
	 * @param appId
	 */
	private static void createFogDevices(int userId, String appId) {  // 44800
		FogDevice cloud = createFogDevice("cloud", 44800, 40000, 100, 10000, 0, 0.01, 16*103, 16*83.25); // creates the fog device Cloud at the apex of the hierarchy with level=0
		cloud.setParentId(-1);		 
		FogDevice proxy = createFogDevice("proxy-server", 16800 , 4000, 10000, 10000, 1, 0.0, 107.339, 83.4333); // 2800
		proxy.setParentId(cloud.getId()); // setting Cloud as parent of the Proxy Server
		proxy.setUplinkLatency(100); // latency of connection from Proxy Server to the Cloud is 100 ms		
		fogDevices.add(cloud);
		deviceById.put(cloud.getId(), cloud);
		fogDevices.add(proxy);
		deviceById.put(proxy.getId(), proxy);		
		for(int i=0;i<numOfDepts;i++){
			addGw(i+"", userId, appId, proxy.getId()); // adding a fog device for every Gateway in physical topology. The parent of each gateway is the Proxy Server
		}	
	}

	private static FogDevice addGw(String id, int userId, String appId, int parentId){
		FogDevice dept = createFogDevice("d-"+id, 2800, 4000, 10000, 10000, 2, 0.0, 107.339, 83.4333); //2800
		fogDevices.add(dept);
		deviceById.put(dept.getId(), dept);
		dept.setParentId(parentId);
		dept.setUplinkLatency(4); // latency of connection between gateways and proxy server is 4 ms
		for(int i=0;i<numOfMobilesPerDept;i++){
			String mobileId = id+"-"+i;
			FogDevice mobile = addMobile(mobileId, userId, appId, dept.getId()); // adding mobiles to the physical topology. Smartphones have been modeled as fog devices as well.
			mobile.setUplinkLatency(2); // latency of connection between the smartphone and proxy server is 4 ms
			fogDevices.add(mobile);
			deviceById.put(mobile.getId(), mobile);
		}
		return dept;
	}
	
	private static FogDevice addMobile(String id, int userId, String appId, int parentId){
		FogDevice mobile = createFogDevice("m-"+id, 1000, 1000, 10000, 270, 3, 0, 87.53, 82.44); //1000   
		mobile.setParentId(parentId);
		idOfEndDevices.add(mobile.getId());
		Sensor ecgsensor = new Sensor("s-"+id, "ECG", userId, appId, new DeterministicDistribution(ECG_TRANSMISSION_TIME)); // inter-transmission time of EEG sensor follows a deterministic distribution
		sensors.add(ecgsensor);
		Actuator display = new Actuator("a-"+id, userId, appId, "DISPLAY");
		actuators.add(display);
		ecgsensor.setGatewayDeviceId(mobile.getId());
		ecgsensor.setLatency(6.0);  // latency of connection between EEG sensors and the parent Smartphone is 6 ms
		display.setGatewayDeviceId(mobile.getId());
		display.setLatency(1.0);  // latency of connection between Display actuator and the parent Smartphone is 1 ms
		return mobile;
	}
	
/*****************************************************************************************
	 * Creates a vanilla fog device
	 * @param nodeName name of the device to be used in simulation
	 * @param mips MIPS
	 * @param ram RAM
	 * @param upBw uplink bandwidth
	 * @param downBw downlink bandwidth
	 * @param level hierarchy level of the device
	 * @param ratePerMips cost rate per MIPS used
	 * @param busyPower
	 * @param idlePower
	 * @return
	 */
	private static FogDevice createFogDevice(String nodeName, long mips,
			int ram, long upBw, long downBw, int level, double ratePerMips, double busyPower, double idlePower) {
		
		List<Pe> peList = new ArrayList<Pe>();
		// 3. Create PEs and add these into a list.
		peList.add(new Pe(0, new PeProvisionerOverbooking(mips))); // need to store Pe id and MIPS Rating
		
		int hostId = FogUtils.generateEntityId();
		long storage = 1000000; // host storage
		int bw = 10000;
		PowerHost host = new PowerHost(
				hostId,
				new RamProvisionerSimple(ram),
				new BwProvisionerOverbooking(bw),
				storage,
				peList,
				new StreamOperatorScheduler(peList),
				new FogLinearPowerModel(busyPower, idlePower)
			);

		List<Host> hostList = new ArrayList<Host>();
		hostList.add(host);

		String arch = "x86"; // system architecture
		String os = "Linux"; // operating system
		String vmm = "Xen";
		double time_zone = 10.0; // time zone this resource located
		double cost = 3.0; // the cost of using processing in this resource
		double costPerMem = 0.05; // the cost of using memory in this resource
		double costPerStorage = 0.001; // the cost of using storage in this	// resource
		double costPerBw = 0.0; // the cost of using bw in this resource
		LinkedList<Storage> storageList = new LinkedList<Storage>(); // we are not adding SAN devices by now

		FogDeviceCharacteristics characteristics = new FogDeviceCharacteristics(
				arch, os, vmm, host, time_zone, cost, costPerMem,
				costPerStorage, costPerBw);

		FogDevice fogdevice = null;
		try {
			fogdevice = new FogDevice(nodeName, characteristics, 
					new AppModuleAllocationPolicy(hostList), storageList, 10 , upBw, downBw, 0, ratePerMips); //10 : schedulingInterval  0 uplink  latency		
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		fogdevice.setLevel(level);
		return fogdevice;
	}

/******************************************************************************************
	 * Function to create the EEG Tractor Beam game application in the DDF model. 
	 * @param appId unique identifier of the application
	 * @param userId identifier of the user of the application
	 * @return
	 */
	@SuppressWarnings({"serial" })
	private static Application createApplication(String appId, int userId){
		
		Application application = Application.createApplication(appId, userId); // creates an empty application model (empty directed graph)
		
		// Adding modules (vertices) to the application model (directed graph)
		application.addAppModule("Client", 10, 2000, 1000,100,5); //250Name,int ram, int mips, long size, long bw, int modprty) size is the image size (MB)
		application.addAppModule("Filtering",10, 2000, 500, 100,4); //150
		application.addAppModule("Monitoring",10, 2000, 500,100,3); //150 
		application.addAppModule("Caregiver", 10, 2000,1000,100,2); // 150
		application.addAppModule("Cloud_Analytics",10, 3000,1000,250,1); //500("Cloud_Analytics",10, 500,1000,500,1); //
		
		// Connecting the application modules (vertices) in the application model (directed graph) with edges
		//source, destination, double tupleCpuLength, double tupleNwLength, String tupleType, int direction, int edgeType){
		application.addAppEdge("ECG", "Client", 2000, 500, "ECG", Tuple.UP, AppEdge.SENSOR);
		application.addAppEdge("Client", "Filtering", 2000, 500, "SENSOR_DATA", Tuple.UP, AppEdge.MODULE); //
		application.addAppEdge("Filtering", "Monitoring", mymips, 500, "FILTERED_DATA", Tuple.UP, AppEdge.MODULE); //
		application.addAppEdge("Monitoring", "Caregiver", mymips, 500, "ECG_REPORT", Tuple.UP, AppEdge.MODULE);  //
		application.addAppEdge("Caregiver", "Cloud_Analytics", mymips, 500, "DATA_OFFLOAD", Tuple.UP, AppEdge.MODULE); //		
		application.addAppEdge("Caregiver", "Client", mymips, 500, "State_Action", Tuple.DOWN, AppEdge.MODULE); //  
		application.addAppEdge("Client", "DISPLAY",2000, 500, "P_State_Action", Tuple.DOWN, AppEdge.ACTUATOR);  //
		application.addAppEdge("Cloud_Analytics", "Caregiver", 2000, 1000, "Advanced_Analytics", Tuple.DOWN, AppEdge.MODULE);  
		
 	    //Defining the input-output relationships (represented by selectivity) of the application modules. 
		application.addTupleMapping("Client", "ECG", "SENSOR_DATA", new FractionalSelectivity(1.0)); // 
		application.addTupleMapping("Client", "State_Action", "P_State_Action", new FractionalSelectivity(1.0)); //  
		application.addTupleMapping("Filtering", "SENSOR_DATA", "FILTERED_DATA", new FractionalSelectivity(1.0)); // 
		application.addTupleMapping("Monitoring", "FILTERED_DATA", "ECG_REPORT", new FractionalSelectivity(1.0)); //
		application.addTupleMapping("Caregiver", "ECG_REPORT", "DATA_OFFLOAD", new FractionalSelectivity(1.0)); //
		application.addTupleMapping("Caregiver", "ECG_REPORT", "State_Action", new FractionalSelectivity(1.0)); //
		application.addTupleMapping("Cloud_Analytics", "DATA_OFFLOAD", "Advanced_Analytics", new FractionalSelectivity(0.01)); //
	
		
		 // Defining application loops to monitor the latency of.
		//final AppLoop ONLY_CLOUD = new AppLoop(new ArrayList<String>(){{add("ECG");add("Client");add("Filtering");add("Monitoring");add("Caregiver");add("Client");add("DISPLAY");}}); //add("Cloud_Analytics");
        //List<AppLoop> loops = new ArrayList<AppLoop>(){{ add(ONLY_CLOUD);}};
		//final AppLoop ECG_REPORTING = new AppLoop(new ArrayList<String>(){{add("ECG");add("Client");add("Filtering");add("Monitoring");add("Caregiver");add("Client");add("DISPLAY");}});
        //List<AppLoop> loops = new ArrayList<AppLoop>(){{ add(ECG_REPORTING);}};
		final AppLoop ECG_ANALYTICS = new AppLoop(new ArrayList<String>(){{add("ECG");add("Client");add("Filtering");add("Monitoring");add("Caregiver");}});
        List<AppLoop> loops = new ArrayList<AppLoop>(){{add( ECG_ANALYTICS);}}; 
 		application.setLoops(loops);
		return application;
		}
///random number generators//////////////////////////////////////////////////////////
	private static double getvalue(double d, double e)  { 
	    Random r = new Random(); 
	    double randomValue = d + (e - d) *r.nextDouble(); 
	   // randomValue = r.nextDouble();
	    return randomValue; 
	  } 
	private static Integer getvalue(int min, int max) { 
	    Random r = new Random(); 
	    Integer randomValue = min + r.nextInt()%(max - min); 
	   // randomValue = r.nextInt(max);
	    return randomValue; 
	  }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//scheduled cloudlet processing =30,100,200,300,500 mips for filtering monitoring caregiver  
//scheduled cloudlet processing = 1000  for client and cloudanalytics modules
// mobile id, need Modulename executed with max delay (3:5)
//static Pair<String, Double> moduledeadline = new Pair <String, Double>(null,null);  // mobile id need deadline double
//static List<Pair<String, Double>> moduledeadline = new ArrayList<Pair <String, Double>>();


//if(placement.equals("Latency Differentiated Module Placement")) {		
//System.out.println(String.format("%-30s%s" ,"Per_User Differentiated Module Placement, " ," variable mips between 50 mips, "+  mymips+ " for all modules except cloud plus 1000 mips"));
//}		
//else if(placement.equals("Module Placement Edgeward")) {
//System.out.println(String.format("%-30s%20s%s%30s%10s%s" ,"Per_Module Edgeward Placement","const mips= " , mymips));
//System.out.println("Per_Module Placement,  Tuple's mips= " + mymips);
//}
///else 
//placement=="Latency Module Placement" 
//System.out.println(String.format("%-30s%20s%s%30s%10s%s" ,"Per_User Basic Module Placement","const mips= " , mymips));
//System.out.println("Per_User Basic Module Placement,  const mips= " + mymips);		

//System.out.println("Application Module mips: Client = Filtering = Monitoring = Caregiver = 300 mips , Cloud_Analytics = 600 mips");
//System.out.println("Migration Condition: Mobile Utilization >= 0.3, Proxy/Dept Utilization >= 0.9" );  //, RESOURCE_MANAGE_INTERVAL = 100 ");
//System.out.println("Enhanced Migration Conditions , RESOURCE_MANAGE_INTERVAL = 10 ");
//System.out.println("fog device scheduling interval = 10,  Application module scheduling interval = 300  ");	

//moduledeadline.put("Client", (x+ 15.0000000000000000));
//deadlineInfomodule.put(id,moduledeadline);
//moduledeadline.put("Caregiver", x);
//deadlineInfomodule.put(id,moduledeadline);				
//System.out.println("deadlineInfomodule  "+ deadlineInfomodule);
//deadlineInfomodule.put(id,moduledeadlinelist);				
//moduledeadline.clear();

/*
for(Integer id : idOfEndDevices){
	if (placement.equals("Latency Differentiated Module Placement")) {
		Integer x= getvalue(50, 500);//mymips);
		x= Math.abs(x);
		additionalMipsInfo.put(id, (double)x);  //getvalue(0,mymips)
		}
	else
		additionalMipsInfo.put(id, (double)mymips);
}
*/
/*else if(device.getName().startsWith("d")){
moduleMapping.addModuleToDevice("Filtering", device.getName());
moduleMapping.addModuleToDevice("Monitoring", device.getName());				
} */
//Controller controller = new Controller("master-controller", fogDevices, sensors, actuators);
//controller.submitApplication(application, 0, new ModulePlacementOnlyCloud(fogDevices, sensors, actuators, application));
//controller.submitApplication(application, 0, new LatencyModulePlacement(fogDevices, sensors, actuators, application, moduleMapping));
//controller.submitApplication(application, 0, new LatencyModifiedModulePlacementNew(fogDevices, sensors, actuators, application, moduleMapping));
 //LModulePlacementEdgewards  // LatencyModulePlacementNear

//TRY FogDevice cloud = createFogDevice("cloud", 448000000, 40000000, 100000, 10000000, 0, 0.01, 16*103, 16*83.25); // creates the fog device Cloud at the apex of the hierarchy with level=0
//FogDevice cloud = createFogDevice("cloud", 4480000, 4000000, 100, 10000, 0, 0.01, 16*103, 16*83.25); // creates the fog device Cloud at the apex of the hierarchy with level=0
//FogDevice proxy = createFogDevice("proxy-server", 2800, 4000, 10000, 10000, 1, 0.0, 107.339, 83.4333);

//peList.add(new Pe(0, new PeProvisionerSimple(mips))); // need to store Pe id and MIPS Rating


/*
application.addAppModule("Client", 10, 300, 1000,100,5); // adding module Client to the application model
application.addAppModule("Filtering",10, 300, 1000, 100,4); //
application.addAppModule("Monitoring",10, 300, 1000,100,3); // 
application.addAppModule("Caregiver", 10, 300,1000,100,2); // 
application.addAppModule("Cloud_Analytics",10, 600,1000,250,1); //("Cloud_Analytics",10, 500,1000,500,1); //
*/
/*application.addAppEdge("ECG", "Client", 3000, 1000, "ECG", Tuple.UP, AppEdge.SENSOR);
application.addAppEdge("Client", "Filtering", 3000, 500, "SENSOR_DATA", Tuple.UP, AppEdge.MODULE); //
application.addAppEdge("Filtering", "Monitoring", (30+ mymips), 500, "FILTERED_DATA", Tuple.UP, AppEdge.MODULE); // 
application.addAppEdge("Monitoring", "Cloud_Analytics", 1000, 500, "DATA_OFFLOAD", Tuple.UP, AppEdge.MODULE); // 
application.addAppEdge("Monitoring", "Caregiver", (60+ mymips) , 500, "ECG_REPORT", Tuple.UP, AppEdge.MODULE);  // 
application.addAppEdge("Cloud_Analytics", "Caregiver", 3500, 1000, "Advanced_Analytics", Tuple.DOWN, AppEdge.MODULE);  // 
application.addAppEdge("Caregiver", "Client", 1000 , 500, "State_Action", Tuple.DOWN, AppEdge.MODULE); // 
application.addAppEdge("Client", "DISPLAY",1000, 500, "P_State_Action", Tuple.DOWN, AppEdge.ACTUATOR);  //
 */
//application.addAppEdge("Caregiver", "Cloud_Analytics", 3000, 1000, "DECISION", Tuple.UP, AppEdge.MODULE); //
// application.addTupleMapping("Cloud_Analytics", "DECISION", "Advanced_Analytics", new FractionalSelectivity(0.001)); //
//final AppLoop HBR_Analytics = new AppLoop(new ArrayList<String>(){{add("HBR"); add("Client"); add("Monitoring"); add("Cloud_Analytics"); add("Caregiver"); add("Client"); add("DISPLAY");}});

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10078, count -3525, length 26108
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-10-15 12:36:50.446
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.StringIndexOutOfBoundsException: offset 10078, count -3525, length 26108
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:324)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10078, count -3525, length 26108
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	... 16 more
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10078, count -3525, length 26108
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2020-10-15 12:36:50.447
!MESSAGE offset 10078, count -3525, length 26108
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10078, count -3525, length 26108
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2020-10-15 12:36:50.447
!MESSAGE offset 10078, count -3525, length 26108
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10078, count -3525, length 26108
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-10-15 12:36:50.448
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.StringIndexOutOfBoundsException: offset 10078, count -3525, length 26108
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:324)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10078, count -3525, length 26108
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	... 16 more
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10078, count -3525, length 26108
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2020-10-15 12:36:50.448
!MESSAGE offset 10078, count -3525, length 26108
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10078, count -3525, length 26108
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-10-15 12:36:50.458
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10078, count -3525, length 26108
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-10-15 12:36:50.460
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10078, count -3525, length 26108
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-10-15 12:36:50.896
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10078, count -3525, length 26108
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-10-15 12:36:50.897
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10078, count -3525, length 26108
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-10-15 12:36:53.132
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10078, count -3525, length 26108
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-10-15 12:36:53.133
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10078, count -3525, length 26108
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-10-15 12:36:54.632
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10078, count -3525, length 26108
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-10-15 12:36:54.633
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10078, count -3525, length 26108
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-10-15 12:36:55.961
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
package org.fog.test.perfeval;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.stream.Collectors;
import org.apache.commons.math3.util.Pair;
import org.cloudbus.cloudsim.Host;
import org.cloudbus.cloudsim.Log;
import org.cloudbus.cloudsim.Pe;
import org.cloudbus.cloudsim.Storage;
import org.cloudbus.cloudsim.core.CloudSim;
import org.cloudbus.cloudsim.power.PowerHost;
import org.cloudbus.cloudsim.provisioners.PeProvisionerSimple;
import org.cloudbus.cloudsim.provisioners.RamProvisionerSimple;
import org.cloudbus.cloudsim.sdn.overbooking.BwProvisionerOverbooking;
import org.cloudbus.cloudsim.sdn.overbooking.PeProvisionerOverbooking;
import org.fog.application.AppEdge;
import org.fog.application.AppLoop;
import org.fog.application.Application;
import org.fog.application.selectivity.FractionalSelectivity;
import org.fog.entities.Actuator;
import org.fog.entities.FogBroker;
import org.fog.entities.FogDevice;
import org.fog.entities.FogDeviceCharacteristics;
import org.fog.entities.Sensor;
import org.fog.entities.Tuple;
import org.fog.placement.Controller;
import org.fog.placement.ControllerEdgeward;
import org.fog.placement.LModulePlacementEdgewards;
import org.fog.placement.LatencyModulePlacementNear;
import org.fog.placement.ModuleMapping;
import org.fog.placement.ModulePlacementDifferentiated;
import org.fog.placement.ModulePlacementEdgewards;
import org.fog.placement.ModulePlacementMapping;
import org.fog.placement.ModulePlacementModified;
import org.fog.placement.ModulePlacementOnlyCloud;
import org.fog.policy.AppModuleAllocationPolicy;
import org.fog.scheduler.StreamOperatorScheduler;
import org.fog.utils.Config;
import org.fog.utils.FogLinearPowerModel;
import org.fog.utils.FogUtils;
import org.fog.utils.TimeKeeper;
import org.fog.utils.distribution.DeterministicDistribution;

/**
 * Simulation setup for  ECG
 * @author Ragaa Shehab
 *
 */ //updateTimingsOnReceipt - checkCloudletCompletion --tupleEndedExecutionUser
public class ECG {
	static List<FogDevice> fogDevices = new ArrayList<FogDevice>();
	static List<Sensor> sensors = new ArrayList<Sensor>();
	static List<Actuator> actuators = new ArrayList<Actuator>();
	static Map<Integer,FogDevice> deviceById = new HashMap<Integer,FogDevice>();	
	static List<Integer> idOfEndDevices = new ArrayList<Integer>();
	static Map<Integer, Double> deadlineInfo = new	HashMap<Integer, Double>();  // mobile id has priority
	static Map<Integer, Double> additionalMipsInfo = new HashMap<Integer, Double>(); // mobile id need tuple mips
	static Map<Integer, Map<String, Double>> deadlineInfomodule = new HashMap<Integer, Map<String,Double>>();  // mobile id has modulename with module priority
	static Map<Integer,List<Map<String, Double>>> deadlineInfomodule1 = new HashMap<Integer, List<Map<String,Double>>>();  // mobile id has modulename with module priority

	static boolean CLOUD = false;
	static int numOfDepts = 1;
	static int numOfMobilesPerDept =5;
	static double ECG_TRANSMISSION_TIME = 50.0 ; // 50.0;   //100, 50, 25 ms   100 //10s= 10000
	static public int mymips= 2000;     
	//static String placement = "Latency Module Placement"; 
	static String placement = "Latency Differentiated Module Placement"; 
	//static String placement = "Module Placement Edgeward";
	//static String placement = "Module Placement Edgeward Differentiated";
	//static String placement = "Latency Modified Module Placement";
	static double MobileCPUload= 0.1;
	
	public static void main(String[] args) {
		Log.print("Starting ECG transmission");	Log.print("             ECG transmission time ms: "); Log.print(ECG_TRANSMISSION_TIME);
		Log.print("     Depts/Mobiles =  "); Log.print (numOfDepts);Log.print("/"); Log.printLine (numOfMobilesPerDept);
		System.out.println("analytics VM mips  2000, Fog device mips: mobile 1000, dept  2800, proxy 16800" ); 

		
		try {
			Log.disable(); 	
			//Config.MAX_SIMULATION_TIME= 100000;
			int num_user = 1; // number of cloud users
			Calendar calendar = Calendar.getInstance();
			boolean trace_flag = false; // mean trace events
			CloudSim.init(num_user, calendar, trace_flag);						
			String appId = "ECG"; 
			FogBroker broker = new FogBroker("broker");			
			createFogDevices(broker.getId(), appId);
			
			Map<String, Double> moduledeadline= new HashMap<String, Double>();
			Map<String, Double> moduledeadline1;
			List<Map<String, Double>> moduledeadline1List;

			for(Integer id : idOfEndDevices){
				Double x= getvalue(5.00, 40.00);
				Double t1= 10.00; Double t2= 5.00; //Double t3= 5.00;
				deadlineInfo.put(id, x);
				
				if (placement.equals("Latency Differentiated Module Placement")||placement.equals("Module Placement Edgeward Differentiated")) {
						if((5.00 < x)&& (x < 10.00)) x=5.00;
						if(10.00 < x)&& (x < 15.00)) x=10.00;
						if(15.00 <  x)&& (x < 20.00)) x=20.00;
						if(20.00 < x)&& (x < 30.00)) x=30.00;
						if(30.00 <  x)&& (x < 40.00) x=40.00;
					
							
						
					additionalMipsInfo.put(id, x*100); //1000
					moduledeadline1=  new HashMap<String,Double>();
					moduledeadline1List= new ArrayList<Map<String, Double>>();
					moduledeadline1.put("Client", x*100);
					moduledeadline1.put("Filtering", x*100);
					moduledeadline1.put("Monitoring", x*100);
					moduledeadline1.put("Caregiver", x*100);
					moduledeadline1.put("Cloud_Analytics", x*100);
					moduledeadline1List.add(moduledeadline1);
					deadlineInfomodule1.put(id, moduledeadline1List);
				}
				else {
					additionalMipsInfo.put(id, (double)mymips);
					moduledeadline1=  new HashMap<String,Double>();
					moduledeadline1List= new ArrayList<Map<String, Double>>();
					moduledeadline1.put("Client", (double)mymips);
					moduledeadline1.put("Filtering", (double)mymips);
					moduledeadline1.put("Monitoring", (double)mymips);
					moduledeadline1.put("Caregiver", (double)mymips);
					moduledeadline1.put("Cloud_Analytics", (double)mymips);
					moduledeadline1List.add(moduledeadline1);
					deadlineInfomodule1.put(id, moduledeadline1List);
				}
				moduledeadline.put("Filtering", (x+t1));
				deadlineInfomodule.put(id,moduledeadline);
				moduledeadline.put("Monitoring", (x+ t2));
				deadlineInfomodule.put(id,moduledeadline);
			}	
			
			deadlineInfo=deadlineInfo.entrySet()
		             .stream().sorted(Map.Entry.comparingByValue())
		             .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -> e1, LinkedHashMap::new));			
				
			Application application = createApplication(appId, broker.getId());
			application.setUserId(broker.getId());
			application.setdeviceById(deviceById);
			application.setidOfEndDevices(idOfEndDevices);
			application.setDeadlineInfo(deadlineInfo);
			application.setDeadlineInfomodule(deadlineInfomodule);
			application.setDeadlineInfomodule1(deadlineInfomodule1);
		    application.setAdditionalMipsInfo(additionalMipsInfo);
		    application.setplacement(placement);
		    application.setMobileCPUload(MobileCPUload);
		    
		    System.out.println(String.format("%-25s%s" ,"User Priority ASC ", application.getDeadlineInfo()));
			System.out.println(String.format("%-25s%s" ,"Module Tuble MIPS ",application.getAdditionalMipsInfo()));
		   /// System.out.println(String.format("%-25s%s" ,"Module Priority ",application.getDeadlineInfomodule()));
		    System.out.println(String.format("%-25s%s" ,"Module Priority1 ",application.getDeadlineInfomodule1()));

		    System.out.println("mobile CPU load "+ application.getMobileCPUload());
		    		
			Controller controller = null;
			ModuleMapping moduleMapping = ModuleMapping.createModuleMapping(); // initializing a module mapping			
			moduleMapping.addModuleToDevice("Cloud_Analytics", "cloud");
			for(FogDevice device : fogDevices){
				if(device.getName().startsWith("m"))
					moduleMapping.addModuleToDevice("Client", device.getName());
				}
			if(CLOUD){			 
				moduleMapping.addModuleToDevice("Caregiver", "cloud");
				moduleMapping.addModuleToDevice("Monitoring", "cloud");
				moduleMapping.addModuleToDevice("Filtering", "cloud");
				System.out.println("cloud only module placement, tuple mips= "+ mymips);
				controller = new ControllerEdgeward("master-controller", fogDevices, sensors, actuators);
				controller.submitApplication(application, 0, new ModulePlacementMapping(fogDevices, application,moduleMapping));
				}
			else {
				moduleMapping.addModuleToDevice("Caregiver", "proxy-server");
				switch (placement) { 
				case "Latency Module Placement":{			
					System.out.println("Per User Basic module placement");//", Tuple mips= "+ mymips
					controller = new Controller("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LatencyModulePlacementNear(fogDevices, sensors, actuators, application, moduleMapping));
					break;}	
				case "Latency Modified Module Placement":{
					System.out.println("Per User Modified module placement");
					controller = new Controller("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new ModulePlacementModified(fogDevices, sensors, actuators, application, moduleMapping));
					break;}
				case "Latency Differentiated Module Placement":{
					System.out.println("Per User Differentiated module placement, variable Module/Tuple mips ");
					controller = new Controller("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LatencyModulePlacementNear(fogDevices, sensors, actuators, application, moduleMapping));
					break;} //ModulePlacementDifferentiated
				case "Module Placement Edgeward":{
					System.out.println("Per module placement");
					controller = new ControllerEdgeward("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LModulePlacementEdgewards(fogDevices, sensors, actuators, application, moduleMapping));
					break;}
				case "Module Placement Edgeward Differentiated":{
					System.out.println("Per module Differentiated placement");
					controller = new ControllerEdgeward("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LModulePlacementEdgewards(fogDevices, sensors, actuators, application, moduleMapping));
					break;}
				}
				}
					
			TimeKeeper.getInstance().setSimulationStartTime(Calendar.getInstance().getTimeInMillis());
			CloudSim.startSimulation();
			CloudSim.stopSimulation();
			Log.printLine("ECG finished!");
		} catch (Exception e) {
			e.printStackTrace();
			Log.printLine("Unwanted errors happen");
		}
	}	
/****************************************************************************************
	 * Creates the fog devices in the physical topology of the simulation.
	 * @param userId
	 * @param appId
	 */
	private static void createFogDevices(int userId, String appId) {  // 44800
		FogDevice cloud = createFogDevice("cloud", 44800, 40000, 100, 10000, 0, 0.01, 16*103, 16*83.25); // creates the fog device Cloud at the apex of the hierarchy with level=0
		cloud.setParentId(-1);		 
		FogDevice proxy = createFogDevice("proxy-server", 16800 , 4000, 10000, 10000, 1, 0.0, 107.339, 83.4333); // 2800
		proxy.setParentId(cloud.getId()); // setting Cloud as parent of the Proxy Server
		proxy.setUplinkLatency(100); // latency of connection from Proxy Server to the Cloud is 100 ms		
		fogDevices.add(cloud);
		deviceById.put(cloud.getId(), cloud);
		fogDevices.add(proxy);
		deviceById.put(proxy.getId(), proxy);		
		for(int i=0;i<numOfDepts;i++){
			addGw(i+"", userId, appId, proxy.getId()); // adding a fog device for every Gateway in physical topology. The parent of each gateway is the Proxy Server
		}	
	}

	private static FogDevice addGw(String id, int userId, String appId, int parentId){
		FogDevice dept = createFogDevice("d-"+id, 2800, 4000, 10000, 10000, 2, 0.0, 107.339, 83.4333); //2800
		fogDevices.add(dept);
		deviceById.put(dept.getId(), dept);
		dept.setParentId(parentId);
		dept.setUplinkLatency(4); // latency of connection between gateways and proxy server is 4 ms
		for(int i=0;i<numOfMobilesPerDept;i++){
			String mobileId = id+"-"+i;
			FogDevice mobile = addMobile(mobileId, userId, appId, dept.getId()); // adding mobiles to the physical topology. Smartphones have been modeled as fog devices as well.
			mobile.setUplinkLatency(2); // latency of connection between the smartphone and proxy server is 4 ms
			fogDevices.add(mobile);
			deviceById.put(mobile.getId(), mobile);
		}
		return dept;
	}
	
	private static FogDevice addMobile(String id, int userId, String appId, int parentId){
		FogDevice mobile = createFogDevice("m-"+id, 1000, 1000, 10000, 270, 3, 0, 87.53, 82.44); //1000   
		mobile.setParentId(parentId);
		idOfEndDevices.add(mobile.getId());
		Sensor ecgsensor = new Sensor("s-"+id, "ECG", userId, appId, new DeterministicDistribution(ECG_TRANSMISSION_TIME)); // inter-transmission time of EEG sensor follows a deterministic distribution
		sensors.add(ecgsensor);
		Actuator display = new Actuator("a-"+id, userId, appId, "DISPLAY");
		actuators.add(display);
		ecgsensor.setGatewayDeviceId(mobile.getId());
		ecgsensor.setLatency(6.0);  // latency of connection between EEG sensors and the parent Smartphone is 6 ms
		display.setGatewayDeviceId(mobile.getId());
		display.setLatency(1.0);  // latency of connection between Display actuator and the parent Smartphone is 1 ms
		return mobile;
	}
	
/*****************************************************************************************
	 * Creates a vanilla fog device
	 * @param nodeName name of the device to be used in simulation
	 * @param mips MIPS
	 * @param ram RAM
	 * @param upBw uplink bandwidth
	 * @param downBw downlink bandwidth
	 * @param level hierarchy level of the device
	 * @param ratePerMips cost rate per MIPS used
	 * @param busyPower
	 * @param idlePower
	 * @return
	 */
	private static FogDevice createFogDevice(String nodeName, long mips,
			int ram, long upBw, long downBw, int level, double ratePerMips, double busyPower, double idlePower) {
		
		List<Pe> peList = new ArrayList<Pe>();
		// 3. Create PEs and add these into a list.
		peList.add(new Pe(0, new PeProvisionerOverbooking(mips))); // need to store Pe id and MIPS Rating
		
		int hostId = FogUtils.generateEntityId();
		long storage = 1000000; // host storage
		int bw = 10000;
		PowerHost host = new PowerHost(
				hostId,
				new RamProvisionerSimple(ram),
				new BwProvisionerOverbooking(bw),
				storage,
				peList,
				new StreamOperatorScheduler(peList),
				new FogLinearPowerModel(busyPower, idlePower)
			);

		List<Host> hostList = new ArrayList<Host>();
		hostList.add(host);

		String arch = "x86"; // system architecture
		String os = "Linux"; // operating system
		String vmm = "Xen";
		double time_zone = 10.0; // time zone this resource located
		double cost = 3.0; // the cost of using processing in this resource
		double costPerMem = 0.05; // the cost of using memory in this resource
		double costPerStorage = 0.001; // the cost of using storage in this	// resource
		double costPerBw = 0.0; // the cost of using bw in this resource
		LinkedList<Storage> storageList = new LinkedList<Storage>(); // we are not adding SAN devices by now

		FogDeviceCharacteristics characteristics = new FogDeviceCharacteristics(
				arch, os, vmm, host, time_zone, cost, costPerMem,
				costPerStorage, costPerBw);

		FogDevice fogdevice = null;
		try {
			fogdevice = new FogDevice(nodeName, characteristics, 
					new AppModuleAllocationPolicy(hostList), storageList, 10 , upBw, downBw, 0, ratePerMips); //10 : schedulingInterval  0 uplink  latency		
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		fogdevice.setLevel(level);
		return fogdevice;
	}

/******************************************************************************************
	 * Function to create the EEG Tractor Beam game application in the DDF model. 
	 * @param appId unique identifier of the application
	 * @param userId identifier of the user of the application
	 * @return
	 */
	@SuppressWarnings({"serial" })
	private static Application createApplication(String appId, int userId){
		
		Application application = Application.createApplication(appId, userId); // creates an empty application model (empty directed graph)
		
		// Adding modules (vertices) to the application model (directed graph)
		application.addAppModule("Client", 10, 2000, 1000,100,5); //250Name,int ram, int mips, long size, long bw, int modprty) size is the image size (MB)
		application.addAppModule("Filtering",10, 2000, 500, 100,4); //150
		application.addAppModule("Monitoring",10, 2000, 500,100,3); //150 
		application.addAppModule("Caregiver", 10, 2000,1000,100,2); // 150
		application.addAppModule("Cloud_Analytics",10, 3000,1000,250,1); //500("Cloud_Analytics",10, 500,1000,500,1); //
		
		// Connecting the application modules (vertices) in the application model (directed graph) with edges
		//source, destination, double tupleCpuLength, double tupleNwLength, String tupleType, int direction, int edgeType){
		application.addAppEdge("ECG", "Client", 2000, 500, "ECG", Tuple.UP, AppEdge.SENSOR);
		application.addAppEdge("Client", "Filtering", 2000, 500, "SENSOR_DATA", Tuple.UP, AppEdge.MODULE); //
		application.addAppEdge("Filtering", "Monitoring", mymips, 500, "FILTERED_DATA", Tuple.UP, AppEdge.MODULE); //
		application.addAppEdge("Monitoring", "Caregiver", mymips, 500, "ECG_REPORT", Tuple.UP, AppEdge.MODULE);  //
		application.addAppEdge("Caregiver", "Cloud_Analytics", mymips, 500, "DATA_OFFLOAD", Tuple.UP, AppEdge.MODULE); //		
		application.addAppEdge("Caregiver", "Client", mymips, 500, "State_Action", Tuple.DOWN, AppEdge.MODULE); //  
		application.addAppEdge("Client", "DISPLAY",2000, 500, "P_State_Action", Tuple.DOWN, AppEdge.ACTUATOR);  //
		application.addAppEdge("Cloud_Analytics", "Caregiver", 2000, 1000, "Advanced_Analytics", Tuple.DOWN, AppEdge.MODULE);  
		
 	    //Defining the input-output relationships (represented by selectivity) of the application modules. 
		application.addTupleMapping("Client", "ECG", "SENSOR_DATA", new FractionalSelectivity(1.0)); // 
		application.addTupleMapping("Client", "State_Action", "P_State_Action", new FractionalSelectivity(1.0)); //  
		application.addTupleMapping("Filtering", "SENSOR_DATA", "FILTERED_DATA", new FractionalSelectivity(1.0)); // 
		application.addTupleMapping("Monitoring", "FILTERED_DATA", "ECG_REPORT", new FractionalSelectivity(1.0)); //
		application.addTupleMapping("Caregiver", "ECG_REPORT", "DATA_OFFLOAD", new FractionalSelectivity(1.0)); //
		application.addTupleMapping("Caregiver", "ECG_REPORT", "State_Action", new FractionalSelectivity(1.0)); //
		application.addTupleMapping("Cloud_Analytics", "DATA_OFFLOAD", "Advanced_Analytics", new FractionalSelectivity(0.01)); //
	
		
		 // Defining application loops to monitor the latency of.
		//final AppLoop ONLY_CLOUD = new AppLoop(new ArrayList<String>(){{add("ECG");add("Client");add("Filtering");add("Monitoring");add("Caregiver");add("Client");add("DISPLAY");}}); //add("Cloud_Analytics");
        //List<AppLoop> loops = new ArrayList<AppLoop>(){{ add(ONLY_CLOUD);}};
		//final AppLoop ECG_REPORTING = new AppLoop(new ArrayList<String>(){{add("ECG");add("Client");add("Filtering");add("Monitoring");add("Caregiver");add("Client");add("DISPLAY");}});
        //List<AppLoop> loops = new ArrayList<AppLoop>(){{ add(ECG_REPORTING);}};
		final AppLoop ECG_ANALYTICS = new AppLoop(new ArrayList<String>(){{add("ECG");add("Client");add("Filtering");add("Monitoring");add("Caregiver");}});
        List<AppLoop> loops = new ArrayList<AppLoop>(){{add( ECG_ANALYTICS);}}; 
 		application.setLoops(loops);
		return application;
		}
///random number generators//////////////////////////////////////////////////////////
	private static double getvalue(double d, double e)  { 
	    Random r = new Random(); 
	    double randomValue = d + (e - d) *r.nextDouble(); 
	   // randomValue = r.nextDouble();
	    return randomValue; 
	  } 
	private static Integer getvalue(int min, int max) { 
	    Random r = new Random(); 
	    Integer randomValue = min + r.nextInt()%(max - min); 
	   // randomValue = r.nextInt(max);
	    return randomValue; 
	  }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//scheduled cloudlet processing =30,100,200,300,500 mips for filtering monitoring caregiver  
//scheduled cloudlet processing = 1000  for client and cloudanalytics modules
// mobile id, need Modulename executed with max delay (3:5)
//static Pair<String, Double> moduledeadline = new Pair <String, Double>(null,null);  // mobile id need deadline double
//static List<Pair<String, Double>> moduledeadline = new ArrayList<Pair <String, Double>>();


//if(placement.equals("Latency Differentiated Module Placement")) {		
//System.out.println(String.format("%-30s%s" ,"Per_User Differentiated Module Placement, " ," variable mips between 50 mips, "+  mymips+ " for all modules except cloud plus 1000 mips"));
//}		
//else if(placement.equals("Module Placement Edgeward")) {
//System.out.println(String.format("%-30s%20s%s%30s%10s%s" ,"Per_Module Edgeward Placement","const mips= " , mymips));
//System.out.println("Per_Module Placement,  Tuple's mips= " + mymips);
//}
///else 
//placement=="Latency Module Placement" 
//System.out.println(String.format("%-30s%20s%s%30s%10s%s" ,"Per_User Basic Module Placement","const mips= " , mymips));
//System.out.println("Per_User Basic Module Placement,  const mips= " + mymips);		

//System.out.println("Application Module mips: Client = Filtering = Monitoring = Caregiver = 300 mips , Cloud_Analytics = 600 mips");
//System.out.println("Migration Condition: Mobile Utilization >= 0.3, Proxy/Dept Utilization >= 0.9" );  //, RESOURCE_MANAGE_INTERVAL = 100 ");
//System.out.println("Enhanced Migration Conditions , RESOURCE_MANAGE_INTERVAL = 10 ");
//System.out.println("fog device scheduling interval = 10,  Application module scheduling interval = 300  ");	

//moduledeadline.put("Client", (x+ 15.0000000000000000));
//deadlineInfomodule.put(id,moduledeadline);
//moduledeadline.put("Caregiver", x);
//deadlineInfomodule.put(id,moduledeadline);				
//System.out.println("deadlineInfomodule  "+ deadlineInfomodule);
//deadlineInfomodule.put(id,moduledeadlinelist);				
//moduledeadline.clear();

/*
for(Integer id : idOfEndDevices){
	if (placement.equals("Latency Differentiated Module Placement")) {
		Integer x= getvalue(50, 500);//mymips);
		x= Math.abs(x);
		additionalMipsInfo.put(id, (double)x);  //getvalue(0,mymips)
		}
	else
		additionalMipsInfo.put(id, (double)mymips);
}
*/
/*else if(device.getName().startsWith("d")){
moduleMapping.addModuleToDevice("Filtering", device.getName());
moduleMapping.addModuleToDevice("Monitoring", device.getName());				
} */
//Controller controller = new Controller("master-controller", fogDevices, sensors, actuators);
//controller.submitApplication(application, 0, new ModulePlacementOnlyCloud(fogDevices, sensors, actuators, application));
//controller.submitApplication(application, 0, new LatencyModulePlacement(fogDevices, sensors, actuators, application, moduleMapping));
//controller.submitApplication(application, 0, new LatencyModifiedModulePlacementNew(fogDevices, sensors, actuators, application, moduleMapping));
 //LModulePlacementEdgewards  // LatencyModulePlacementNear

//TRY FogDevice cloud = createFogDevice("cloud", 448000000, 40000000, 100000, 10000000, 0, 0.01, 16*103, 16*83.25); // creates the fog device Cloud at the apex of the hierarchy with level=0
//FogDevice cloud = createFogDevice("cloud", 4480000, 4000000, 100, 10000, 0, 0.01, 16*103, 16*83.25); // creates the fog device Cloud at the apex of the hierarchy with level=0
//FogDevice proxy = createFogDevice("proxy-server", 2800, 4000, 10000, 10000, 1, 0.0, 107.339, 83.4333);

//peList.add(new Pe(0, new PeProvisionerSimple(mips))); // need to store Pe id and MIPS Rating


/*
application.addAppModule("Client", 10, 300, 1000,100,5); // adding module Client to the application model
application.addAppModule("Filtering",10, 300, 1000, 100,4); //
application.addAppModule("Monitoring",10, 300, 1000,100,3); // 
application.addAppModule("Caregiver", 10, 300,1000,100,2); // 
application.addAppModule("Cloud_Analytics",10, 600,1000,250,1); //("Cloud_Analytics",10, 500,1000,500,1); //
*/
/*application.addAppEdge("ECG", "Client", 3000, 1000, "ECG", Tuple.UP, AppEdge.SENSOR);
application.addAppEdge("Client", "Filtering", 3000, 500, "SENSOR_DATA", Tuple.UP, AppEdge.MODULE); //
application.addAppEdge("Filtering", "Monitoring", (30+ mymips), 500, "FILTERED_DATA", Tuple.UP, AppEdge.MODULE); // 
application.addAppEdge("Monitoring", "Cloud_Analytics", 1000, 500, "DATA_OFFLOAD", Tuple.UP, AppEdge.MODULE); // 
application.addAppEdge("Monitoring", "Caregiver", (60+ mymips) , 500, "ECG_REPORT", Tuple.UP, AppEdge.MODULE);  // 
application.addAppEdge("Cloud_Analytics", "Caregiver", 3500, 1000, "Advanced_Analytics", Tuple.DOWN, AppEdge.MODULE);  // 
application.addAppEdge("Caregiver", "Client", 1000 , 500, "State_Action", Tuple.DOWN, AppEdge.MODULE); // 
application.addAppEdge("Client", "DISPLAY",1000, 500, "P_State_Action", Tuple.DOWN, AppEdge.ACTUATOR);  //
 */
//application.addAppEdge("Caregiver", "Cloud_Analytics", 3000, 1000, "DECISION", Tuple.UP, AppEdge.MODULE); //
// application.addTupleMapping("Cloud_Analytics", "DECISION", "Advanced_Analytics", new FractionalSelectivity(0.001)); //
//final AppLoop HBR_Analytics = new AppLoop(new ArrayList<String>(){{add("HBR"); add("Client"); add("Monitoring"); add("Cloud_Analytics"); add("Caregiver"); add("Client"); add("DISPLAY");}});

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10085, count -3525, length 26115
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-10-15 12:36:55.962
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.StringIndexOutOfBoundsException: offset 10085, count -3525, length 26115
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:324)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10085, count -3525, length 26115
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	... 19 more
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10085, count -3525, length 26115
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2020-10-15 12:36:55.963
!MESSAGE offset 10085, count -3525, length 26115
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10085, count -3525, length 26115
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2020-10-15 12:36:55.963
!MESSAGE offset 10085, count -3525, length 26115
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10085, count -3525, length 26115
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-10-15 12:36:55.963
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.StringIndexOutOfBoundsException: offset 10085, count -3525, length 26115
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:324)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10085, count -3525, length 26115
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	... 19 more
Caused by: java.lang.StringIndexOutOfBoundsException: offset 10085, count -3525, length 26115
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2020-10-15 12:36:55.963
!MESSAGE offset 10085, count -3525, length 26115
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10085, count -3525, length 26115
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2020-10-15 12:36:56.975
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
package org.fog.test.perfeval;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.stream.Collectors;
import org.apache.commons.math3.util.Pair;
import org.cloudbus.cloudsim.Host;
import org.cloudbus.cloudsim.Log;
import org.cloudbus.cloudsim.Pe;
import org.cloudbus.cloudsim.Storage;
import org.cloudbus.cloudsim.core.CloudSim;
import org.cloudbus.cloudsim.power.PowerHost;
import org.cloudbus.cloudsim.provisioners.PeProvisionerSimple;
import org.cloudbus.cloudsim.provisioners.RamProvisionerSimple;
import org.cloudbus.cloudsim.sdn.overbooking.BwProvisionerOverbooking;
import org.cloudbus.cloudsim.sdn.overbooking.PeProvisionerOverbooking;
import org.fog.application.AppEdge;
import org.fog.application.AppLoop;
import org.fog.application.Application;
import org.fog.application.selectivity.FractionalSelectivity;
import org.fog.entities.Actuator;
import org.fog.entities.FogBroker;
import org.fog.entities.FogDevice;
import org.fog.entities.FogDeviceCharacteristics;
import org.fog.entities.Sensor;
import org.fog.entities.Tuple;
import org.fog.placement.Controller;
import org.fog.placement.ControllerEdgeward;
import org.fog.placement.LModulePlacementEdgewards;
import org.fog.placement.LatencyModulePlacementNear;
import org.fog.placement.ModuleMapping;
import org.fog.placement.ModulePlacementDifferentiated;
import org.fog.placement.ModulePlacementEdgewards;
import org.fog.placement.ModulePlacementMapping;
import org.fog.placement.ModulePlacementModified;
import org.fog.placement.ModulePlacementOnlyCloud;
import org.fog.policy.AppModuleAllocationPolicy;
import org.fog.scheduler.StreamOperatorScheduler;
import org.fog.utils.Config;
import org.fog.utils.FogLinearPowerModel;
import org.fog.utils.FogUtils;
import org.fog.utils.TimeKeeper;
import org.fog.utils.distribution.DeterministicDistribution;

/**
 * Simulation setup for  ECG
 * @author Ragaa Shehab
 *
 */ //updateTimingsOnReceipt - checkCloudletCompletion --tupleEndedExecutionUser
public class ECG {
	static List<FogDevice> fogDevices = new ArrayList<FogDevice>();
	static List<Sensor> sensors = new ArrayList<Sensor>();
	static List<Actuator> actuators = new ArrayList<Actuator>();
	static Map<Integer,FogDevice> deviceById = new HashMap<Integer,FogDevice>();	
	static List<Integer> idOfEndDevices = new ArrayList<Integer>();
	static Map<Integer, Double> deadlineInfo = new	HashMap<Integer, Double>();  // mobile id has priority
	static Map<Integer, Double> additionalMipsInfo = new HashMap<Integer, Double>(); // mobile id need tuple mips
	static Map<Integer, Map<String, Double>> deadlineInfomodule = new HashMap<Integer, Map<String,Double>>();  // mobile id has modulename with module priority
	static Map<Integer,List<Map<String, Double>>> deadlineInfomodule1 = new HashMap<Integer, List<Map<String,Double>>>();  // mobile id has modulename with module priority

	static boolean CLOUD = false;
	static int numOfDepts = 1;
	static int numOfMobilesPerDept =5;
	static double ECG_TRANSMISSION_TIME = 50.0 ; // 50.0;   //100, 50, 25 ms   100 //10s= 10000
	static public int mymips= 2000;     
	//static String placement = "Latency Module Placement"; 
	static String placement = "Latency Differentiated Module Placement"; 
	//static String placement = "Module Placement Edgeward";
	//static String placement = "Module Placement Edgeward Differentiated";
	//static String placement = "Latency Modified Module Placement";
	static double MobileCPUload= 0.1;
	
	public static void main(String[] args) {
		Log.print("Starting ECG transmission");	Log.print("             ECG transmission time ms: "); Log.print(ECG_TRANSMISSION_TIME);
		Log.print("     Depts/Mobiles =  "); Log.print (numOfDepts);Log.print("/"); Log.printLine (numOfMobilesPerDept);
		System.out.println("analytics VM mips  2000, Fog device mips: mobile 1000, dept  2800, proxy 16800" ); 

		
		try {
			Log.disable(); 	
			//Config.MAX_SIMULATION_TIME= 100000;
			int num_user = 1; // number of cloud users
			Calendar calendar = Calendar.getInstance();
			boolean trace_flag = false; // mean trace events
			CloudSim.init(num_user, calendar, trace_flag);						
			String appId = "ECG"; 
			FogBroker broker = new FogBroker("broker");			
			createFogDevices(broker.getId(), appId);
			
			Map<String, Double> moduledeadline= new HashMap<String, Double>();
			Map<String, Double> moduledeadline1;
			List<Map<String, Double>> moduledeadline1List;

			for(Integer id : idOfEndDevices){
				Double x= getvalue(5.00, 40.00);
				Double t1= 10.00; Double t2= 5.00; //Double t3= 5.00;
				deadlineInfo.put(id, x);
				
				if (placement.equals("Latency Differentiated Module Placement")||placement.equals("Module Placement Edgeward Differentiated")) {
						if((5.00 < x)&& (x < 10.00)) x=5.00;
						if(10.00 < x)&& (x < 15.00)) x=10.00;
						if(15.00 <  x)&& (x < 20.00)) x=20.00;
						if(20.00 < x)&& (x < 30.00)) x=30.00;
						if(30.00 <  x)&& (x < 40.00) x=40.00;
					
							
						
					additionalMipsInfo.put(id, x*100); //1000
					moduledeadline1=  new HashMap<String,Double>();
					moduledeadline1List= new ArrayList<Map<String, Double>>();
					moduledeadline1.put("Client", x*100);
					moduledeadline1.put("Filtering", x*100);
					moduledeadline1.put("Monitoring", x*100);
					moduledeadline1.put("Caregiver", x*100);
					moduledeadline1.put("Cloud_Analytics", x*100);
					moduledeadline1List.add(moduledeadline1);
					deadlineInfomodule1.put(id, moduledeadline1List);
				}
				else {
					additionalMipsInfo.put(id, (double)mymips);
					moduledeadline1=  new HashMap<String,Double>();
					moduledeadline1List= new ArrayList<Map<String, Double>>();
					moduledeadline1.put("Client", (double)mymips);
					moduledeadline1.put("Filtering", (double)mymips);
					moduledeadline1.put("Monitoring", (double)mymips);
					moduledeadline1.put("Caregiver", (double)mymips);
					moduledeadline1.put("Cloud_Analytics", (double)mymips);
					moduledeadline1List.add(moduledeadline1);
					deadlineInfomodule1.put(id, moduledeadline1List);
				}
				moduledeadline.put("Filtering", (x+t1));
				deadlineInfomodule.put(id,moduledeadline);
				moduledeadline.put("Monitoring", (x+ t2));
				deadlineInfomodule.put(id,moduledeadline);
			}	
			
			deadlineInfo=deadlineInfo.entrySet()
		             .stream().sorted(Map.Entry.comparingByValue())
		             .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -> e1, LinkedHashMap::new));			
				
			Application application = createApplication(appId, broker.getId());
			application.setUserId(broker.getId());
			application.setdeviceById(deviceById);
			application.setidOfEndDevices(idOfEndDevices);
			application.setDeadlineInfo(deadlineInfo);
			application.setDeadlineInfomodule(deadlineInfomodule);
			application.setDeadlineInfomodule1(deadlineInfomodule1);
		    application.setAdditionalMipsInfo(additionalMipsInfo);
		    application.setplacement(placement);
		    application.setMobileCPUload(MobileCPUload);
		    
		    System.out.println(String.format("%-25s%s" ,"User Priority ASC ", application.getDeadlineInfo()));
			System.out.println(String.format("%-25s%s" ,"Module Tuble MIPS ",application.getAdditionalMipsInfo()));
		   /// System.out.println(String.format("%-25s%s" ,"Module Priority ",application.getDeadlineInfomodule()));
		    System.out.println(String.format("%-25s%s" ,"Module Priority1 ",application.getDeadlineInfomodule1()));

		    System.out.println("mobile CPU load "+ application.getMobileCPUload());
		    		
			Controller controller = null;
			ModuleMapping moduleMapping = ModuleMapping.createModuleMapping(); // initializing a module mapping			
			moduleMapping.addModuleToDevice("Cloud_Analytics", "cloud");
			for(FogDevice device : fogDevices){
				if(device.getName().startsWith("m"))
					moduleMapping.addModuleToDevice("Client", device.getName());
				}
			if(CLOUD){			 
				moduleMapping.addModuleToDevice("Caregiver", "cloud");
				moduleMapping.addModuleToDevice("Monitoring", "cloud");
				moduleMapping.addModuleToDevice("Filtering", "cloud");
				System.out.println("cloud only module placement, tuple mips= "+ mymips);
				controller = new ControllerEdgeward("master-controller", fogDevices, sensors, actuators);
				controller.submitApplication(application, 0, new ModulePlacementMapping(fogDevices, application,moduleMapping));
				}
			else {
				moduleMapping.addModuleToDevice("Caregiver", "proxy-server");
				switch (placement) { 
				case "Latency Module Placement":{			
					System.out.println("Per User Basic module placement");//", Tuple mips= "+ mymips
					controller = new Controller("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LatencyModulePlacementNear(fogDevices, sensors, actuators, application, moduleMapping));
					break;}	
				case "Latency Modified Module Placement":{
					System.out.println("Per User Modified module placement");
					controller = new Controller("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new ModulePlacementModified(fogDevices, sensors, actuators, application, moduleMapping));
					break;}
				case "Latency Differentiated Module Placement":{
					System.out.println("Per User Differentiated module placement, variable Module/Tuple mips ");
					controller = new Controller("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LatencyModulePlacementNear(fogDevices, sensors, actuators, application, moduleMapping));
					break;} //ModulePlacementDifferentiated
				case "Module Placement Edgeward":{
					System.out.println("Per module placement");
					controller = new ControllerEdgeward("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LModulePlacementEdgewards(fogDevices, sensors, actuators, application, moduleMapping));
					break;}
				case "Module Placement Edgeward Differentiated":{
					System.out.println("Per module Differentiated placement");
					controller = new ControllerEdgeward("master-controller", fogDevices, sensors, actuators);
					controller.submitApplication(application, 0, new LModulePlacementEdgewards(fogDevices, sensors, actuators, application, moduleMapping));
					break;}
				}
				}
					
			TimeKeeper.getInstance().setSimulationStartTime(Calendar.getInstance().getTimeInMillis());
			CloudSim.startSimulation();
			CloudSim.stopSimulation();
			Log.printLine("ECG finished!");
		} catch (Exception e) {
			e.printStackTrace();
			Log.printLine("Unwanted errors happen");
		}
	}	
/****************************************************************************************
	 * Creates the fog devices in the physical topology of the simulation.
	 * @param userId
	 * @param appId
	 */
	private static void createFogDevices(int userId, String appId) {  // 44800
		FogDevice cloud = createFogDevice("cloud", 44800, 40000, 100, 10000, 0, 0.01, 16*103, 16*83.25); // creates the fog device Cloud at the apex of the hierarchy with level=0
		cloud.setParentId(-1);		 
		FogDevice proxy = createFogDevice("proxy-server", 16800 , 4000, 10000, 10000, 1, 0.0, 107.339, 83.4333); // 2800
		proxy.setParentId(cloud.getId()); // setting Cloud as parent of the Proxy Server
		proxy.setUplinkLatency(100); // latency of connection from Proxy Server to the Cloud is 100 ms		
		fogDevices.add(cloud);
		deviceById.put(cloud.getId(), cloud);
		fogDevices.add(proxy);
		deviceById.put(proxy.getId(), proxy);		
		for(int i=0;i<numOfDepts;i++){
			addGw(i+"", userId, appId, proxy.getId()); // adding a fog device for every Gateway in physical topology. The parent of each gateway is the Proxy Server
		}	
	}

	private static FogDevice addGw(String id, int userId, String appId, int parentId){
		FogDevice dept = createFogDevice("d-"+id, 2800, 4000, 10000, 10000, 2, 0.0, 107.339, 83.4333); //2800
		fogDevices.add(dept);
		deviceById.put(dept.getId(), dept);
		dept.setParentId(parentId);
		dept.setUplinkLatency(4); // latency of connection between gateways and proxy server is 4 ms
		for(int i=0;i<numOfMobilesPerDept;i++){
			String mobileId = id+"-"+i;
			FogDevice mobile = addMobile(mobileId, userId, appId, dept.getId()); // adding mobiles to the physical topology. Smartphones have been modeled as fog devices as well.
			mobile.setUplinkLatency(2); // latency of connection between the smartphone and proxy server is 4 ms
			fogDevices.add(mobile);
			deviceById.put(mobile.getId(), mobile);
		}
		return dept;
	}
	
	private static FogDevice addMobile(String id, int userId, String appId, int parentId){
		FogDevice mobile = createFogDevice("m-"+id, 1000, 1000, 10000, 270, 3, 0, 87.53, 82.44); //1000   
		mobile.setParentId(parentId);
		idOfEndDevices.add(mobile.getId());
		Sensor ecgsensor = new Sensor("s-"+id, "ECG", userId, appId, new DeterministicDistribution(ECG_TRANSMISSION_TIME)); // inter-transmission time of EEG sensor follows a deterministic distribution
		sensors.add(ecgsensor);
		Actuator display = new Actuator("a-"+id, userId, appId, "DISPLAY");
		actuators.add(display);
		ecgsensor.setGatewayDeviceId(mobile.getId());
		ecgsensor.setLatency(6.0);  // latency of connection between EEG sensors and the parent Smartphone is 6 ms
		display.setGatewayDeviceId(mobile.getId());
		display.setLatency(1.0);  // latency of connection between Display actuator and the parent Smartphone is 1 ms
		return mobile;
	}
	
/*****************************************************************************************
	 * Creates a vanilla fog device
	 * @param nodeName name of the device to be used in simulation
	 * @param mips MIPS
	 * @param ram RAM
	 * @param upBw uplink bandwidth
	 * @param downBw downlink bandwidth
	 * @param level hierarchy level of the device
	 * @param ratePerMips cost rate per MIPS used
	 * @param busyPower
	 * @param idlePower
	 * @return
	 */
	private static FogDevice createFogDevice(String nodeName, long mips,
			int ram, long upBw, long downBw, int level, double ratePerMips, double busyPower, double idlePower) {
		
		List<Pe> peList = new ArrayList<Pe>();
		// 3. Create PEs and add these into a list.
		peList.add(new Pe(0, new PeProvisionerOverbooking(mips))); // need to store Pe id and MIPS Rating
		
		int hostId = FogUtils.generateEntityId();
		long storage = 1000000; // host storage
		int bw = 10000;
		PowerHost host = new PowerHost(
				hostId,
				new RamProvisionerSimple(ram),
				new BwProvisionerOverbooking(bw),
				storage,
				peList,
				new StreamOperatorScheduler(peList),
				new FogLinearPowerModel(busyPower, idlePower)
			);

		List<Host> hostList = new ArrayList<Host>();
		hostList.add(host);

		String arch = "x86"; // system architecture
		String os = "Linux"; // operating system
		String vmm = "Xen";
		double time_zone = 10.0; // time zone this resource located
		double cost = 3.0; // the cost of using processing in this resource
		double costPerMem = 0.05; // the cost of using memory in this resource
		double costPerStorage = 0.001; // the cost of using storage in this	// resource
		double costPerBw = 0.0; // the cost of using bw in this resource
		LinkedList<Storage> storageList = new LinkedList<Storage>(); // we are not adding SAN devices by now

		FogDeviceCharacteristics characteristics = new FogDeviceCharacteristics(
				arch, os, vmm, host, time_zone, cost, costPerMem,
				costPerStorage, costPerBw);

		FogDevice fogdevice = null;
		try {
			fogdevice = new FogDevice(nodeName, characteristics, 
					new AppModuleAllocationPolicy(hostList), storageList, 10 , upBw, downBw, 0, ratePerMips); //10 : schedulingInterval  0 uplink  latency		
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		fogdevice.setLevel(level);
		return fogdevice;
	}

/******************************************************************************************
	 * Function to create the EEG Tractor Beam game application in the DDF model. 
	 * @param appId unique identifier of the application
	 * @param userId identifier of the user of the application
	 * @return
	 */
	@SuppressWarnings({"serial" })
	private static Application createApplication(String appId, int userId){
		
		Application application = Application.createApplication(appId, userId); // creates an empty application model (empty directed graph)
		
		// Adding modules (vertices) to the application model (directed graph)
		application.addAppModule("Client", 10, 2000, 1000,100,5); //250Name,int ram, int mips, long size, long bw, int modprty) size is the image size (MB)
		application.addAppModule("Filtering",10, 2000, 500, 100,4); //150
		application.addAppModule("Monitoring",10, 2000, 500,100,3); //150 
		application.addAppModule("Caregiver", 10, 2000,1000,100,2); // 150
		application.addAppModule("Cloud_Analytics",10, 3000,1000,250,1); //500("Cloud_Analytics",10, 500,1000,500,1); //
		
		// Connecting the application modules (vertices) in the application model (directed graph) with edges
		//source, destination, double tupleCpuLength, double tupleNwLength, String tupleType, int direction, int edgeType){
		application.addAppEdge("ECG", "Client", 2000, 500, "ECG", Tuple.UP, AppEdge.SENSOR);
		application.addAppEdge("Client", "Filtering", 2000, 500, "SENSOR_DATA", Tuple.UP, AppEdge.MODULE); //
		application.addAppEdge("Filtering", "Monitoring", mymips, 500, "FILTERED_DATA", Tuple.UP, AppEdge.MODULE); //
		application.addAppEdge("Monitoring", "Caregiver", mymips, 500, "ECG_REPORT", Tuple.UP, AppEdge.MODULE);  //
		application.addAppEdge("Caregiver", "Cloud_Analytics", mymips, 500, "DATA_OFFLOAD", Tuple.UP, AppEdge.MODULE); //		
		application.addAppEdge("Caregiver", "Client", mymips, 500, "State_Action", Tuple.DOWN, AppEdge.MODULE); //  
		application.addAppEdge("Client", "DISPLAY",2000, 500, "P_State_Action", Tuple.DOWN, AppEdge.ACTUATOR);  //
		application.addAppEdge("Cloud_Analytics", "Caregiver", 2000, 1000, "Advanced_Analytics", Tuple.DOWN, AppEdge.MODULE);  
		
 	    //Defining the input-output relationships (represented by selectivity) of the application modules. 
		application.addTupleMapping("Client", "ECG", "SENSOR_DATA", new FractionalSelectivity(1.0)); // 
		application.addTupleMapping("Client", "State_Action", "P_State_Action", new FractionalSelectivity(1.0)); //  
		application.addTupleMapping("Filtering", "SENSOR_DATA", "FILTERED_DATA", new FractionalSelectivity(1.0)); // 
		application.addTupleMapping("Monitoring", "FILTERED_DATA", "ECG_REPORT", new FractionalSelectivity(1.0)); //
		application.addTupleMapping("Caregiver", "ECG_REPORT", "DATA_OFFLOAD", new FractionalSelectivity(1.0)); //
		application.addTupleMapping("Caregiver", "ECG_REPORT", "State_Action", new FractionalSelectivity(1.0)); //
		application.addTupleMapping("Cloud_Analytics", "DATA_OFFLOAD", "Advanced_Analytics", new FractionalSelectivity(0.01)); //
	
		
		 // Defining application loops to monitor the latency of.
		//final AppLoop ONLY_CLOUD = new AppLoop(new ArrayList<String>(){{add("ECG");add("Client");add("Filtering");add("Monitoring");add("Caregiver");add("Client");add("DISPLAY");}}); //add("Cloud_Analytics");
        //List<AppLoop> loops = new ArrayList<AppLoop>(){{ add(ONLY_CLOUD);}};
		//final AppLoop ECG_REPORTING = new AppLoop(new ArrayList<String>(){{add("ECG");add("Client");add("Filtering");add("Monitoring");add("Caregiver");add("Client");add("DISPLAY");}});
        //List<AppLoop> loops = new ArrayList<AppLoop>(){{ add(ECG_REPORTING);}};
		final AppLoop ECG_ANALYTICS = new AppLoop(new ArrayList<String>(){{add("ECG");add("Client");add("Filtering");add("Monitoring");add("Caregiver");}});
        List<AppLoop> loops = new ArrayList<AppLoop>(){{add( ECG_ANALYTICS);}}; 
 		application.setLoops(loops);
		return application;
		}
///random number generators//////////////////////////////////////////////////////////
	private static double getvalue(double d, double e)  { 
	    Random r = new Random(); 
	    double randomValue = d + (e - d) *r.nextDouble(); 
	   // randomValue = r.nextDouble();
	    return randomValue; 
	  } 
	private static Integer getvalue(int min, int max) { 
	    Random r = new Random(); 
	    Integer randomValue = min + r.nextInt()%(max - min); 
	   // randomValue = r.nextInt(max);
	    return randomValue; 
	  }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//scheduled cloudlet processing =30,100,200,300,500 mips for filtering monitoring caregiver  
//scheduled cloudlet processing = 1000  for client and cloudanalytics modules
// mobile id, need Modulename executed with max delay (3:5)
//static Pair<String, Double> moduledeadline = new Pair <String, Double>(null,null);  // mobile id need deadline double
//static List<Pair<String, Double>> moduledeadline = new ArrayList<Pair <String, Double>>();


//if(placement.equals("Latency Differentiated Module Placement")) {		
//System.out.println(String.format("%-30s%s" ,"Per_User Differentiated Module Placement, " ," variable mips between 50 mips, "+  mymips+ " for all modules except cloud plus 1000 mips"));
//}		
//else if(placement.equals("Module Placement Edgeward")) {
//System.out.println(String.format("%-30s%20s%s%30s%10s%s" ,"Per_Module Edgeward Placement","const mips= " , mymips));
//System.out.println("Per_Module Placement,  Tuple's mips= " + mymips);
//}
///else 
//placement=="Latency Module Placement" 
//System.out.println(String.format("%-30s%20s%s%30s%10s%s" ,"Per_User Basic Module Placement","const mips= " , mymips));
//System.out.println("Per_User Basic Module Placement,  const mips= " + mymips);		

//System.out.println("Application Module mips: Client = Filtering = Monitoring = Caregiver = 300 mips , Cloud_Analytics = 600 mips");
//System.out.println("Migration Condition: Mobile Utilization >= 0.3, Proxy/Dept Utilization >= 0.9" );  //, RESOURCE_MANAGE_INTERVAL = 100 ");
//System.out.println("Enhanced Migration Conditions , RESOURCE_MANAGE_INTERVAL = 10 ");
//System.out.println("fog device scheduling interval = 10,  Application module scheduling interval = 300  ");	

//moduledeadline.put("Client", (x+ 15.0000000000000000));
//deadlineInfomodule.put(id,moduledeadline);
//moduledeadline.put("Caregiver", x);
//deadlineInfomodule.put(id,moduledeadline);				
//System.out.println("deadlineInfomodule  "+ deadlineInfomodule);
//deadlineInfomodule.put(id,moduledeadlinelist);				
//moduledeadline.clear();

/*
for(Integer id : idOfEndDevices){
	if (placement.equals("Latency Differentiated Module Placement")) {
		Integer x= getvalue(50, 500);//mymips);
		x= Math.abs(x);
		additionalMipsInfo.put(id, (double)x);  //getvalue(0,mymips)
		}
	else
		additionalMipsInfo.put(id, (double)mymips);
}
*/
/*else if(device.getName().startsWith("d")){
moduleMapping.addModuleToDevice("Filtering", device.getName());
moduleMapping.addModuleToDevice("Monitoring", device.getName());				
} */
//Controller controller = new Controller("master-controller", fogDevices, sensors, actuators);
//controller.submitApplication(application, 0, new ModulePlacementOnlyCloud(fogDevices, sensors, actuators, application));
//controller.submitApplication(application, 0, new LatencyModulePlacement(fogDevices, sensors, actuators, application, moduleMapping));
//controller.submitApplication(application, 0, new LatencyModifiedModulePlacementNew(fogDevices, sensors, actuators, application, moduleMapping));
 //LModulePlacementEdgewards  // LatencyModulePlacementNear

//TRY FogDevice cloud = createFogDevice("cloud", 448000000, 40000000, 100000, 10000000, 0, 0.01, 16*103, 16*83.25); // creates the fog device Cloud at the apex of the hierarchy with level=0
//FogDevice cloud = createFogDevice("cloud", 4480000, 4000000, 100, 10000, 0, 0.01, 16*103, 16*83.25); // creates the fog device Cloud at the apex of the hierarchy with level=0
//FogDevice proxy = createFogDevice("proxy-server", 2800, 4000, 10000, 10000, 1, 0.0, 107.339, 83.4333);

//peList.add(new Pe(0, new PeProvisionerSimple(mips))); // need to store Pe id and MIPS Rating


/*
application.addAppModule("Client", 10, 300, 1000,100,5); // adding module Client to the application model
application.addAppModule("Filtering",10, 300, 1000, 100,4); //
application.addAppModule("Monitoring",10, 300, 1000,100,3); // 
application.addAppModule("Caregiver", 10, 300,1000,100,2); // 
application.addAppModule("Cloud_Analytics",10, 600,1000,250,1); //("Cloud_Analytics",10, 500,1000,500,1); //
*/
/*application.addAppEdge("ECG", "Client", 3000, 1000, "ECG", Tuple.UP, AppEdge.SENSOR);
application.addAppEdge("Client", "Filtering", 3000, 500, "SENSOR_DATA", Tuple.UP, AppEdge.MODULE); //
application.addAppEdge("Filtering", "Monitoring", (30+ mymips), 500, "FILTERED_DATA", Tuple.UP, AppEdge.MODULE); // 
application.addAppEdge("Monitoring", "Cloud_Analytics", 1000, 500, "DATA_OFFLOAD", Tuple.UP, AppEdge.MODULE); // 
application.addAppEdge("Monitoring", "Caregiver", (60+ mymips) , 500, "ECG_REPORT", Tuple.UP, AppEdge.MODULE);  // 
application.addAppEdge("Cloud_Analytics", "Caregiver", 3500, 1000, "Advanced_Analytics", Tuple.DOWN, AppEdge.MODULE);  // 
application.addAppEdge("Caregiver", "Client", 1000 , 500, "State_Action", Tuple.DOWN, AppEdge.MODULE); // 
application.addAppEdge("Client", "DISPLAY",1000, 500, "P_State_Action", Tuple.DOWN, AppEdge.ACTUATOR);  //
 */
//application.addAppEdge("Caregiver", "Cloud_Analytics", 3000, 1000, "DECISION", Tuple.UP, AppEdge.MODULE); //
// application.addTupleMapping("Cloud_Analytics", "DECISION", "Advanced_Analytics", new FractionalSelectivity(0.001)); //
//final AppLoop HBR_Analytics = new AppLoop(new ArrayList<String>(){{add("HBR"); add("Client"); add("Monitoring"); add("Cloud_Analytics"); add("Caregiver"); add("Client"); add("DISPLAY");}});

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 10085, count -3525, length 26115
	at java.base/java.lang.String.checkBoundsOffCount(String.java:3741)
	at java.base/java.lang.String.rangeCheck(String.java:298)
	at java.base/java.lang.String.<init>(String.java:294)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1063)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1115)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:280)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:346)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
