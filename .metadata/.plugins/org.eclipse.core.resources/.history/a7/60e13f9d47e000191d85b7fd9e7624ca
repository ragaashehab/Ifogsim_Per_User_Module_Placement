package org.fog.test.perfeval;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Random;
import org.cloudbus.cloudsim.Host;
import org.cloudbus.cloudsim.Log;
import org.cloudbus.cloudsim.Pe;
import org.cloudbus.cloudsim.Storage;
import org.cloudbus.cloudsim.core.CloudSim;
import org.cloudbus.cloudsim.power.PowerHost;
import org.cloudbus.cloudsim.provisioners.PeProvisionerSimple;
import org.cloudbus.cloudsim.provisioners.RamProvisionerSimple;
import org.cloudbus.cloudsim.sdn.overbooking.BwProvisionerOverbooking;
import org.cloudbus.cloudsim.sdn.overbooking.PeProvisionerOverbooking;
import org.fog.application.AppEdge;
import org.fog.application.AppLoop;
import org.fog.application.Application;
import org.fog.application.selectivity.FractionalSelectivity;
import org.fog.entities.Actuator;
import org.fog.entities.FogBroker;
import org.fog.entities.FogDevice;
import org.fog.entities.FogDeviceCharacteristics;
import org.fog.entities.Sensor;
import org.fog.entities.Tuple;
import org.fog.placement.Controller;
import org.fog.placement.LModulePlacementEdgewards;
import org.fog.placement.LatencyDifferentiatedModulePlacement;
//import org.fog.placement.ECGLatencyDifferentiatedModulePlacement;
//import org.fog.placement.ECGLatencyModifiedModulePlacement;
//import org.fog.placement.ECGLatencyModulePlacement;
//import org.fog.placement.ECGModulePlacementEdgewards;
import org.fog.placement.LatencyModifiedModulePlacement;
import org.fog.placement.LatencyModifiedModulePlacementNEW;
import org.fog.placement.LatencyModulePlacement;
import org.fog.placement.LatencyModulePlacementNear;
import org.fog.placement.ModuleMapping;
import org.fog.placement.ModulePlacementEdgewards;
import org.fog.placement.ModulePlacementMapping;
import org.fog.placement.ModulePlacementOnlyCloud;
import org.fog.policy.AppModuleAllocationPolicy;
import org.fog.scheduler.StreamOperatorScheduler;
import org.fog.utils.Config;
import org.fog.utils.FogLinearPowerModel;
import org.fog.utils.FogUtils;
import org.fog.utils.TimeKeeper;
import org.fog.utils.distribution.DeterministicDistribution;

/**
 * Simulation setup for  ECG
 * @author Ragaa Shehab
 *
 */
public class ECG {
	static List<FogDevice> fogDevices = new ArrayList<FogDevice>();
	static List<Sensor> sensors = new ArrayList<Sensor>();
	static List<Actuator> actuators = new ArrayList<Actuator>();
	static Map<Integer,FogDevice> deviceById = new HashMap<Integer,FogDevice>();
	static List<Integer> idOfEndDevices = new ArrayList<Integer>(); 
	static Map<Integer, Double> deadlineInfo = new	HashMap<Integer, Double>();  // mobile id need deadline double
	static Map<Integer, Integer> additionalMipsInfo = new HashMap<Integer, Integer>(); // mobile id need additional mips int
	//static Map<String,Double> moduleDeadline = new HashMap<String,Double>();
	
	static boolean CLOUD = false;   // true       false
		
	static int numOfDepts = 1;
	static int numOfMobilesPerDept = 10;
	static double ECG_TRANSMISSION_TIME = 100.0;   //100, 50, 25 ms   100
	static public int mymips= 10;    //50.0: 0, 480, 1001//
	static String placement = "Latency Module Placement"; 
	//static String placement = "Latency Modified Module Placement";
	//static String placement = "Latency Differentiated Module Placement";   //ECGLatencyDifferentiatedModulePlacement
	//static String placement = "Module Placement Edgeward";  // 1500
	
	public static void main(String[] args) {

		Log.print("Starting ECG transmission");
		Log.print("     ECG transmission time ms: "); Log.print(ECG_TRANSMISSION_TIME);
		Log.print("     Depts/Mobiles =  "); Log.print (numOfDepts);Log.print("/"); Log.printLine (numOfMobilesPerDept);
		

		try {
			Log.disable(); 	//enable();   disable();
			//Config.MAX_SIMULATION_TIME= 100000;
			int num_user = 1; // number of cloud users
			Calendar calendar = Calendar.getInstance();
			boolean trace_flag = false; // mean trace events
			CloudSim.init(num_user, calendar, trace_flag);
			
			
			String appId = "ECG"; // identifier of the application
			FogBroker broker = new FogBroker("broker");

			createFogDevices(broker.getId(), appId);
			
			//moduleDeadline.put("Client", 0.0 );moduleDeadline.put("Filtering", 1.0 );	moduleDeadline.put("Monitoring", 2.0 );
			
			for(int id : idOfEndDevices){
				deadlineInfo.put(id, getvalue(0.00, 1.00));
				
				if (placement == "Latency Differentiated Module Placement")
					additionalMipsInfo.put(id, getvalue(0,mymips));
				else
					additionalMipsInfo.put(id, mymips);
			}
			
			Application application = createApplication(appId, broker.getId());
			application.setUserId(broker.getId());
			
			application.setDeadlineInfo(deadlineInfo); 
		    application.setAdditionalMipsInfo(additionalMipsInfo);
			
		    Controller controller = null;		    
			ModuleMapping moduleMapping = ModuleMapping.createModuleMapping(); // initializing a module mapping
			for(FogDevice device : fogDevices){
				if(device.getName().startsWith("m")){
					moduleMapping.addModuleToDevice("Client", device.getName());
					}
				}
			moduleMapping.addModuleToDevice("Cloud_Analytics", "cloud");
			moduleMapping.addModuleToDevice("Caregiver", "proxy-server");
			if(CLOUD){			 
			moduleMapping.addModuleToDevice("Caregiver", "cloud");
			moduleMapping.addModuleToDevice("Monitoring", "cloud");
			moduleMapping.addModuleToDevice("Filtering", "cloud");
			}
			/*else
			{
				moduleMapping.addModuleToDevice("Cloud_Analytics", "cloud"); 
				moduleMapping.addModuleToDevice("Caregiver", "proxy-server");
			}*/
			
			//Controller controller = new Controller("master-controller", fogDevices, sensors, actuators);
			controller = new Controller("master-controller", fogDevices, sensors, actuators);
			if(CLOUD){
				System.out.println("cloud only module placement, Additional mips= "+ mymips + " mips");
				controller.submitApplication(application, 0, new ModulePlacementMapping(fogDevices, application, moduleMapping));
				//controller.submitApplication(application, 0, new ModulePlacementOnlyCloud(fogDevices, sensors, actuators, application));   
				}
			else{
				switch (placement) { 
				case "Latency Module Placement":{			
					System.out.println("latency module placement, Additional mips= "+ mymips + " mips");
					//controller.submitApplication(application, 0, new LatencyModulePlacement(fogDevices, sensors, actuators, application, moduleMapping));
					controller.submitApplication(application, 0, new LatencyModulePlacementNear(fogDevices, sensors, actuators, application, moduleMapping));
					break;}	
				case "Latency Modified Module Placement":{
					System.out.println("latency modified module placement, Additional mips= "+ mymips + " mips");
					controller.submitApplication(application, 0, new LatencyModifiedModulePlacement(fogDevices, sensors, actuators, application, moduleMapping));
					//controller.submitApplication(application, 0, new LatencyModifiedModulePlacementNew(fogDevices, sensors, actuators, application, moduleMapping));
					break;}
				case "Latency Differentiated Module Placement":{
					System.out.println("latency differentiated module placement, Additional mips= "+ mymips + " mips");
					controller.submitApplication(application, 0, new LatencyDifferentiatedModulePlacement(fogDevices, sensors, actuators, application, moduleMapping));
					break;}
				case "Module Placement Edgeward":{
					System.out.println("Edgeward module placement, Additional mips= "+ mymips + " mips");			
					controller.submitApplication(application, 0, new LModulePlacementEdgewards(fogDevices, sensors, actuators, application, moduleMapping));
					//  ModulePlacementEdgewards
					break;}
				}
			}		
			
			TimeKeeper.getInstance().setSimulationStartTime(Calendar.getInstance().getTimeInMillis());
			CloudSim.startSimulation();
			CloudSim.stopSimulation();
			Log.printLine("ECG finished!");
		} catch (Exception e) {
			e.printStackTrace();
			Log.printLine("Unwanted errors happen");
		}
	}	
/****************************************************************************************
	 * Creates the fog devices in the physical topology of the simulation.
	 * @param userId
	 * @param appId
	 */
	private static void createFogDevices(int userId, String appId) {  // 44800
		FogDevice cloud = createFogDevice("cloud", 44800, 40000, 100, 10000, 0, 0.01, 16*103, 16*83.25); // creates the fog device Cloud at the apex of the hierarchy with level=0
		cloud.setParentId(-1);
		FogDevice proxy = createFogDevice("proxy-server", 2800, 4000, 10000, 10000, 1, 0.0, 107.339, 83.4333); // 2800
		proxy.setParentId(cloud.getId()); // setting Cloud as parent of the Proxy Server
		proxy.setUplinkLatency(100); // latency of connection from Proxy Server to the Cloud is 100 ms
		
		fogDevices.add(cloud);
		deviceById.put(cloud.getId(), cloud);
		fogDevices.add(proxy);
		deviceById.put(proxy.getId(), proxy);
		
		for(int i=0;i<numOfDepts;i++){
			addGw(i+"", userId, appId, proxy.getId()); // adding a fog device for every Gateway in physical topology. The parent of each gateway is the Proxy Server
		}
		
	}

	private static FogDevice addGw(String id, int userId, String appId, int parentId){
		FogDevice dept = createFogDevice("d-"+id, 2800, 4000, 10000, 10000, 2, 0.0, 107.339, 83.4333); //
		fogDevices.add(dept);
		deviceById.put(dept.getId(), dept);
		dept.setParentId(parentId);
		dept.setUplinkLatency(4); // latency of connection between gateways and proxy server is 4 ms
		for(int i=0;i<numOfMobilesPerDept;i++){
			String mobileId = id+"-"+i;
			FogDevice mobile = addMobile(mobileId, userId, appId, dept.getId()); // adding mobiles to the physical topology. Smartphones have been modeled as fog devices as well.
			mobile.setUplinkLatency(2); // latency of connection between the smartphone and proxy server is 4 ms
			fogDevices.add(mobile);
			deviceById.put(mobile.getId(), mobile);
		}
		return dept;
	}
	
	private static FogDevice addMobile(String id, int userId, String appId, int parentId){
		FogDevice mobile = createFogDevice("m-"+id, 1000, 1000, 10000, 270, 3, 0, 87.53, 82.44); //1000   
		mobile.setParentId(parentId);
		idOfEndDevices.add(mobile.getId());
		Sensor ecgsensor = new Sensor("s-"+id, "ECG", userId, appId, new DeterministicDistribution(ECG_TRANSMISSION_TIME)); // inter-transmission time of EEG sensor follows a deterministic distribution
		sensors.add(ecgsensor);
		Actuator display = new Actuator("a-"+id, userId, appId, "DISPLAY");
		actuators.add(display);
		ecgsensor.setGatewayDeviceId(mobile.getId());
		ecgsensor.setLatency(6.0);  // latency of connection between EEG sensors and the parent Smartphone is 6 ms
		display.setGatewayDeviceId(mobile.getId());
		display.setLatency(1.0);  // latency of connection between Display actuator and the parent Smartphone is 1 ms
		return mobile;
	}
	
/*****************************************************************************************
	 * Creates a vanilla fog device
	 * @param nodeName name of the device to be used in simulation
	 * @param mips MIPS
	 * @param ram RAM
	 * @param upBw uplink bandwidth
	 * @param downBw downlink bandwidth
	 * @param level hierarchy level of the device
	 * @param ratePerMips cost rate per MIPS used
	 * @param busyPower
	 * @param idlePower
	 * @return
	 */
	private static FogDevice createFogDevice(String nodeName, long mips,
			int ram, long upBw, long downBw, int level, double ratePerMips, double busyPower, double idlePower) {
		
		List<Pe> peList = new ArrayList<Pe>();
		// 3. Create PEs and add these into a list.
		//peList.add(new Pe(0, new PeProvisionerOverbooking(mips))); // need to store Pe id and MIPS Rating
		peList.add(new Pe(0, new PeProvisionerSimple(mips))); // need to store Pe id and MIPS Rating
		

		int hostId = FogUtils.generateEntityId();
		long storage = 1000000; // host storage
		int bw = 10000;

		PowerHost host = new PowerHost(
				hostId,
				new RamProvisionerSimple(ram),
				new BwProvisionerOverbooking(bw),
				storage,
				peList,
				new StreamOperatorScheduler(peList),
				new FogLinearPowerModel(busyPower, idlePower)
			);

		List<Host> hostList = new ArrayList<Host>();
		hostList.add(host);

		String arch = "x86"; // system architecture
		String os = "Linux"; // operating system
		String vmm = "Xen";
		double time_zone = 10.0; // time zone this resource located
		double cost = 3.0; // the cost of using processing in this resource
		double costPerMem = 0.05; // the cost of using memory in this resource
		double costPerStorage = 0.001; // the cost of using storage in this	// resource
		double costPerBw = 0.0; // the cost of using bw in this resource
		LinkedList<Storage> storageList = new LinkedList<Storage>(); // we are not adding SAN devices by now

		FogDeviceCharacteristics characteristics = new FogDeviceCharacteristics(
				arch, os, vmm, host, time_zone, cost, costPerMem,
				costPerStorage, costPerBw);

		FogDevice fogdevice = null;
		try {
			fogdevice = new FogDevice(nodeName, characteristics, 
					new AppModuleAllocationPolicy(hostList), storageList, 10, upBw, downBw, 0, ratePerMips); //10 : schedulingInterval  0 uplink  latency		
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		fogdevice.setLevel(level);
		return fogdevice;
	}

/******************************************************************************************
	 * Function to create the EEG Tractor Beam game application in the DDF model. 
	 * @param appId unique identifier of the application
	 * @param userId identifier of the user of the application
	 * @return
	 */
	@SuppressWarnings({"serial" })
	private static Application createApplication(String appId, int userId){
		
		Application application = Application.createApplication(appId, userId); // creates an empty application model (empty directed graph)
		
		/*
		 * Adding modules (vertices) to the application model (directed graph)
		 *  addAppModule(String moduleName,int ram, int mips, long size, long bw){ 
		 */		
		application.addAppModule("Client", 10, 300, 1000,100, 5); // adding module Client to the application model
		application.addAppModule("Filtering",10, 100, 500, 100,4); //
		application.addAppModule("Monitoring",10, 100, 500,100,3); // 
		application.addAppModule("Caregiver", 10, 100,1000,100,2); // 
		application.addAppModule("Cloud_Analytics",10, 2000,1000,500,1); //
		
		/*
		 * Connecting the application modules (vertices) in the application model (directed graph) with edges
		 
		application.addAppEdge("ECG", "Client", 3000, 1000, "ECG", Tuple.UP, AppEdge.SENSOR);
		application.addAppEdge("Client", "Filtering", 3000, 500, "SENSOR_DATA", Tuple.UP, AppEdge.MODULE); //
		application.addAppEdge("Filtering", "Monitoring", (30+ mymips), 500, "FILTERED_DATA", Tuple.UP, AppEdge.MODULE); // 
		application.addAppEdge("Monitoring", "Cloud_Analytics", 1000, 500, "DATA_OFFLOAD", Tuple.UP, AppEdge.MODULE); // 
		application.addAppEdge("Monitoring", "Caregiver", (60+ mymips) , 500, "ECG_REPORT", Tuple.UP, AppEdge.MODULE);  // 
		application.addAppEdge("Cloud_Analytics", "Caregiver", 3500, 1000, "Advanced_Analytics", Tuple.DOWN, AppEdge.MODULE);  // 
		application.addAppEdge("Caregiver", "Client", 1000 , 500, "State_Action", Tuple.DOWN, AppEdge.MODULE); // 
		application.addAppEdge("Client", "DISPLAY",1000, 500, "P_State_Action", Tuple.DOWN, AppEdge.ACTUATOR);  //
		 */
		application.addAppEdge("ECG", "Client", 2000, 1000, "ECG", Tuple.UP, AppEdge.SENSOR);
		application.addAppEdge("Client", "Filtering",  mymips, 500, "SENSOR_DATA", Tuple.UP, AppEdge.MODULE); // 1000
		application.addAppEdge("Filtering", "Monitoring", mymips, 500, "FILTERED_DATA", Tuple.UP, AppEdge.MODULE); //		 
		application.addAppEdge("Monitoring", "Caregiver",  mymips , 500, "ECG_REPORT", Tuple.UP, AppEdge.MODULE);  //
		//application.addAppEdge("Caregiver", "Client", 1000 , 500, "State_Action", Tuple.DOWN, AppEdge.MODULE); //
		application.addAppEdge("Caregiver", "Client",  mymips , 500, "State_Action", Tuple.DOWN, AppEdge.MODULE); //
		application.addAppEdge("Client", "DISPLAY",1000, 500, "P_State_Action", Tuple.DOWN, AppEdge.ACTUATOR);  //
		application.addAppEdge("Monitoring", "Cloud_Analytics", 1000, 500, "DATA_OFFLOAD", Tuple.UP, AppEdge.MODULE); //
		application.addAppEdge("Cloud_Analytics", "Caregiver", 3000, 1000, "Advanced_Analytics", Tuple.DOWN, AppEdge.MODULE);  // 
		
		

		//application.addAppEdge("Caregiver", "Cloud_Analytics", 3000, 1000, "DECISION", Tuple.UP, AppEdge.MODULE); //
		// application.addTupleMapping("Cloud_Analytics", "DECISION", "Advanced_Analytics", new FractionalSelectivity(0.001)); //

		/*
		 * Defining the input-output relationships (represented by selectivity) of the application modules. 
		 */
		application.addTupleMapping("Client", "ECG", "SENSOR_DATA", new FractionalSelectivity(1.0)); // 
		application.addTupleMapping("Client", "State_Action", "P_State_Action", new FractionalSelectivity(1.0)); //  
		application.addTupleMapping("Filtering", "SENSOR_DATA", "FILTERED_DATA", new FractionalSelectivity(1.0)); //
		application.addTupleMapping("Monitoring", "FILTERED_DATA", "DATA_OFFLOAD", new FractionalSelectivity(1.0)); // 
		application.addTupleMapping("Monitoring", "FILTERED_DATA", "ECG_REPORT", new FractionalSelectivity(1.0)); //   
		application.addTupleMapping("Caregiver", "ECG_REPORT", "State_Action", new FractionalSelectivity(1.0)); //
		application.addTupleMapping("Cloud_Analytics", "DATA_OFFLOAD", "Advanced_Analytics", new FractionalSelectivity(0.01)); //
		//application.addTupleMapping("Caregiver", "Advanced_Analytics", "State_Action", new FractionalSelectivity(1.0)); //
		
		/*
		 * Defining application loops to monitor the latency of.
		 */
		final AppLoop ECG_REPORTING = new AppLoop(new ArrayList<String>(){{add("ECG");add("Client");add("Filtering");add("Monitoring");add("Caregiver");add("Client");add("DISPLAY");}});
        //final AppLoop HBR_Analytics = new AppLoop(new ArrayList<String>(){{add("HBR"); add("Client"); add("Monitoring"); add("Cloud_Analytics"); add("Caregiver"); add("Client"); add("DISPLAY");}});
        List<AppLoop> loops = new ArrayList<AppLoop>(){{ add(ECG_REPORTING);}};  // add(HBR_Analytics);
 		application.setLoops(loops);
		return application;
}
///random number generators//////////////////////////////////////////////////////////
	private static double getvalue(double d, double e)  { 
	    Random r = new Random(); 
	    double randomValue = d + (e - d) *r.nextDouble(); 
	    randomValue = r.nextDouble();
	    return randomValue; 
	  } 
	private static int getvalue(int min, int max) { 
	    Random r = new Random(); 
	    int randomValue = min + r.nextInt()%(max - min); 
	    randomValue = r.nextInt(max);
	    return randomValue; 
	  }
/////////////////////////////////////////////////////////////
}